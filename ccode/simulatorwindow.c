/* simulatorwindow.c generated by valac 0.18.1, the Vala compiler
 * generated from simulatorwindow.vala, do not modify */

/* 
 * SmartSim - Digital Logic Circuit Designer and Simulator
 *   
 *   Expansion Version
 *   
 *   Filename: simulatorwindow.vala
 *   
 *   Copyright Ashley Newson 2012
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <cairo.h>
#include <gdk/gdk.h>


#define TYPE_SIMULATOR_WINDOW (simulator_window_get_type ())
#define SIMULATOR_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SIMULATOR_WINDOW, SimulatorWindow))
#define SIMULATOR_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SIMULATOR_WINDOW, SimulatorWindowClass))
#define IS_SIMULATOR_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SIMULATOR_WINDOW))
#define IS_SIMULATOR_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SIMULATOR_WINDOW))
#define SIMULATOR_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SIMULATOR_WINDOW, SimulatorWindowClass))

typedef struct _SimulatorWindow SimulatorWindow;
typedef struct _SimulatorWindowClass SimulatorWindowClass;
typedef struct _SimulatorWindowPrivate SimulatorWindowPrivate;

#define TYPE_COMPILED_CIRCUIT (compiled_circuit_get_type ())
#define COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuit))
#define COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))
#define IS_COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPILED_CIRCUIT))
#define IS_COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPILED_CIRCUIT))
#define COMPILED_CIRCUIT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))

typedef struct _CompiledCircuit CompiledCircuit;
typedef struct _CompiledCircuitClass CompiledCircuitClass;

#define SIMULATOR_WINDOW_TYPE_MOUSE_MODE (simulator_window_mouse_mode_get_type ())

#define SIMULATOR_WINDOW_TYPE_RUN_STATE (simulator_window_run_state_get_type ())

#define TYPE_TIMING_DIAGRAM (timing_diagram_get_type ())
#define TIMING_DIAGRAM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TIMING_DIAGRAM, TimingDiagram))
#define TIMING_DIAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TIMING_DIAGRAM, TimingDiagramClass))
#define IS_TIMING_DIAGRAM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TIMING_DIAGRAM))
#define IS_TIMING_DIAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TIMING_DIAGRAM))
#define TIMING_DIAGRAM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TIMING_DIAGRAM, TimingDiagramClass))

typedef struct _TimingDiagram TimingDiagram;
typedef struct _TimingDiagramClass TimingDiagramClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _compiled_circuit_unref0(var) ((var == NULL) ? NULL : (var = (compiled_circuit_unref (var), NULL)))
typedef struct _CompiledCircuitPrivate CompiledCircuitPrivate;

#define TYPE_COMPONENT_DEF (component_def_get_type ())
#define COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_DEF, ComponentDef))
#define COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_DEF, ComponentDefClass))
#define IS_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_DEF))
#define IS_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_DEF))
#define COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_DEF, ComponentDefClass))

typedef struct _ComponentDef ComponentDef;
typedef struct _ComponentDefClass ComponentDefClass;

#define TYPE_CUSTOM_COMPONENT_DEF (custom_component_def_get_type ())
#define CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDef))
#define CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))
#define IS_CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_COMPONENT_DEF))
#define IS_CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOM_COMPONENT_DEF))
#define CUSTOM_COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))

typedef struct _CustomComponentDef CustomComponentDef;
typedef struct _CustomComponentDefClass CustomComponentDefClass;

#define TYPE_PROJECT (project_get_type ())
#define PROJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROJECT, Project))
#define PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROJECT, ProjectClass))
#define IS_PROJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROJECT))
#define IS_PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROJECT))
#define PROJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROJECT, ProjectClass))

typedef struct _Project Project;
typedef struct _ProjectClass ProjectClass;

#define TYPE_UPDATE_QUEUE (update_queue_get_type ())
#define UPDATE_QUEUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UPDATE_QUEUE, UpdateQueue))
#define UPDATE_QUEUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UPDATE_QUEUE, UpdateQueueClass))
#define IS_UPDATE_QUEUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UPDATE_QUEUE))
#define IS_UPDATE_QUEUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UPDATE_QUEUE))
#define UPDATE_QUEUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UPDATE_QUEUE, UpdateQueueClass))

typedef struct _UpdateQueue UpdateQueue;
typedef struct _UpdateQueueClass UpdateQueueClass;

#define TYPE_WIRE_STATE (wire_state_get_type ())
#define WIRE_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WIRE_STATE, WireState))
#define WIRE_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WIRE_STATE, WireStateClass))
#define IS_WIRE_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WIRE_STATE))
#define IS_WIRE_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WIRE_STATE))
#define WIRE_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WIRE_STATE, WireStateClass))

typedef struct _WireState WireState;
typedef struct _WireStateClass WireStateClass;

#define TYPE_COMPONENT_STATE (component_state_get_type ())
#define COMPONENT_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_STATE, ComponentState))
#define COMPONENT_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_STATE, ComponentStateClass))
#define IS_COMPONENT_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_STATE))
#define IS_COMPONENT_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_STATE))
#define COMPONENT_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_STATE, ComponentStateClass))

typedef struct _ComponentState ComponentState;
typedef struct _ComponentStateClass ComponentStateClass;
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _wire_state_unref0(var) ((var == NULL) ? NULL : (var = (wire_state_unref (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
typedef struct _ProjectPrivate ProjectPrivate;

#define TYPE_PLUGIN_COMPONENT_DEF (plugin_component_def_get_type ())
#define PLUGIN_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLUGIN_COMPONENT_DEF, PluginComponentDef))
#define PLUGIN_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLUGIN_COMPONENT_DEF, PluginComponentDefClass))
#define IS_PLUGIN_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLUGIN_COMPONENT_DEF))
#define IS_PLUGIN_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLUGIN_COMPONENT_DEF))
#define PLUGIN_COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLUGIN_COMPONENT_DEF, PluginComponentDefClass))

typedef struct _PluginComponentDef PluginComponentDef;
typedef struct _PluginComponentDefClass PluginComponentDefClass;

#define TYPE_PLUGIN_COMPONENT_MANAGER (plugin_component_manager_get_type ())
#define PLUGIN_COMPONENT_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLUGIN_COMPONENT_MANAGER, PluginComponentManager))
#define PLUGIN_COMPONENT_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLUGIN_COMPONENT_MANAGER, PluginComponentManagerClass))
#define IS_PLUGIN_COMPONENT_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLUGIN_COMPONENT_MANAGER))
#define IS_PLUGIN_COMPONENT_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLUGIN_COMPONENT_MANAGER))
#define PLUGIN_COMPONENT_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLUGIN_COMPONENT_MANAGER, PluginComponentManagerClass))

typedef struct _PluginComponentManager PluginComponentManager;
typedef struct _PluginComponentManagerClass PluginComponentManagerClass;

struct _SimulatorWindow {
	GtkWindow parent_instance;
	SimulatorWindowPrivate * priv;
	gint gridSize;
	gfloat zoom;
};

struct _SimulatorWindowClass {
	GtkWindowClass parent_class;
};

typedef enum  {
	SIMULATOR_WINDOW_MOUSE_MODE_SCROLL,
	SIMULATOR_WINDOW_MOUSE_MODE_ZOOM,
	SIMULATOR_WINDOW_MOUSE_MODE_CONTEXT,
	SIMULATOR_WINDOW_MOUSE_MODE_INTERACT,
	SIMULATOR_WINDOW_MOUSE_MODE_EXPLORE,
	SIMULATOR_WINDOW_MOUSE_MODE_WATCH
} SimulatorWindowMouseMode;

typedef enum  {
	SIMULATOR_WINDOW_RUN_STATE_PAUSED,
	SIMULATOR_WINDOW_RUN_STATE_STEPPING,
	SIMULATOR_WINDOW_RUN_STATE_RUNNING,
	SIMULATOR_WINDOW_RUN_STATE_HALTING,
	SIMULATOR_WINDOW_RUN_STATE_ERROR
} SimulatorWindowRunState;

struct _SimulatorWindowPrivate {
	GtkBox* vBox;
	GtkMenuBar* menubar;
	GtkMenuItem* menuSimulation;
	GtkMenu* menuSimulationMenu;
	GtkCheckMenuItem* menuSimulationRun;
	GtkMenuItem* menuSimulationSeparator1;
	GtkMenuItem* menuSimulationExit;
	GtkMenuItem* menuView;
	GtkMenu* menuViewMenu;
	GtkMenuItem* menuViewFitdesign;
	GtkCheckMenuItem* menuViewAutofitdesign;
	GtkMenuItem* menuViewSeparator1;
	GtkMenuItem* menuViewTimingdiagram;
	GtkToolbar* toolbar;
	GtkRadioToolButton* toolScroll;
	GtkImage* toolScrollImage;
	GtkRadioToolButton* toolZoom;
	GtkImage* toolZoomImage;
	GtkSeparatorToolItem* toolSeparator1;
	GtkRadioToolButton* toolContext;
	GtkImage* toolContextImage;
	GtkRadioToolButton* toolInteract;
	GtkImage* toolInteractImage;
	GtkRadioToolButton* toolExplore;
	GtkImage* toolExploreImage;
	GtkRadioToolButton* toolWatch;
	GtkImage* toolWatchImage;
	GtkSeparatorToolItem* toolSeparator2;
	GtkToolButton* toolShrink;
	GtkImage* toolShrinkImage;
	GtkSeparatorToolItem* toolSeparator3;
	GtkToggleToolButton* toolRun;
	GtkImage* toolRunImage;
	GtkToolButton* toolSinglestep;
	GtkImage* toolSinglestepImage;
	GtkToolButton* toolMultistep;
	GtkImage* toolMultistepImage;
	GtkSeparatorToolItem* toolSeparator4;
	GtkToggleToolButton* toolMaxspeed;
	GtkImage* toolMaxspeedImage;
	GtkToolItem* toolSpeed;
	GtkBox* toolSpeedBox;
	GtkLabel* toolSpeedLabel;
	GtkSpinButton* toolSpeedSpin;
	GtkSeparatorToolItem* toolSeparator5;
	GtkToolItem* toolStepsize;
	GtkBox* toolStepsizeBox;
	GtkLabel* toolStepsizeLabel;
	GtkSpinButton* toolStepsizeSpin;
	GtkEventBox* controller;
	GtkDrawingArea* display;
	CompiledCircuit* compiledCircuit;
	gint xMouseStart;
	gint yMouseStart;
	SimulatorWindowMouseMode mouseMode;
	gint xView;
	gint yView;
	SimulatorWindowRunState runState;
	gint cycleDelay;
	gint multistepSize;
	gint stepsLeft;
	guint cycleSourceID;
	guint refreshSourceID;
	gint microCycleDelay;
	gdouble timeBeforeRender;
	gboolean inhibitRender;
	gboolean autoFitDesign;
	TimingDiagram* timingDiagram;
};

struct _CompiledCircuit {
	GTypeInstance parent_instance;
	volatile int ref_count;
	CompiledCircuitPrivate * priv;
	CustomComponentDef* rootComponent;
	Project* project;
	UpdateQueue* renderWireStates;
	UpdateQueue* renderComponentStates;
	UpdateQueue* processWireStates;
	UpdateQueue* processComponentStates;
	CustomComponentDef* viewedComponent;
	gint iterationCount;
};

struct _CompiledCircuitClass {
	GTypeClass parent_class;
	void (*finalize) (CompiledCircuit *self);
};

struct _Project {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ProjectPrivate * priv;
	gboolean running;
	CustomComponentDef** customComponentDefs;
	gint customComponentDefs_length1;
	PluginComponentDef** pluginComponentDefs;
	gint pluginComponentDefs_length1;
	PluginComponentManager** pluginComponentManagers;
	gint pluginComponentManagers_length1;
	CustomComponentDef* rootComponent;
	gint myID;
	gchar* description;
	gchar* filename;
};

struct _ProjectClass {
	GTypeClass parent_class;
	void (*finalize) (Project *self);
};


static gpointer simulator_window_parent_class = NULL;

GType simulator_window_get_type (void) G_GNUC_CONST;
gpointer compiled_circuit_ref (gpointer instance);
void compiled_circuit_unref (gpointer instance);
GParamSpec* param_spec_compiled_circuit (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_compiled_circuit (GValue* value, gpointer v_object);
void value_take_compiled_circuit (GValue* value, gpointer v_object);
gpointer value_get_compiled_circuit (const GValue* value);
GType compiled_circuit_get_type (void) G_GNUC_CONST;
static GType simulator_window_mouse_mode_get_type (void) G_GNUC_UNUSED;
GType simulator_window_run_state_get_type (void) G_GNUC_CONST;
GType timing_diagram_get_type (void) G_GNUC_CONST;
#define SIMULATOR_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SIMULATOR_WINDOW, SimulatorWindowPrivate))
enum  {
	SIMULATOR_WINDOW_DUMMY_PROPERTY
};
void timing_diagram_close_diagram (TimingDiagram* self);
SimulatorWindow* simulator_window_new (CompiledCircuit* compiledCircuit);
SimulatorWindow* simulator_window_construct (GType object_type, CompiledCircuit* compiledCircuit);
void simulator_window_populate (SimulatorWindow* self);
void simulator_window_close_simulation (SimulatorWindow* self);
static void _simulator_window_close_simulation_gtk_widget_destroy (GtkWidget* _sender, gpointer self);
#define CORE_programName "SmartSim"
static void __lambda37_ (SimulatorWindow* self);
static void simulator_window_run_toggle (SimulatorWindow* self, GtkWidget* widget);
static void ___lambda37__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static void __lambda38_ (SimulatorWindow* self);
static void ___lambda38__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda39_ (SimulatorWindow* self);
static void simulator_window_fit_design (SimulatorWindow* self);
static void ___lambda39__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda40_ (SimulatorWindow* self, GtkCheckMenuItem* menuItem);
static void ___lambda40__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static void __lambda41_ (SimulatorWindow* self);
static void simulator_window_show_timing_diagram (SimulatorWindow* self);
static void ___lambda41__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda42_ (SimulatorWindow* self);
static void ___lambda42__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda43_ (SimulatorWindow* self);
static void ___lambda43__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda44_ (SimulatorWindow* self);
static void ___lambda44__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda45_ (SimulatorWindow* self);
static void ___lambda45__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda46_ (SimulatorWindow* self);
static void ___lambda46__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda47_ (SimulatorWindow* self);
static void ___lambda47__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda48_ (SimulatorWindow* self);
void compiled_circuit_shrink_component (CompiledCircuit* self);
gboolean simulator_window_render (SimulatorWindow* self, gboolean fullRefresh, gboolean cancelIfRunning, cairo_t* passedDisplayContext);
static void ___lambda48__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda49_ (SimulatorWindow* self);
static void ___lambda49__gtk_toggle_tool_button_toggled (GtkToggleToolButton* _sender, gpointer self);
static void __lambda50_ (SimulatorWindow* self);
static void simulator_window_step (SimulatorWindow* self, gboolean multistep);
static void ___lambda50__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda51_ (SimulatorWindow* self);
static void ___lambda51__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda52_ (SimulatorWindow* self);
static void simulator_window_change_speed (SimulatorWindow* self, gint newCycleDelay);
static void ___lambda52__gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self);
static void __lambda53_ (SimulatorWindow* self);
static void ___lambda53__gtk_toggle_tool_button_toggled (GtkToggleToolButton* _sender, gpointer self);
static void __lambda54_ (SimulatorWindow* self);
static void ___lambda54__gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self);
static gboolean simulator_window_mouse_down (SimulatorWindow* self, GdkEventButton* event);
static gboolean _simulator_window_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean simulator_window_mouse_up (SimulatorWindow* self, GdkEventButton* event);
static gboolean _simulator_window_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean __lambda55_ (SimulatorWindow* self, cairo_t* context);
static gboolean ___lambda55__gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self);
TimingDiagram* timing_diagram_new (CompiledCircuit* compiledCircuit);
TimingDiagram* timing_diagram_construct (GType object_type, CompiledCircuit* compiledCircuit);
void simulator_window_pause (SimulatorWindow* self);
void simulator_window_run (SimulatorWindow* self);
static gboolean simulator_window_update_cycle (SimulatorWindow* self);
static gboolean _simulator_window_update_cycle_gsource_func (gpointer self);
static gboolean simulator_window_refresh_cycle (SimulatorWindow* self);
static gboolean _simulator_window_refresh_cycle_gsource_func (gpointer self);
gboolean timing_diagram_render (TimingDiagram* self, gboolean fullRefresh, cairo_t* passedDisplayContext);
void timing_diagram_show_diagram (TimingDiagram* self);
gpointer component_def_ref (gpointer instance);
void component_def_unref (gpointer instance);
GParamSpec* param_spec_component_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_def (GValue* value, gpointer v_object);
void value_take_component_def (GValue* value, gpointer v_object);
gpointer value_get_component_def (const GValue* value);
GType component_def_get_type (void) G_GNUC_CONST;
GType custom_component_def_get_type (void) G_GNUC_CONST;
gpointer project_ref (gpointer instance);
void project_unref (gpointer instance);
GParamSpec* param_spec_project (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_project (GValue* value, gpointer v_object);
void value_take_project (GValue* value, gpointer v_object);
gpointer value_get_project (const GValue* value);
GType project_get_type (void) G_GNUC_CONST;
gpointer update_queue_ref (gpointer instance);
void update_queue_unref (gpointer instance);
GParamSpec* param_spec_update_queue (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_update_queue (GValue* value, gpointer v_object);
void value_take_update_queue (GValue* value, gpointer v_object);
gpointer value_get_update_queue (const GValue* value);
GType update_queue_get_type (void) G_GNUC_CONST;
gpointer wire_state_ref (gpointer instance);
void wire_state_unref (gpointer instance);
GParamSpec* param_spec_wire_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_wire_state (GValue* value, gpointer v_object);
void value_take_wire_state (GValue* value, gpointer v_object);
gpointer value_get_wire_state (const GValue* value);
GType wire_state_get_type (void) G_GNUC_CONST;
gpointer component_state_ref (gpointer instance);
void component_state_unref (gpointer instance);
GParamSpec* param_spec_component_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_state (GValue* value, gpointer v_object);
void value_take_component_state (GValue* value, gpointer v_object);
gpointer value_get_component_state (const GValue* value);
GType component_state_get_type (void) G_GNUC_CONST;
void custom_component_def_get_design_bounds (CustomComponentDef* self, gint* right, gint* down, gint* left, gint* up);
gint compiled_circuit_update_cycle (CompiledCircuit* self);
const gchar* compiled_circuit_get_errorMessage (CompiledCircuit* self);
void basic_dialog_error (GtkWindow* window, const gchar* text);
void compiled_circuit_interact_components (CompiledCircuit* self, gint xInteract, gint yInteract);
gint compiled_circuit_expand_component (CompiledCircuit* self, gint x, gint y);
WireState* compiled_circuit_find_wire (CompiledCircuit* self, gint x, gint y);
void timing_diagram_add_wire (TimingDiagram* self, WireState* newWireState);
void compiled_circuit_render (CompiledCircuit* self, cairo_t* context, gboolean fullRender, gfloat zoom);
void basic_dialog_information (GtkWindow* window, const gchar* text);
GType plugin_component_def_get_type (void) G_GNUC_CONST;
gpointer plugin_component_manager_ref (gpointer instance);
void plugin_component_manager_unref (gpointer instance);
GParamSpec* param_spec_plugin_component_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_plugin_component_manager (GValue* value, gpointer v_object);
void value_take_plugin_component_manager (GValue* value, gpointer v_object);
gpointer value_get_plugin_component_manager (const GValue* value);
GType plugin_component_manager_get_type (void) G_GNUC_CONST;
static void simulator_window_finalize (GObject* obj);


/**
 * Actions to perform when the mouse button is released.
 */
static GType simulator_window_mouse_mode_get_type (void) {
	static volatile gsize simulator_window_mouse_mode_type_id__volatile = 0;
	if (g_once_init_enter (&simulator_window_mouse_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{SIMULATOR_WINDOW_MOUSE_MODE_SCROLL, "SIMULATOR_WINDOW_MOUSE_MODE_SCROLL", "scroll"}, {SIMULATOR_WINDOW_MOUSE_MODE_ZOOM, "SIMULATOR_WINDOW_MOUSE_MODE_ZOOM", "zoom"}, {SIMULATOR_WINDOW_MOUSE_MODE_CONTEXT, "SIMULATOR_WINDOW_MOUSE_MODE_CONTEXT", "context"}, {SIMULATOR_WINDOW_MOUSE_MODE_INTERACT, "SIMULATOR_WINDOW_MOUSE_MODE_INTERACT", "interact"}, {SIMULATOR_WINDOW_MOUSE_MODE_EXPLORE, "SIMULATOR_WINDOW_MOUSE_MODE_EXPLORE", "explore"}, {SIMULATOR_WINDOW_MOUSE_MODE_WATCH, "SIMULATOR_WINDOW_MOUSE_MODE_WATCH", "watch"}, {0, NULL, NULL}};
		GType simulator_window_mouse_mode_type_id;
		simulator_window_mouse_mode_type_id = g_enum_register_static ("SimulatorWindowMouseMode", values);
		g_once_init_leave (&simulator_window_mouse_mode_type_id__volatile, simulator_window_mouse_mode_type_id);
	}
	return simulator_window_mouse_mode_type_id__volatile;
}


/**
 * The states the simulation can be in. (e.g. running, paused...)
 */
GType simulator_window_run_state_get_type (void) {
	static volatile gsize simulator_window_run_state_type_id__volatile = 0;
	if (g_once_init_enter (&simulator_window_run_state_type_id__volatile)) {
		static const GEnumValue values[] = {{SIMULATOR_WINDOW_RUN_STATE_PAUSED, "SIMULATOR_WINDOW_RUN_STATE_PAUSED", "paused"}, {SIMULATOR_WINDOW_RUN_STATE_STEPPING, "SIMULATOR_WINDOW_RUN_STATE_STEPPING", "stepping"}, {SIMULATOR_WINDOW_RUN_STATE_RUNNING, "SIMULATOR_WINDOW_RUN_STATE_RUNNING", "running"}, {SIMULATOR_WINDOW_RUN_STATE_HALTING, "SIMULATOR_WINDOW_RUN_STATE_HALTING", "halting"}, {SIMULATOR_WINDOW_RUN_STATE_ERROR, "SIMULATOR_WINDOW_RUN_STATE_ERROR", "error"}, {0, NULL, NULL}};
		GType simulator_window_run_state_type_id;
		simulator_window_run_state_type_id = g_enum_register_static ("SimulatorWindowRunState", values);
		g_once_init_leave (&simulator_window_run_state_type_id__volatile, simulator_window_run_state_type_id);
	}
	return simulator_window_run_state_type_id__volatile;
}


/**
 * Creates a new Simulator window associated with the
 * CompiledCircuit //compiledCircuit//.
 */
static gpointer _compiled_circuit_ref0 (gpointer self) {
	return self ? compiled_circuit_ref (self) : NULL;
}


SimulatorWindow* simulator_window_construct (GType object_type, CompiledCircuit* compiledCircuit) {
	SimulatorWindow * self = NULL;
	CompiledCircuit* _tmp0_;
	CompiledCircuit* _tmp1_;
	g_return_val_if_fail (compiledCircuit != NULL, NULL);
	self = (SimulatorWindow*) g_object_new (object_type, NULL);
	_tmp0_ = compiledCircuit;
	_tmp1_ = _compiled_circuit_ref0 (_tmp0_);
	_compiled_circuit_unref0 (self->priv->compiledCircuit);
	self->priv->compiledCircuit = _tmp1_;
	self->priv->runState = SIMULATOR_WINDOW_RUN_STATE_PAUSED;
	simulator_window_populate (self);
	return self;
}


SimulatorWindow* simulator_window_new (CompiledCircuit* compiledCircuit) {
	return simulator_window_construct (TYPE_SIMULATOR_WINDOW, compiledCircuit);
}


/**
 * Populate the window with widgets.
 */
static void _simulator_window_close_simulation_gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	simulator_window_close_simulation (self);
}


static void __lambda37_ (SimulatorWindow* self) {
	GtkCheckMenuItem* _tmp0_;
	_tmp0_ = self->priv->menuSimulationRun;
	simulator_window_run_toggle (self, (GtkWidget*) _tmp0_);
}


static void ___lambda37__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	__lambda37_ (self);
}


static void __lambda38_ (SimulatorWindow* self) {
	gtk_widget_destroy ((GtkWidget*) self);
}


static void ___lambda38__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda38_ (self);
}


static void __lambda39_ (SimulatorWindow* self) {
	simulator_window_fit_design (self);
}


static void ___lambda39__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda39_ (self);
}


static void __lambda40_ (SimulatorWindow* self, GtkCheckMenuItem* menuItem) {
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (menuItem != NULL);
	_tmp0_ = menuItem;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	self->priv->autoFitDesign = _tmp2_;
}


static void ___lambda40__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	__lambda40_ (self, _sender);
}


static void __lambda41_ (SimulatorWindow* self) {
	simulator_window_show_timing_diagram (self);
}


static void ___lambda41__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda41_ (self);
}


static void __lambda42_ (SimulatorWindow* self) {
	self->priv->mouseMode = SIMULATOR_WINDOW_MOUSE_MODE_SCROLL;
}


static void ___lambda42__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda42_ (self);
}


static void __lambda43_ (SimulatorWindow* self) {
	self->priv->mouseMode = SIMULATOR_WINDOW_MOUSE_MODE_ZOOM;
}


static void ___lambda43__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda43_ (self);
}


static void __lambda44_ (SimulatorWindow* self) {
	self->priv->mouseMode = SIMULATOR_WINDOW_MOUSE_MODE_CONTEXT;
}


static void ___lambda44__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda44_ (self);
}


static void __lambda45_ (SimulatorWindow* self) {
	self->priv->mouseMode = SIMULATOR_WINDOW_MOUSE_MODE_INTERACT;
}


static void ___lambda45__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda45_ (self);
}


static void __lambda46_ (SimulatorWindow* self) {
	self->priv->mouseMode = SIMULATOR_WINDOW_MOUSE_MODE_EXPLORE;
}


static void ___lambda46__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda46_ (self);
}


static void __lambda47_ (SimulatorWindow* self) {
	self->priv->mouseMode = SIMULATOR_WINDOW_MOUSE_MODE_WATCH;
}


static void ___lambda47__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda47_ (self);
}


static void __lambda48_ (SimulatorWindow* self) {
	CompiledCircuit* _tmp0_;
	gboolean _tmp1_;
	_tmp0_ = self->priv->compiledCircuit;
	compiled_circuit_shrink_component (_tmp0_);
	_tmp1_ = self->priv->autoFitDesign;
	if (_tmp1_) {
		simulator_window_fit_design (self);
	}
	simulator_window_render (self, TRUE, FALSE, NULL);
}


static void ___lambda48__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda48_ (self);
}


static void __lambda49_ (SimulatorWindow* self) {
	GtkToggleToolButton* _tmp0_;
	_tmp0_ = self->priv->toolRun;
	simulator_window_run_toggle (self, (GtkWidget*) _tmp0_);
}


static void ___lambda49__gtk_toggle_tool_button_toggled (GtkToggleToolButton* _sender, gpointer self) {
	__lambda49_ (self);
}


static void __lambda50_ (SimulatorWindow* self) {
	simulator_window_step (self, FALSE);
}


static void ___lambda50__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda50_ (self);
}


static void __lambda51_ (SimulatorWindow* self) {
	simulator_window_step (self, TRUE);
}


static void ___lambda51__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda51_ (self);
}


static void __lambda52_ (SimulatorWindow* self) {
	GtkToggleToolButton* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	_tmp0_ = self->priv->toolMaxspeed;
	_tmp1_ = gtk_toggle_tool_button_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	if (!_tmp2_) {
		GtkSpinButton* _tmp3_;
		gdouble _tmp4_ = 0.0;
		_tmp3_ = self->priv->toolSpeedSpin;
		_tmp4_ = gtk_spin_button_get_value (_tmp3_);
		simulator_window_change_speed (self, (gint) (1000.0 / _tmp4_));
	}
}


static void ___lambda52__gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self) {
	__lambda52_ (self);
}


static void __lambda53_ (SimulatorWindow* self) {
	GtkToggleToolButton* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	_tmp0_ = self->priv->toolMaxspeed;
	_tmp1_ = gtk_toggle_tool_button_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		GtkSpinButton* _tmp3_;
		_tmp3_ = self->priv->toolSpeedSpin;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp3_, FALSE);
		simulator_window_change_speed (self, 0);
	} else {
		GtkSpinButton* _tmp4_;
		GtkSpinButton* _tmp5_;
		gdouble _tmp6_ = 0.0;
		_tmp4_ = self->priv->toolSpeedSpin;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp4_, TRUE);
		_tmp5_ = self->priv->toolSpeedSpin;
		_tmp6_ = gtk_spin_button_get_value (_tmp5_);
		simulator_window_change_speed (self, (gint) (1000.0 / _tmp6_));
	}
}


static void ___lambda53__gtk_toggle_tool_button_toggled (GtkToggleToolButton* _sender, gpointer self) {
	__lambda53_ (self);
}


static void __lambda54_ (SimulatorWindow* self) {
	GtkSpinButton* _tmp0_;
	gint _tmp1_ = 0;
	_tmp0_ = self->priv->toolStepsizeSpin;
	_tmp1_ = gtk_spin_button_get_value_as_int (_tmp0_);
	self->priv->multistepSize = _tmp1_;
}


static void ___lambda54__gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self) {
	__lambda54_ (self);
}


static gboolean _simulator_window_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = simulator_window_mouse_down (self, event);
	return result;
}


static gboolean _simulator_window_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = simulator_window_mouse_up (self, event);
	return result;
}


static gboolean __lambda55_ (SimulatorWindow* self, cairo_t* context) {
	gboolean result = FALSE;
	cairo_t* _tmp0_;
	g_return_val_if_fail (context != NULL, FALSE);
	_tmp0_ = context;
	simulator_window_render (self, TRUE, FALSE, _tmp0_);
	result = FALSE;
	return result;
}


static gboolean ___lambda55__gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self) {
	gboolean result;
	result = __lambda55_ (self, cr);
	return result;
}


void simulator_window_populate (SimulatorWindow* self) {
	FILE* _tmp0_;
	GtkBox* _tmp5_;
	GtkBox* _tmp6_;
	GtkMenuBar* _tmp7_;
	GtkBox* _tmp8_;
	GtkMenuBar* _tmp9_;
	GtkMenuItem* _tmp10_;
	GtkMenuBar* _tmp11_;
	GtkMenuItem* _tmp12_;
	GtkMenu* _tmp13_;
	GtkMenuItem* _tmp14_;
	GtkMenu* _tmp15_;
	GtkCheckMenuItem* _tmp16_;
	GtkMenu* _tmp17_;
	GtkCheckMenuItem* _tmp18_;
	GtkCheckMenuItem* _tmp19_;
	GtkSeparatorMenuItem* _tmp20_;
	GtkMenu* _tmp21_;
	GtkMenuItem* _tmp22_;
	GtkMenuItem* _tmp23_;
	GtkMenu* _tmp24_;
	GtkMenuItem* _tmp25_;
	GtkMenuItem* _tmp26_;
	GtkMenuItem* _tmp27_;
	GtkMenuBar* _tmp28_;
	GtkMenuItem* _tmp29_;
	GtkMenu* _tmp30_;
	GtkMenuItem* _tmp31_;
	GtkMenu* _tmp32_;
	GtkMenuItem* _tmp33_;
	GtkMenu* _tmp34_;
	GtkMenuItem* _tmp35_;
	GtkMenuItem* _tmp36_;
	GtkCheckMenuItem* _tmp37_;
	GtkMenu* _tmp38_;
	GtkCheckMenuItem* _tmp39_;
	GtkCheckMenuItem* _tmp40_;
	GtkCheckMenuItem* _tmp41_;
	GtkSeparatorMenuItem* _tmp42_;
	GtkMenu* _tmp43_;
	GtkMenuItem* _tmp44_;
	GtkMenuItem* _tmp45_;
	GtkMenu* _tmp46_;
	GtkMenuItem* _tmp47_;
	GtkMenuItem* _tmp48_;
	GtkToolbar* _tmp49_;
	GtkToolbar* _tmp50_;
	GtkBox* _tmp51_;
	GtkToolbar* _tmp52_;
	GtkImage* _tmp53_;
	GtkRadioToolButton* _tmp54_;
	GtkRadioToolButton* _tmp55_;
	GtkRadioToolButton* _tmp56_;
	GtkImage* _tmp57_;
	GtkToolbar* _tmp58_;
	GtkRadioToolButton* _tmp59_;
	GtkRadioToolButton* _tmp60_;
	GtkRadioToolButton* _tmp61_;
	GtkImage* _tmp62_;
	GtkRadioToolButton* _tmp63_;
	GtkRadioToolButton* _tmp64_;
	GtkRadioToolButton* _tmp65_;
	GtkRadioToolButton* _tmp66_;
	GtkImage* _tmp67_;
	GtkToolbar* _tmp68_;
	GtkRadioToolButton* _tmp69_;
	GtkRadioToolButton* _tmp70_;
	GtkRadioToolButton* _tmp71_;
	GtkSeparatorToolItem* _tmp72_;
	GtkToolbar* _tmp73_;
	GtkSeparatorToolItem* _tmp74_;
	GtkImage* _tmp75_;
	GtkRadioToolButton* _tmp76_;
	GtkRadioToolButton* _tmp77_;
	GtkRadioToolButton* _tmp78_;
	GtkRadioToolButton* _tmp79_;
	GtkImage* _tmp80_;
	GtkToolbar* _tmp81_;
	GtkRadioToolButton* _tmp82_;
	GtkRadioToolButton* _tmp83_;
	GtkRadioToolButton* _tmp84_;
	GtkRadioToolButton* _tmp85_;
	GtkImage* _tmp86_;
	GtkRadioToolButton* _tmp87_;
	GtkRadioToolButton* _tmp88_;
	GtkRadioToolButton* _tmp89_;
	GtkRadioToolButton* _tmp90_;
	GtkImage* _tmp91_;
	GtkToolbar* _tmp92_;
	GtkRadioToolButton* _tmp93_;
	GtkRadioToolButton* _tmp94_;
	GtkRadioToolButton* _tmp95_;
	GtkImage* _tmp96_;
	GtkRadioToolButton* _tmp97_;
	GtkRadioToolButton* _tmp98_;
	GtkRadioToolButton* _tmp99_;
	GtkRadioToolButton* _tmp100_;
	GtkImage* _tmp101_;
	GtkToolbar* _tmp102_;
	GtkRadioToolButton* _tmp103_;
	GtkRadioToolButton* _tmp104_;
	GtkRadioToolButton* _tmp105_;
	GtkImage* _tmp106_;
	GtkRadioToolButton* _tmp107_;
	GtkRadioToolButton* _tmp108_;
	GtkRadioToolButton* _tmp109_;
	GtkRadioToolButton* _tmp110_;
	GtkImage* _tmp111_;
	GtkToolbar* _tmp112_;
	GtkRadioToolButton* _tmp113_;
	GtkRadioToolButton* _tmp114_;
	GtkRadioToolButton* _tmp115_;
	GtkSeparatorToolItem* _tmp116_;
	GtkToolbar* _tmp117_;
	GtkSeparatorToolItem* _tmp118_;
	GtkImage* _tmp119_;
	GtkImage* _tmp120_;
	GtkToolButton* _tmp121_;
	GtkToolbar* _tmp122_;
	GtkToolButton* _tmp123_;
	GtkToolButton* _tmp124_;
	GtkToolButton* _tmp125_;
	GtkSeparatorToolItem* _tmp126_;
	GtkToolbar* _tmp127_;
	GtkSeparatorToolItem* _tmp128_;
	GtkImage* _tmp129_;
	GtkToggleToolButton* _tmp130_;
	GtkToggleToolButton* _tmp131_;
	GtkToggleToolButton* _tmp132_;
	GtkImage* _tmp133_;
	GtkToolbar* _tmp134_;
	GtkToggleToolButton* _tmp135_;
	GtkToggleToolButton* _tmp136_;
	GtkToggleToolButton* _tmp137_;
	GtkImage* _tmp138_;
	GtkImage* _tmp139_;
	GtkToolButton* _tmp140_;
	GtkToolbar* _tmp141_;
	GtkToolButton* _tmp142_;
	GtkToolButton* _tmp143_;
	GtkToolButton* _tmp144_;
	GtkImage* _tmp145_;
	GtkImage* _tmp146_;
	GtkToolButton* _tmp147_;
	GtkToolbar* _tmp148_;
	GtkToolButton* _tmp149_;
	GtkToolButton* _tmp150_;
	GtkToolButton* _tmp151_;
	GtkSeparatorToolItem* _tmp152_;
	GtkToolbar* _tmp153_;
	GtkSeparatorToolItem* _tmp154_;
	GtkToolItem* _tmp155_;
	GtkToolbar* _tmp156_;
	GtkToolItem* _tmp157_;
	GtkBox* _tmp158_;
	GtkToolItem* _tmp159_;
	GtkBox* _tmp160_;
	GtkLabel* _tmp161_;
	GtkBox* _tmp162_;
	GtkLabel* _tmp163_;
	GtkSpinButton* _tmp164_;
	GtkBox* _tmp165_;
	GtkSpinButton* _tmp166_;
	GtkSpinButton* _tmp167_;
	GtkSpinButton* _tmp168_;
	GtkSpinButton* _tmp169_;
	GtkSpinButton* _tmp170_;
	GtkSpinButton* _tmp171_;
	GtkImage* _tmp172_;
	GtkToggleToolButton* _tmp173_;
	GtkToggleToolButton* _tmp174_;
	GtkToggleToolButton* _tmp175_;
	GtkImage* _tmp176_;
	GtkToolbar* _tmp177_;
	GtkToggleToolButton* _tmp178_;
	GtkToggleToolButton* _tmp179_;
	GtkToggleToolButton* _tmp180_;
	GtkToggleToolButton* _tmp181_;
	GtkSeparatorToolItem* _tmp182_;
	GtkToolbar* _tmp183_;
	GtkSeparatorToolItem* _tmp184_;
	GtkToolItem* _tmp185_;
	GtkToolbar* _tmp186_;
	GtkToolItem* _tmp187_;
	GtkBox* _tmp188_;
	GtkToolItem* _tmp189_;
	GtkBox* _tmp190_;
	GtkLabel* _tmp191_;
	GtkBox* _tmp192_;
	GtkLabel* _tmp193_;
	GtkSpinButton* _tmp194_;
	GtkBox* _tmp195_;
	GtkSpinButton* _tmp196_;
	GtkSpinButton* _tmp197_;
	GtkSpinButton* _tmp198_;
	GtkEventBox* _tmp199_;
	GtkBox* _tmp200_;
	GtkEventBox* _tmp201_;
	GtkEventBox* _tmp202_;
	GtkEventBox* _tmp203_;
	GtkDrawingArea* _tmp204_;
	GtkEventBox* _tmp205_;
	GtkDrawingArea* _tmp206_;
	GtkDrawingArea* _tmp207_;
	CompiledCircuit* _tmp208_;
	TimingDiagram* _tmp209_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "Simulation Window Created\n");
	gtk_window_set_default_size ((GtkWindow*) self, 800, 600);
	gtk_container_set_border_width ((GtkContainer*) self, (guint) 0);
	g_signal_connect_object ((GtkWidget*) self, "destroy", (GCallback) _simulator_window_close_simulation_gtk_widget_destroy, self, 0);
	gtk_window_set_title ((GtkWindow*) self, CORE_programName " - Simulation");
	{
		GdkPixbuf* _tmp1_;
		GdkPixbuf* _tmp2_;
		GdkPixbuf* _tmp3_;
		_tmp1_ = gdk_pixbuf_new_from_file (PACKAGE_DATADIR "images/icons/smartsim64.png", &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			goto __catch67_g_error;
		}
		_tmp3_ = _tmp2_;
		gtk_window_set_icon ((GtkWindow*) self, _tmp3_);
		_g_object_unref0 (_tmp3_);
	}
	goto __finally67;
	__catch67_g_error:
	{
		FILE* _tmp4_;
		g_clear_error (&_inner_error_);
		_inner_error_ = NULL;
		_tmp4_ = stderr;
		fprintf (_tmp4_, "Could not load window image.\n");
	}
	__finally67:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp5_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
	g_object_ref_sink (_tmp5_);
	_g_object_unref0 (self->priv->vBox);
	self->priv->vBox = _tmp5_;
	_tmp6_ = self->priv->vBox;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp6_);
	_tmp7_ = (GtkMenuBar*) gtk_menu_bar_new ();
	g_object_ref_sink (_tmp7_);
	_g_object_unref0 (self->priv->menubar);
	self->priv->menubar = _tmp7_;
	_tmp8_ = self->priv->vBox;
	_tmp9_ = self->priv->menubar;
	gtk_box_pack_start (_tmp8_, (GtkWidget*) _tmp9_, FALSE, TRUE, (guint) 0);
	_tmp10_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Simulation");
	g_object_ref_sink (_tmp10_);
	_g_object_unref0 (self->priv->menuSimulation);
	self->priv->menuSimulation = _tmp10_;
	_tmp11_ = self->priv->menubar;
	_tmp12_ = self->priv->menuSimulation;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp11_, (GtkWidget*) _tmp12_);
	_tmp13_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp13_);
	_g_object_unref0 (self->priv->menuSimulationMenu);
	self->priv->menuSimulationMenu = _tmp13_;
	_tmp14_ = self->priv->menuSimulation;
	_tmp15_ = self->priv->menuSimulationMenu;
	gtk_menu_item_set_submenu (_tmp14_, (GtkWidget*) _tmp15_);
	_tmp16_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label ("Run");
	g_object_ref_sink (_tmp16_);
	_g_object_unref0 (self->priv->menuSimulationRun);
	self->priv->menuSimulationRun = _tmp16_;
	_tmp17_ = self->priv->menuSimulationMenu;
	_tmp18_ = self->priv->menuSimulationRun;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp17_, (GtkWidget*) ((GtkMenuItem*) _tmp18_));
	_tmp19_ = self->priv->menuSimulationRun;
	g_signal_connect_object (_tmp19_, "toggled", (GCallback) ___lambda37__gtk_check_menu_item_toggled, self, 0);
	_tmp20_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp20_);
	_g_object_unref0 (self->priv->menuSimulationSeparator1);
	self->priv->menuSimulationSeparator1 = (GtkMenuItem*) _tmp20_;
	_tmp21_ = self->priv->menuSimulationMenu;
	_tmp22_ = self->priv->menuSimulationSeparator1;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp21_, (GtkWidget*) _tmp22_);
	_tmp23_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Close Simulation");
	g_object_ref_sink (_tmp23_);
	_g_object_unref0 (self->priv->menuSimulationExit);
	self->priv->menuSimulationExit = _tmp23_;
	_tmp24_ = self->priv->menuSimulationMenu;
	_tmp25_ = self->priv->menuSimulationExit;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp24_, (GtkWidget*) _tmp25_);
	_tmp26_ = self->priv->menuSimulationExit;
	g_signal_connect_object (_tmp26_, "activate", (GCallback) ___lambda38__gtk_menu_item_activate, self, 0);
	_tmp27_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("View");
	g_object_ref_sink (_tmp27_);
	_g_object_unref0 (self->priv->menuView);
	self->priv->menuView = _tmp27_;
	_tmp28_ = self->priv->menubar;
	_tmp29_ = self->priv->menuView;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp28_, (GtkWidget*) _tmp29_);
	_tmp30_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp30_);
	_g_object_unref0 (self->priv->menuViewMenu);
	self->priv->menuViewMenu = _tmp30_;
	_tmp31_ = self->priv->menuView;
	_tmp32_ = self->priv->menuViewMenu;
	gtk_menu_item_set_submenu (_tmp31_, (GtkWidget*) _tmp32_);
	_tmp33_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Fit Design to Display");
	g_object_ref_sink (_tmp33_);
	_g_object_unref0 (self->priv->menuViewFitdesign);
	self->priv->menuViewFitdesign = _tmp33_;
	_tmp34_ = self->priv->menuViewMenu;
	_tmp35_ = self->priv->menuViewFitdesign;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp34_, (GtkWidget*) _tmp35_);
	_tmp36_ = self->priv->menuViewFitdesign;
	g_signal_connect_object (_tmp36_, "activate", (GCallback) ___lambda39__gtk_menu_item_activate, self, 0);
	_tmp37_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label ("Auto Fit When Exploring");
	g_object_ref_sink (_tmp37_);
	_g_object_unref0 (self->priv->menuViewAutofitdesign);
	self->priv->menuViewAutofitdesign = _tmp37_;
	_tmp38_ = self->priv->menuViewMenu;
	_tmp39_ = self->priv->menuViewAutofitdesign;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp38_, (GtkWidget*) ((GtkMenuItem*) _tmp39_));
	_tmp40_ = self->priv->menuViewAutofitdesign;
	gtk_check_menu_item_set_active (_tmp40_, TRUE);
	_tmp41_ = self->priv->menuViewAutofitdesign;
	g_signal_connect_object (_tmp41_, "toggled", (GCallback) ___lambda40__gtk_check_menu_item_toggled, self, 0);
	_tmp42_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp42_);
	_g_object_unref0 (self->priv->menuViewSeparator1);
	self->priv->menuViewSeparator1 = (GtkMenuItem*) _tmp42_;
	_tmp43_ = self->priv->menuViewMenu;
	_tmp44_ = self->priv->menuViewSeparator1;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp43_, (GtkWidget*) _tmp44_);
	_tmp45_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Show Timing Diagram");
	g_object_ref_sink (_tmp45_);
	_g_object_unref0 (self->priv->menuViewTimingdiagram);
	self->priv->menuViewTimingdiagram = _tmp45_;
	_tmp46_ = self->priv->menuViewMenu;
	_tmp47_ = self->priv->menuViewTimingdiagram;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp46_, (GtkWidget*) _tmp47_);
	_tmp48_ = self->priv->menuViewTimingdiagram;
	g_signal_connect_object (_tmp48_, "activate", (GCallback) ___lambda41__gtk_menu_item_activate, self, 0);
	_tmp49_ = (GtkToolbar*) gtk_toolbar_new ();
	g_object_ref_sink (_tmp49_);
	_g_object_unref0 (self->priv->toolbar);
	self->priv->toolbar = _tmp49_;
	_tmp50_ = self->priv->toolbar;
	g_object_set (_tmp50_, "toolbar-style", GTK_TOOLBAR_ICONS, NULL);
	_tmp51_ = self->priv->vBox;
	_tmp52_ = self->priv->toolbar;
	gtk_box_pack_start (_tmp51_, (GtkWidget*) _tmp52_, FALSE, TRUE, (guint) 0);
	_tmp53_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/scroll.png");
	g_object_ref_sink (_tmp53_);
	_g_object_unref0 (self->priv->toolScrollImage);
	self->priv->toolScrollImage = _tmp53_;
	_tmp54_ = (GtkRadioToolButton*) gtk_radio_tool_button_new (NULL);
	g_object_ref_sink (_tmp54_);
	_g_object_unref0 (self->priv->toolScroll);
	self->priv->toolScroll = _tmp54_;
	_tmp55_ = self->priv->toolScroll;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp55_, "Scroll");
	_tmp56_ = self->priv->toolScroll;
	_tmp57_ = self->priv->toolScrollImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp56_, (GtkWidget*) _tmp57_);
	_tmp58_ = self->priv->toolbar;
	_tmp59_ = self->priv->toolScroll;
	gtk_toolbar_insert (_tmp58_, (GtkToolItem*) _tmp59_, -1);
	_tmp60_ = self->priv->toolScroll;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp60_, "Scroll: Move your view of the circuit with click and drag.");
	_tmp61_ = self->priv->toolScroll;
	g_signal_connect_object ((GtkToolButton*) _tmp61_, "clicked", (GCallback) ___lambda42__gtk_tool_button_clicked, self, 0);
	_tmp62_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/zoom.png");
	g_object_ref_sink (_tmp62_);
	_g_object_unref0 (self->priv->toolZoomImage);
	self->priv->toolZoomImage = _tmp62_;
	_tmp63_ = self->priv->toolScroll;
	_tmp64_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp63_);
	g_object_ref_sink (_tmp64_);
	_g_object_unref0 (self->priv->toolZoom);
	self->priv->toolZoom = _tmp64_;
	_tmp65_ = self->priv->toolZoom;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp65_, "Zoom");
	_tmp66_ = self->priv->toolZoom;
	_tmp67_ = self->priv->toolZoomImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp66_, (GtkWidget*) _tmp67_);
	_tmp68_ = self->priv->toolbar;
	_tmp69_ = self->priv->toolZoom;
	gtk_toolbar_insert (_tmp68_, (GtkToolItem*) _tmp69_, -1);
	_tmp70_ = self->priv->toolZoom;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp70_, "Zoom: Drag downward to zoom in or upward to zoom out.");
	_tmp71_ = self->priv->toolZoom;
	g_signal_connect_object ((GtkToolButton*) _tmp71_, "clicked", (GCallback) ___lambda43__gtk_tool_button_clicked, self, 0);
	_tmp72_ = (GtkSeparatorToolItem*) gtk_separator_tool_item_new ();
	g_object_ref_sink (_tmp72_);
	_g_object_unref0 (self->priv->toolSeparator1);
	self->priv->toolSeparator1 = _tmp72_;
	_tmp73_ = self->priv->toolbar;
	_tmp74_ = self->priv->toolSeparator1;
	gtk_toolbar_insert (_tmp73_, (GtkToolItem*) _tmp74_, -1);
	_tmp75_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/context.png");
	g_object_ref_sink (_tmp75_);
	_g_object_unref0 (self->priv->toolContextImage);
	self->priv->toolContextImage = _tmp75_;
	_tmp76_ = self->priv->toolScroll;
	_tmp77_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp76_);
	g_object_ref_sink (_tmp77_);
	_g_object_unref0 (self->priv->toolContext);
	self->priv->toolContext = _tmp77_;
	_tmp78_ = self->priv->toolContext;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp78_, "Context");
	_tmp79_ = self->priv->toolContext;
	_tmp80_ = self->priv->toolContextImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp79_, (GtkWidget*) _tmp80_);
	_tmp81_ = self->priv->toolbar;
	_tmp82_ = self->priv->toolContext;
	gtk_toolbar_insert (_tmp81_, (GtkToolItem*) _tmp82_, -1);
	_tmp83_ = self->priv->toolContext;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp83_, "Context: Interact or explore depending on what you click on. See Inter" \
"act and Explore tools.");
	_tmp84_ = self->priv->toolContext;
	g_signal_connect_object ((GtkToolButton*) _tmp84_, "clicked", (GCallback) ___lambda44__gtk_tool_button_clicked, self, 0);
	_tmp85_ = self->priv->toolContext;
	gtk_toggle_tool_button_set_active ((GtkToggleToolButton*) _tmp85_, TRUE);
	_tmp86_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/interact.png");
	g_object_ref_sink (_tmp86_);
	_g_object_unref0 (self->priv->toolInteractImage);
	self->priv->toolInteractImage = _tmp86_;
	_tmp87_ = self->priv->toolScroll;
	_tmp88_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp87_);
	g_object_ref_sink (_tmp88_);
	_g_object_unref0 (self->priv->toolInteract);
	self->priv->toolInteract = _tmp88_;
	_tmp89_ = self->priv->toolInteract;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp89_, "Interact");
	_tmp90_ = self->priv->toolInteract;
	_tmp91_ = self->priv->toolInteractImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp90_, (GtkWidget*) _tmp91_);
	_tmp92_ = self->priv->toolbar;
	_tmp93_ = self->priv->toolInteract;
	gtk_toolbar_insert (_tmp92_, (GtkToolItem*) _tmp93_, -1);
	_tmp94_ = self->priv->toolInteract;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp94_, "Interact: Click on an interactive component to interact with it.");
	_tmp95_ = self->priv->toolInteract;
	g_signal_connect_object ((GtkToolButton*) _tmp95_, "clicked", (GCallback) ___lambda45__gtk_tool_button_clicked, self, 0);
	_tmp96_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/explore.png");
	g_object_ref_sink (_tmp96_);
	_g_object_unref0 (self->priv->toolExploreImage);
	self->priv->toolExploreImage = _tmp96_;
	_tmp97_ = self->priv->toolScroll;
	_tmp98_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp97_);
	g_object_ref_sink (_tmp98_);
	_g_object_unref0 (self->priv->toolExplore);
	self->priv->toolExplore = _tmp98_;
	_tmp99_ = self->priv->toolExplore;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp99_, "Explore");
	_tmp100_ = self->priv->toolExplore;
	_tmp101_ = self->priv->toolExploreImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp100_, (GtkWidget*) _tmp101_);
	_tmp102_ = self->priv->toolbar;
	_tmp103_ = self->priv->toolExplore;
	gtk_toolbar_insert (_tmp102_, (GtkToolItem*) _tmp103_, -1);
	_tmp104_ = self->priv->toolExplore;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp104_, "Explore: Click on sub components to expand them and look at the activi" \
"ty inside them. Click on the background (or use the shrink tool) to go" \
" back to the higher level.");
	_tmp105_ = self->priv->toolExplore;
	g_signal_connect_object ((GtkToolButton*) _tmp105_, "clicked", (GCallback) ___lambda46__gtk_tool_button_clicked, self, 0);
	_tmp106_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/watch.png");
	g_object_ref_sink (_tmp106_);
	_g_object_unref0 (self->priv->toolWatchImage);
	self->priv->toolWatchImage = _tmp106_;
	_tmp107_ = self->priv->toolScroll;
	_tmp108_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp107_);
	g_object_ref_sink (_tmp108_);
	_g_object_unref0 (self->priv->toolWatch);
	self->priv->toolWatch = _tmp108_;
	_tmp109_ = self->priv->toolWatch;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp109_, "Watch");
	_tmp110_ = self->priv->toolWatch;
	_tmp111_ = self->priv->toolWatchImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp110_, (GtkWidget*) _tmp111_);
	_tmp112_ = self->priv->toolbar;
	_tmp113_ = self->priv->toolWatch;
	gtk_toolbar_insert (_tmp112_, (GtkToolItem*) _tmp113_, -1);
	_tmp114_ = self->priv->toolWatch;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp114_, "Watch: Click on a wire to add it to the logic timing diagram.");
	_tmp115_ = self->priv->toolWatch;
	g_signal_connect_object ((GtkToolButton*) _tmp115_, "clicked", (GCallback) ___lambda47__gtk_tool_button_clicked, self, 0);
	_tmp116_ = (GtkSeparatorToolItem*) gtk_separator_tool_item_new ();
	g_object_ref_sink (_tmp116_);
	_g_object_unref0 (self->priv->toolSeparator2);
	self->priv->toolSeparator2 = _tmp116_;
	_tmp117_ = self->priv->toolbar;
	_tmp118_ = self->priv->toolSeparator2;
	gtk_toolbar_insert (_tmp117_, (GtkToolItem*) _tmp118_, -1);
	_tmp119_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/shrink.png");
	g_object_ref_sink (_tmp119_);
	_g_object_unref0 (self->priv->toolShrinkImage);
	self->priv->toolShrinkImage = _tmp119_;
	_tmp120_ = self->priv->toolShrinkImage;
	_tmp121_ = (GtkToolButton*) gtk_tool_button_new ((GtkWidget*) _tmp120_, "Shrink");
	g_object_ref_sink (_tmp121_);
	_g_object_unref0 (self->priv->toolShrink);
	self->priv->toolShrink = _tmp121_;
	_tmp122_ = self->priv->toolbar;
	_tmp123_ = self->priv->toolShrink;
	gtk_toolbar_insert (_tmp122_, (GtkToolItem*) _tmp123_, -1);
	_tmp124_ = self->priv->toolShrink;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp124_, "Shrink: Explore the immediately higher level component (the component " \
"containing the currently viewed one).");
	_tmp125_ = self->priv->toolShrink;
	g_signal_connect_object (_tmp125_, "clicked", (GCallback) ___lambda48__gtk_tool_button_clicked, self, 0);
	_tmp126_ = (GtkSeparatorToolItem*) gtk_separator_tool_item_new ();
	g_object_ref_sink (_tmp126_);
	_g_object_unref0 (self->priv->toolSeparator3);
	self->priv->toolSeparator3 = _tmp126_;
	_tmp127_ = self->priv->toolbar;
	_tmp128_ = self->priv->toolSeparator3;
	gtk_toolbar_insert (_tmp127_, (GtkToolItem*) _tmp128_, -1);
	_tmp129_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/run.png");
	g_object_ref_sink (_tmp129_);
	_g_object_unref0 (self->priv->toolRunImage);
	self->priv->toolRunImage = _tmp129_;
	_tmp130_ = (GtkToggleToolButton*) gtk_toggle_tool_button_new ();
	g_object_ref_sink (_tmp130_);
	_g_object_unref0 (self->priv->toolRun);
	self->priv->toolRun = _tmp130_;
	_tmp131_ = self->priv->toolRun;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp131_, "Run");
	_tmp132_ = self->priv->toolRun;
	_tmp133_ = self->priv->toolRunImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp132_, (GtkWidget*) _tmp133_);
	_tmp134_ = self->priv->toolbar;
	_tmp135_ = self->priv->toolRun;
	gtk_toolbar_insert (_tmp134_, (GtkToolItem*) _tmp135_, -1);
	_tmp136_ = self->priv->toolRun;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp136_, "Run: Toggle between a running and paused simulation.");
	_tmp137_ = self->priv->toolRun;
	g_signal_connect_object (_tmp137_, "toggled", (GCallback) ___lambda49__gtk_toggle_tool_button_toggled, self, 0);
	_tmp138_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/singlestep.png");
	g_object_ref_sink (_tmp138_);
	_g_object_unref0 (self->priv->toolSinglestepImage);
	self->priv->toolSinglestepImage = _tmp138_;
	_tmp139_ = self->priv->toolSinglestepImage;
	_tmp140_ = (GtkToolButton*) gtk_tool_button_new ((GtkWidget*) _tmp139_, "Single Step");
	g_object_ref_sink (_tmp140_);
	_g_object_unref0 (self->priv->toolSinglestep);
	self->priv->toolSinglestep = _tmp140_;
	_tmp141_ = self->priv->toolbar;
	_tmp142_ = self->priv->toolSinglestep;
	gtk_toolbar_insert (_tmp141_, (GtkToolItem*) _tmp142_, -1);
	_tmp143_ = self->priv->toolSinglestep;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp143_, "Single Step: Step through the simulation a single iteration at a time.");
	_tmp144_ = self->priv->toolSinglestep;
	g_signal_connect_object (_tmp144_, "clicked", (GCallback) ___lambda50__gtk_tool_button_clicked, self, 0);
	_tmp145_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/multistep.png");
	g_object_ref_sink (_tmp145_);
	_g_object_unref0 (self->priv->toolMultistepImage);
	self->priv->toolMultistepImage = _tmp145_;
	_tmp146_ = self->priv->toolMultistepImage;
	_tmp147_ = (GtkToolButton*) gtk_tool_button_new ((GtkWidget*) _tmp146_, "Multi Step");
	g_object_ref_sink (_tmp147_);
	_g_object_unref0 (self->priv->toolMultistep);
	self->priv->toolMultistep = _tmp147_;
	_tmp148_ = self->priv->toolbar;
	_tmp149_ = self->priv->toolMultistep;
	gtk_toolbar_insert (_tmp148_, (GtkToolItem*) _tmp149_, -1);
	_tmp150_ = self->priv->toolMultistep;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp150_, "Multi Step: Step through the simulation by a specified number of itera" \
"tions.");
	_tmp151_ = self->priv->toolMultistep;
	g_signal_connect_object (_tmp151_, "clicked", (GCallback) ___lambda51__gtk_tool_button_clicked, self, 0);
	_tmp152_ = (GtkSeparatorToolItem*) gtk_separator_tool_item_new ();
	g_object_ref_sink (_tmp152_);
	_g_object_unref0 (self->priv->toolSeparator4);
	self->priv->toolSeparator4 = _tmp152_;
	_tmp153_ = self->priv->toolbar;
	_tmp154_ = self->priv->toolSeparator4;
	gtk_toolbar_insert (_tmp153_, (GtkToolItem*) _tmp154_, -1);
	_tmp155_ = gtk_tool_item_new ();
	g_object_ref_sink (_tmp155_);
	_g_object_unref0 (self->priv->toolSpeed);
	self->priv->toolSpeed = _tmp155_;
	_tmp156_ = self->priv->toolbar;
	_tmp157_ = self->priv->toolSpeed;
	gtk_toolbar_insert (_tmp156_, _tmp157_, -1);
	_tmp158_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp158_);
	_g_object_unref0 (self->priv->toolSpeedBox);
	self->priv->toolSpeedBox = _tmp158_;
	_tmp159_ = self->priv->toolSpeed;
	_tmp160_ = self->priv->toolSpeedBox;
	gtk_container_add ((GtkContainer*) _tmp159_, (GtkWidget*) _tmp160_);
	_tmp161_ = (GtkLabel*) gtk_label_new ("Speed (Hz):");
	g_object_ref_sink (_tmp161_);
	_g_object_unref0 (self->priv->toolSpeedLabel);
	self->priv->toolSpeedLabel = _tmp161_;
	_tmp162_ = self->priv->toolSpeedBox;
	_tmp163_ = self->priv->toolSpeedLabel;
	gtk_box_pack_start (_tmp162_, (GtkWidget*) _tmp163_, FALSE, TRUE, (guint) 0);
	_tmp164_ = (GtkSpinButton*) gtk_spin_button_new_with_range (0.1, 1000.0, 1.0);
	g_object_ref_sink (_tmp164_);
	_g_object_unref0 (self->priv->toolSpeedSpin);
	self->priv->toolSpeedSpin = _tmp164_;
	_tmp165_ = self->priv->toolSpeedBox;
	_tmp166_ = self->priv->toolSpeedSpin;
	gtk_box_pack_start (_tmp165_, (GtkWidget*) _tmp166_, FALSE, TRUE, (guint) 0);
	_tmp167_ = self->priv->toolSpeedSpin;
	gtk_spin_button_set_value (_tmp167_, 50.0);
	_tmp168_ = self->priv->toolSpeedSpin;
	gtk_spin_button_set_snap_to_ticks (_tmp168_, FALSE);
	_tmp169_ = self->priv->toolSpeedSpin;
	gtk_spin_button_set_digits (_tmp169_, (guint) 1);
	_tmp170_ = self->priv->toolSpeedSpin;
	g_signal_connect_object (_tmp170_, "value-changed", (GCallback) ___lambda52__gtk_spin_button_value_changed, self, 0);
	_tmp171_ = self->priv->toolSpeedSpin;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp171_, FALSE);
	_tmp172_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/fastest.png");
	g_object_ref_sink (_tmp172_);
	_g_object_unref0 (self->priv->toolMaxspeedImage);
	self->priv->toolMaxspeedImage = _tmp172_;
	_tmp173_ = (GtkToggleToolButton*) gtk_toggle_tool_button_new ();
	g_object_ref_sink (_tmp173_);
	_g_object_unref0 (self->priv->toolMaxspeed);
	self->priv->toolMaxspeed = _tmp173_;
	_tmp174_ = self->priv->toolMaxspeed;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp174_, "Maximum Speed");
	_tmp175_ = self->priv->toolMaxspeed;
	_tmp176_ = self->priv->toolMaxspeedImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp175_, (GtkWidget*) _tmp176_);
	_tmp177_ = self->priv->toolbar;
	_tmp178_ = self->priv->toolMaxspeed;
	gtk_toolbar_insert (_tmp177_, (GtkToolItem*) _tmp178_, -1);
	_tmp179_ = self->priv->toolMaxspeed;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp179_, "Maximum Speed: Toggle between running as fast as possible and running " \
"at a specified speed.");
	_tmp180_ = self->priv->toolMaxspeed;
	gtk_toggle_tool_button_set_active (_tmp180_, TRUE);
	_tmp181_ = self->priv->toolMaxspeed;
	g_signal_connect_object (_tmp181_, "toggled", (GCallback) ___lambda53__gtk_toggle_tool_button_toggled, self, 0);
	_tmp182_ = (GtkSeparatorToolItem*) gtk_separator_tool_item_new ();
	g_object_ref_sink (_tmp182_);
	_g_object_unref0 (self->priv->toolSeparator5);
	self->priv->toolSeparator5 = _tmp182_;
	_tmp183_ = self->priv->toolbar;
	_tmp184_ = self->priv->toolSeparator5;
	gtk_toolbar_insert (_tmp183_, (GtkToolItem*) _tmp184_, -1);
	_tmp185_ = gtk_tool_item_new ();
	g_object_ref_sink (_tmp185_);
	_g_object_unref0 (self->priv->toolStepsize);
	self->priv->toolStepsize = _tmp185_;
	_tmp186_ = self->priv->toolbar;
	_tmp187_ = self->priv->toolStepsize;
	gtk_toolbar_insert (_tmp186_, _tmp187_, -1);
	_tmp188_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp188_);
	_g_object_unref0 (self->priv->toolStepsizeBox);
	self->priv->toolStepsizeBox = _tmp188_;
	_tmp189_ = self->priv->toolStepsize;
	_tmp190_ = self->priv->toolStepsizeBox;
	gtk_container_add ((GtkContainer*) _tmp189_, (GtkWidget*) _tmp190_);
	_tmp191_ = (GtkLabel*) gtk_label_new ("Multi Step:");
	g_object_ref_sink (_tmp191_);
	_g_object_unref0 (self->priv->toolStepsizeLabel);
	self->priv->toolStepsizeLabel = _tmp191_;
	_tmp192_ = self->priv->toolStepsizeBox;
	_tmp193_ = self->priv->toolStepsizeLabel;
	gtk_box_pack_start (_tmp192_, (GtkWidget*) _tmp193_, FALSE, TRUE, (guint) 0);
	_tmp194_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 1, (gdouble) 1000000, 1.0);
	g_object_ref_sink (_tmp194_);
	_g_object_unref0 (self->priv->toolStepsizeSpin);
	self->priv->toolStepsizeSpin = _tmp194_;
	_tmp195_ = self->priv->toolStepsizeBox;
	_tmp196_ = self->priv->toolStepsizeSpin;
	gtk_box_pack_start (_tmp195_, (GtkWidget*) _tmp196_, FALSE, TRUE, (guint) 0);
	_tmp197_ = self->priv->toolStepsizeSpin;
	gtk_spin_button_set_value (_tmp197_, 50.0);
	_tmp198_ = self->priv->toolStepsizeSpin;
	g_signal_connect_object (_tmp198_, "value-changed", (GCallback) ___lambda54__gtk_spin_button_value_changed, self, 0);
	_tmp199_ = (GtkEventBox*) gtk_event_box_new ();
	g_object_ref_sink (_tmp199_);
	_g_object_unref0 (self->priv->controller);
	self->priv->controller = _tmp199_;
	_tmp200_ = self->priv->vBox;
	_tmp201_ = self->priv->controller;
	gtk_box_pack_start (_tmp200_, (GtkWidget*) _tmp201_, TRUE, TRUE, (guint) 0);
	_tmp202_ = self->priv->controller;
	g_signal_connect_object ((GtkWidget*) _tmp202_, "button-press-event", (GCallback) _simulator_window_mouse_down_gtk_widget_button_press_event, self, 0);
	_tmp203_ = self->priv->controller;
	g_signal_connect_object ((GtkWidget*) _tmp203_, "button-release-event", (GCallback) _simulator_window_mouse_up_gtk_widget_button_release_event, self, 0);
	_tmp204_ = (GtkDrawingArea*) gtk_drawing_area_new ();
	g_object_ref_sink (_tmp204_);
	_g_object_unref0 (self->priv->display);
	self->priv->display = _tmp204_;
	_tmp205_ = self->priv->controller;
	_tmp206_ = self->priv->display;
	gtk_container_add ((GtkContainer*) _tmp205_, (GtkWidget*) _tmp206_);
	_tmp207_ = self->priv->display;
	g_signal_connect_object ((GtkWidget*) _tmp207_, "draw", (GCallback) ___lambda55__gtk_widget_draw, self, 0);
	gtk_widget_show_all ((GtkWidget*) self);
	_tmp208_ = self->priv->compiledCircuit;
	_tmp209_ = timing_diagram_new (_tmp208_);
	g_object_ref_sink (_tmp209_);
	_g_object_unref0 (self->priv->timingDiagram);
	self->priv->timingDiagram = _tmp209_;
}


static void simulator_window_change_speed (SimulatorWindow* self, gint newCycleDelay) {
	SimulatorWindowRunState _tmp0_;
	gboolean running;
	gint _tmp1_;
	gboolean _tmp2_;
	gint _tmp3_;
	gint _tmp5_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->runState;
	running = _tmp0_ == SIMULATOR_WINDOW_RUN_STATE_RUNNING;
	simulator_window_pause (self);
	_tmp1_ = newCycleDelay;
	self->priv->cycleDelay = _tmp1_;
	_tmp2_ = running;
	if (_tmp2_) {
		simulator_window_run (self);
	}
	_tmp3_ = self->priv->cycleDelay;
	if (_tmp3_ < 0) {
		self->priv->cycleDelay = 0;
	} else {
		gint _tmp4_;
		_tmp4_ = self->priv->cycleDelay;
		if (_tmp4_ > 10000) {
			self->priv->cycleDelay = 10000;
		}
	}
	_tmp5_ = self->priv->cycleDelay;
	self->priv->microCycleDelay = _tmp5_ * 1000;
}


/**
 * Toggles whether the simulation is running or paused. Does nothing
 * if the circuit is in the ERROR state.
 */
static void simulator_window_run_toggle (SimulatorWindow* self, GtkWidget* widget) {
	gboolean doRun;
	GtkWidget* _tmp0_;
	GtkCheckMenuItem* _tmp1_;
	gboolean _tmp10_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	doRun = FALSE;
	_tmp0_ = widget;
	_tmp1_ = self->priv->menuSimulationRun;
	if (_tmp0_ == G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, GTK_TYPE_WIDGET, GtkWidget)) {
		GtkCheckMenuItem* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp2_ = self->priv->menuSimulationRun;
		_tmp3_ = gtk_check_menu_item_get_active (_tmp2_);
		_tmp4_ = _tmp3_;
		doRun = _tmp4_;
	} else {
		GtkWidget* _tmp5_;
		GtkToggleToolButton* _tmp6_;
		_tmp5_ = widget;
		_tmp6_ = self->priv->toolRun;
		if (_tmp5_ == G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, GTK_TYPE_WIDGET, GtkWidget)) {
			GtkToggleToolButton* _tmp7_;
			gboolean _tmp8_;
			gboolean _tmp9_;
			_tmp7_ = self->priv->toolRun;
			_tmp8_ = gtk_toggle_tool_button_get_active (_tmp7_);
			_tmp9_ = _tmp8_;
			doRun = _tmp9_;
		}
	}
	_tmp10_ = doRun;
	if (_tmp10_) {
		simulator_window_run (self);
	} else {
		simulator_window_pause (self);
	}
}


static void simulator_window_step (SimulatorWindow* self, gboolean multistep) {
	gint _tmp0_ = 0;
	gboolean _tmp1_;
	gint _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp1_ = multistep;
	if (_tmp1_) {
		gint _tmp2_;
		_tmp2_ = self->priv->multistepSize;
		_tmp0_ = _tmp2_;
	} else {
		_tmp0_ = 1;
	}
	_tmp3_ = _tmp0_;
	self->priv->stepsLeft = _tmp3_;
	simulator_window_run (self);
	self->priv->runState = SIMULATOR_WINDOW_RUN_STATE_STEPPING;
}


/**
 * Sets the simulation state to running. Does nothing if the circuit
 * is in the ERROR state.
 */
static gboolean _simulator_window_update_cycle_gsource_func (gpointer self) {
	gboolean result;
	result = simulator_window_update_cycle (self);
	return result;
}


static gboolean _simulator_window_refresh_cycle_gsource_func (gpointer self) {
	gboolean result;
	result = simulator_window_refresh_cycle (self);
	return result;
}


void simulator_window_run (SimulatorWindow* self) {
	SimulatorWindowRunState _tmp0_;
	SimulatorWindowRunState _tmp1_;
	GtkCheckMenuItem* _tmp12_;
	GtkToggleToolButton* _tmp13_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->runState;
	if (_tmp0_ == SIMULATOR_WINDOW_RUN_STATE_ERROR) {
		return;
	}
	_tmp1_ = self->priv->runState;
	if (_tmp1_ != SIMULATOR_WINDOW_RUN_STATE_RUNNING) {
		gint refreshDelay = 0;
		gint _tmp2_;
		guint _tmp4_;
		guint _tmp6_;
		gint _tmp8_;
		guint _tmp9_ = 0U;
		gint _tmp10_;
		guint _tmp11_ = 0U;
		_tmp2_ = self->priv->cycleDelay;
		if (_tmp2_ > 100) {
			gint _tmp3_;
			_tmp3_ = self->priv->cycleDelay;
			refreshDelay = _tmp3_;
		} else {
			refreshDelay = 100;
		}
		_tmp4_ = self->priv->cycleSourceID;
		if (_tmp4_ != ((guint) 0)) {
			guint _tmp5_;
			_tmp5_ = self->priv->cycleSourceID;
			g_source_remove (_tmp5_);
		}
		_tmp6_ = self->priv->refreshSourceID;
		if (_tmp6_ != ((guint) 0)) {
			guint _tmp7_;
			_tmp7_ = self->priv->refreshSourceID;
			g_source_remove (_tmp7_);
		}
		_tmp8_ = self->priv->cycleDelay;
		_tmp9_ = g_timeout_add_full (G_PRIORITY_DEFAULT_IDLE, (guint) _tmp8_, _simulator_window_update_cycle_gsource_func, g_object_ref (self), g_object_unref);
		self->priv->cycleSourceID = _tmp9_;
		_tmp10_ = refreshDelay;
		_tmp11_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) _tmp10_, _simulator_window_refresh_cycle_gsource_func, g_object_ref (self), g_object_unref);
		self->priv->refreshSourceID = _tmp11_;
	}
	self->priv->runState = SIMULATOR_WINDOW_RUN_STATE_RUNNING;
	_tmp12_ = self->priv->menuSimulationRun;
	gtk_check_menu_item_set_active (_tmp12_, TRUE);
	_tmp13_ = self->priv->toolRun;
	gtk_toggle_tool_button_set_active (_tmp13_, TRUE);
	self->priv->timeBeforeRender = (gdouble) 0;
}


/**
 * Sets the simulation state to paused. Does nothing if the circuit
 * is in the ERROR state.
 */
void simulator_window_pause (SimulatorWindow* self) {
	SimulatorWindowRunState _tmp0_;
	guint _tmp1_;
	guint _tmp3_;
	GtkCheckMenuItem* _tmp5_;
	GtkToggleToolButton* _tmp6_;
	TimingDiagram* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->runState;
	if (_tmp0_ == SIMULATOR_WINDOW_RUN_STATE_ERROR) {
		return;
	}
	_tmp1_ = self->priv->cycleSourceID;
	if (_tmp1_ != ((guint) 0)) {
		guint _tmp2_;
		_tmp2_ = self->priv->cycleSourceID;
		g_source_remove (_tmp2_);
		self->priv->cycleSourceID = (guint) 0;
	}
	_tmp3_ = self->priv->refreshSourceID;
	if (_tmp3_ != ((guint) 0)) {
		guint _tmp4_;
		_tmp4_ = self->priv->refreshSourceID;
		g_source_remove (_tmp4_);
		self->priv->refreshSourceID = (guint) 0;
	}
	self->priv->runState = SIMULATOR_WINDOW_RUN_STATE_PAUSED;
	_tmp5_ = self->priv->menuSimulationRun;
	gtk_check_menu_item_set_active (_tmp5_, FALSE);
	_tmp6_ = self->priv->toolRun;
	gtk_toggle_tool_button_set_active (_tmp6_, FALSE);
	simulator_window_render (self, TRUE, FALSE, NULL);
	_tmp7_ = self->priv->timingDiagram;
	timing_diagram_render (_tmp7_, TRUE, NULL);
}


static void simulator_window_show_timing_diagram (SimulatorWindow* self) {
	TimingDiagram* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->timingDiagram;
	timing_diagram_show_diagram (_tmp0_);
}


static void simulator_window_fit_design (SimulatorWindow* self) {
	GtkAllocation areaAllocation = {0};
	GtkEventBox* _tmp0_;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_;
	gint _tmp3_;
	gint width;
	GtkAllocation _tmp4_;
	gint _tmp5_;
	gint height;
	gint rightBound = 0;
	gint downBound = 0;
	gint leftBound = 0;
	gint upBound = 0;
	gint boundWidth = 0;
	gint boundHeight = 0;
	gfloat altZoom = 0.0F;
	CompiledCircuit* _tmp6_;
	CustomComponentDef* _tmp7_;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	gint _tmp11_ = 0;
	gboolean _tmp12_ = FALSE;
	gint _tmp13_;
	gint _tmp14_;
	gboolean _tmp17_;
	gint _tmp18_;
	gint _tmp19_;
	gint _tmp20_;
	gint _tmp21_;
	gint _tmp22_;
	gint _tmp23_;
	gint _tmp24_;
	gint _tmp25_;
	gint _tmp26_;
	gint _tmp27_;
	gint _tmp28_;
	gint _tmp29_;
	gint _tmp30_;
	gint _tmp31_;
	gint _tmp32_;
	gint _tmp33_;
	gfloat _tmp34_;
	gfloat _tmp35_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->controller;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	areaAllocation = _tmp1_;
	_tmp2_ = areaAllocation;
	_tmp3_ = _tmp2_.width;
	width = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.height;
	height = _tmp5_;
	_tmp6_ = self->priv->compiledCircuit;
	_tmp7_ = _tmp6_->viewedComponent;
	custom_component_def_get_design_bounds (_tmp7_, &_tmp8_, &_tmp9_, &_tmp10_, &_tmp11_);
	rightBound = _tmp8_;
	downBound = _tmp9_;
	leftBound = _tmp10_;
	upBound = _tmp11_;
	_tmp13_ = rightBound;
	_tmp14_ = leftBound;
	if (_tmp13_ == _tmp14_) {
		_tmp12_ = TRUE;
	} else {
		gint _tmp15_;
		gint _tmp16_;
		_tmp15_ = downBound;
		_tmp16_ = upBound;
		_tmp12_ = _tmp15_ == _tmp16_;
	}
	_tmp17_ = _tmp12_;
	if (_tmp17_) {
		return;
	}
	_tmp18_ = rightBound;
	rightBound = _tmp18_ + 10;
	_tmp19_ = downBound;
	downBound = _tmp19_ + 10;
	_tmp20_ = leftBound;
	leftBound = _tmp20_ - 10;
	_tmp21_ = upBound;
	upBound = _tmp21_ - 10;
	_tmp22_ = rightBound;
	_tmp23_ = leftBound;
	self->priv->xView = (_tmp22_ + _tmp23_) / 2;
	_tmp24_ = downBound;
	_tmp25_ = upBound;
	self->priv->yView = (_tmp24_ + _tmp25_) / 2;
	_tmp26_ = rightBound;
	_tmp27_ = leftBound;
	boundWidth = _tmp26_ - _tmp27_;
	_tmp28_ = downBound;
	_tmp29_ = upBound;
	boundHeight = _tmp28_ - _tmp29_;
	_tmp30_ = width;
	_tmp31_ = boundWidth;
	self->zoom = ((gfloat) _tmp30_) / ((gfloat) _tmp31_);
	_tmp32_ = height;
	_tmp33_ = boundHeight;
	altZoom = ((gfloat) _tmp32_) / ((gfloat) _tmp33_);
	_tmp34_ = altZoom;
	_tmp35_ = self->zoom;
	if (_tmp34_ < _tmp35_) {
		gfloat _tmp36_;
		_tmp36_ = altZoom;
		self->zoom = _tmp36_;
	}
	simulator_window_render (self, TRUE, FALSE, NULL);
}


/**
 * Run periodically using a timer. Updates the display.
 */
static gboolean simulator_window_refresh_cycle (SimulatorWindow* self) {
	gboolean result = FALSE;
	GTimer* _tmp0_;
	GTimer* renderingTimer;
	gboolean _tmp1_ = FALSE;
	SimulatorWindowRunState _tmp2_;
	gboolean _tmp4_;
	gboolean _tmp10_ = FALSE;
	SimulatorWindowRunState _tmp11_;
	gboolean _tmp13_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = g_timer_new ();
	renderingTimer = _tmp0_;
	_tmp2_ = self->priv->runState;
	if (_tmp2_ != SIMULATOR_WINDOW_RUN_STATE_HALTING) {
		gdouble _tmp3_;
		_tmp3_ = self->priv->timeBeforeRender;
		_tmp1_ = _tmp3_ <= 0.0;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		GTimer* _tmp5_;
		TimingDiagram* _tmp6_;
		GTimer* _tmp7_;
		GTimer* _tmp8_;
		gdouble _tmp9_ = 0.0;
		_tmp5_ = renderingTimer;
		g_timer_start (_tmp5_);
		simulator_window_render (self, FALSE, FALSE, NULL);
		_tmp6_ = self->priv->timingDiagram;
		timing_diagram_render (_tmp6_, FALSE, NULL);
		_tmp7_ = renderingTimer;
		g_timer_stop (_tmp7_);
		_tmp8_ = renderingTimer;
		_tmp9_ = g_timer_elapsed (_tmp8_, NULL);
		self->priv->timeBeforeRender = _tmp9_;
	}
	_tmp11_ = self->priv->runState;
	if (_tmp11_ == SIMULATOR_WINDOW_RUN_STATE_RUNNING) {
		_tmp10_ = TRUE;
	} else {
		SimulatorWindowRunState _tmp12_;
		_tmp12_ = self->priv->runState;
		_tmp10_ = _tmp12_ == SIMULATOR_WINDOW_RUN_STATE_STEPPING;
	}
	_tmp13_ = _tmp10_;
	if (_tmp13_) {
		result = TRUE;
		_g_timer_destroy0 (renderingTimer);
		return result;
	} else {
		result = FALSE;
		_g_timer_destroy0 (renderingTimer);
		return result;
	}
	_g_timer_destroy0 (renderingTimer);
}


/**
 * Run periodically using a timer. Runs an single iteration of the
 * simulation.
 */
static gboolean simulator_window_update_cycle (SimulatorWindow* self) {
	gboolean result = FALSE;
	GTimer* _tmp0_;
	GTimer* simulationTimer;
	GTimer* _tmp1_;
	CompiledCircuit* _tmp2_;
	gint _tmp3_ = 0;
	gint _result_;
	GTimer* _tmp4_;
	GTimer* _tmp5_;
	gdouble _tmp6_ = 0.0;
	gint _tmp7_;
	gint _tmp13_;
	SimulatorWindowRunState _tmp25_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = g_timer_new ();
	simulationTimer = _tmp0_;
	_tmp1_ = simulationTimer;
	g_timer_start (_tmp1_);
	_tmp2_ = self->priv->compiledCircuit;
	_tmp3_ = compiled_circuit_update_cycle (_tmp2_);
	_result_ = _tmp3_;
	_tmp4_ = simulationTimer;
	g_timer_stop (_tmp4_);
	_tmp5_ = simulationTimer;
	_tmp6_ = g_timer_elapsed (_tmp5_, NULL);
	_tmp7_ = self->priv->microCycleDelay;
	if (_tmp6_ < ((gdouble) _tmp7_)) {
		gdouble _tmp8_;
		gint _tmp9_;
		_tmp8_ = self->priv->timeBeforeRender;
		_tmp9_ = self->priv->microCycleDelay;
		self->priv->timeBeforeRender = _tmp8_ - ((gdouble) _tmp9_);
	} else {
		gdouble _tmp10_;
		GTimer* _tmp11_;
		gdouble _tmp12_ = 0.0;
		_tmp10_ = self->priv->timeBeforeRender;
		_tmp11_ = simulationTimer;
		_tmp12_ = g_timer_elapsed (_tmp11_, NULL);
		self->priv->timeBeforeRender = _tmp10_ - _tmp12_;
	}
	_tmp13_ = _result_;
	if (_tmp13_ == 1) {
		FILE* _tmp14_;
		FILE* _tmp15_;
		FILE* _tmp16_;
		CompiledCircuit* _tmp17_;
		const gchar* _tmp18_;
		const gchar* _tmp19_;
		CompiledCircuit* _tmp20_;
		const gchar* _tmp21_;
		const gchar* _tmp22_;
		gchar* _tmp23_;
		gchar* _tmp24_;
		self->priv->runState = SIMULATOR_WINDOW_RUN_STATE_ERROR;
		simulator_window_render (self, TRUE, FALSE, NULL);
		_tmp14_ = stdout;
		fprintf (_tmp14_, "Simulation Error!\n");
		_tmp15_ = stdout;
		fflush (_tmp15_);
		_tmp16_ = stderr;
		_tmp17_ = self->priv->compiledCircuit;
		_tmp18_ = compiled_circuit_get_errorMessage (_tmp17_);
		_tmp19_ = _tmp18_;
		fprintf (_tmp16_, "Error Messages:\n%s\n", _tmp19_);
		_tmp20_ = self->priv->compiledCircuit;
		_tmp21_ = compiled_circuit_get_errorMessage (_tmp20_);
		_tmp22_ = _tmp21_;
		_tmp23_ = g_strconcat ("Circuit Runtime Error:\n", _tmp22_, NULL);
		_tmp24_ = _tmp23_;
		basic_dialog_error (NULL, _tmp24_);
		_g_free0 (_tmp24_);
	}
	_tmp25_ = self->priv->runState;
	if (_tmp25_ == SIMULATOR_WINDOW_RUN_STATE_RUNNING) {
		result = TRUE;
		_g_timer_destroy0 (simulationTimer);
		return result;
	} else {
		SimulatorWindowRunState _tmp26_;
		_tmp26_ = self->priv->runState;
		if (_tmp26_ == SIMULATOR_WINDOW_RUN_STATE_STEPPING) {
			gint _tmp27_;
			gint _tmp28_;
			_tmp27_ = self->priv->stepsLeft;
			self->priv->stepsLeft = _tmp27_ - 1;
			_tmp28_ = self->priv->stepsLeft;
			if (_tmp28_ <= 0) {
				simulator_window_pause (self);
				result = FALSE;
				_g_timer_destroy0 (simulationTimer);
				return result;
			} else {
				result = TRUE;
				_g_timer_destroy0 (simulationTimer);
				return result;
			}
		} else {
			result = FALSE;
			_g_timer_destroy0 (simulationTimer);
			return result;
		}
	}
	_g_timer_destroy0 (simulationTimer);
}


/**
 * Handles mouse button down in the work area. Records mouse
 * (drag) starting point.
 */
static gboolean simulator_window_mouse_down (SimulatorWindow* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GdkEventButton _tmp0_;
	gdouble _tmp1_;
	GdkEventButton _tmp2_;
	gdouble _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.x;
	self->priv->xMouseStart = (gint) _tmp1_;
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.y;
	self->priv->yMouseStart = (gint) _tmp3_;
	result = FALSE;
	return result;
}


/**
 * Handles mouse button up in the work area. Performs an action
 * which is determined by //mouseMode//.
 */
static gboolean simulator_window_mouse_up (SimulatorWindow* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GtkAllocation areaAllocation = {0};
	GtkEventBox* _tmp0_;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_;
	gint _tmp3_;
	gint width;
	GtkAllocation _tmp4_;
	gint _tmp5_;
	gint height;
	gint _tmp6_;
	gint xCentre;
	gint _tmp7_;
	gint yCentre;
	gint _tmp8_;
	gint _tmp9_;
	gint xStart;
	gint _tmp10_;
	gint _tmp11_;
	gint yStart;
	GdkEventButton _tmp12_;
	gdouble _tmp13_;
	gint _tmp14_;
	gint xEnd;
	GdkEventButton _tmp15_;
	gdouble _tmp16_;
	gint _tmp17_;
	gint yEnd;
	gint _tmp18_;
	gint _tmp19_;
	gint yDiff;
	gint _tmp20_;
	gfloat _tmp21_;
	gint _tmp22_;
	gint xBoardStart;
	gint _tmp23_;
	gfloat _tmp24_;
	gint _tmp25_;
	gint yBoardStart;
	gint _tmp26_;
	gfloat _tmp27_;
	gint _tmp28_;
	gint xBoardEnd;
	gint _tmp29_;
	gfloat _tmp30_;
	gint _tmp31_;
	gint yBoardEnd;
	gboolean snapGridStart;
	gboolean snapGridEnd;
	gint _tmp32_;
	gint halfGridSize;
	gboolean _tmp33_;
	gboolean _tmp52_;
	gint _tmp71_;
	gint _tmp72_;
	gint xBoardDiff;
	gint _tmp73_;
	gint _tmp74_;
	gint yBoardDiff;
	gint _tmp75_ = 0;
	gint _tmp76_;
	gint _tmp79_;
	gint yDiffAbs;
	SimulatorWindowMouseMode _tmp80_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->controller;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	areaAllocation = _tmp1_;
	_tmp2_ = areaAllocation;
	_tmp3_ = _tmp2_.width;
	width = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.height;
	height = _tmp5_;
	_tmp6_ = width;
	xCentre = _tmp6_ / 2;
	_tmp7_ = height;
	yCentre = _tmp7_ / 2;
	_tmp8_ = self->priv->xMouseStart;
	_tmp9_ = xCentre;
	xStart = _tmp8_ - _tmp9_;
	_tmp10_ = self->priv->yMouseStart;
	_tmp11_ = yCentre;
	yStart = _tmp10_ - _tmp11_;
	_tmp12_ = *event;
	_tmp13_ = _tmp12_.x;
	_tmp14_ = xCentre;
	xEnd = ((gint) _tmp13_) - _tmp14_;
	_tmp15_ = *event;
	_tmp16_ = _tmp15_.y;
	_tmp17_ = yCentre;
	yEnd = ((gint) _tmp16_) - _tmp17_;
	_tmp18_ = yEnd;
	_tmp19_ = yStart;
	yDiff = _tmp18_ - _tmp19_;
	_tmp20_ = xStart;
	_tmp21_ = self->zoom;
	_tmp22_ = self->priv->xView;
	xBoardStart = (gint) ((((gfloat) _tmp20_) / _tmp21_) + ((gfloat) _tmp22_));
	_tmp23_ = yStart;
	_tmp24_ = self->zoom;
	_tmp25_ = self->priv->yView;
	yBoardStart = (gint) ((((gfloat) _tmp23_) / _tmp24_) + ((gfloat) _tmp25_));
	_tmp26_ = xEnd;
	_tmp27_ = self->zoom;
	_tmp28_ = self->priv->xView;
	xBoardEnd = (gint) ((((gfloat) _tmp26_) / _tmp27_) + ((gfloat) _tmp28_));
	_tmp29_ = yEnd;
	_tmp30_ = self->zoom;
	_tmp31_ = self->priv->yView;
	yBoardEnd = (gint) ((((gfloat) _tmp29_) / _tmp30_) + ((gfloat) _tmp31_));
	snapGridStart = TRUE;
	snapGridEnd = TRUE;
	_tmp32_ = self->gridSize;
	halfGridSize = _tmp32_ / 2;
	_tmp33_ = snapGridStart;
	if (_tmp33_) {
		gint _tmp34_ = 0;
		gint _tmp35_;
		gint _tmp38_;
		gint _tmp39_;
		gint _tmp40_ = 0;
		gint _tmp41_;
		gint _tmp44_;
		gint _tmp45_;
		gint _tmp46_;
		gint _tmp47_;
		gint _tmp48_;
		gint _tmp49_;
		gint _tmp50_;
		gint _tmp51_;
		_tmp35_ = xBoardStart;
		if (_tmp35_ > 0) {
			gint _tmp36_;
			_tmp36_ = halfGridSize;
			_tmp34_ = _tmp36_;
		} else {
			gint _tmp37_;
			_tmp37_ = halfGridSize;
			_tmp34_ = -_tmp37_;
		}
		_tmp38_ = xBoardStart;
		_tmp39_ = _tmp34_;
		xBoardStart = _tmp38_ + _tmp39_;
		_tmp41_ = yBoardStart;
		if (_tmp41_ > 0) {
			gint _tmp42_;
			_tmp42_ = halfGridSize;
			_tmp40_ = _tmp42_;
		} else {
			gint _tmp43_;
			_tmp43_ = halfGridSize;
			_tmp40_ = -_tmp43_;
		}
		_tmp44_ = yBoardStart;
		_tmp45_ = _tmp40_;
		yBoardStart = _tmp44_ + _tmp45_;
		_tmp46_ = xBoardStart;
		_tmp47_ = self->gridSize;
		_tmp48_ = self->gridSize;
		xBoardStart = (_tmp46_ / _tmp47_) * _tmp48_;
		_tmp49_ = yBoardStart;
		_tmp50_ = self->gridSize;
		_tmp51_ = self->gridSize;
		yBoardStart = (_tmp49_ / _tmp50_) * _tmp51_;
	}
	_tmp52_ = snapGridEnd;
	if (_tmp52_) {
		gint _tmp53_ = 0;
		gint _tmp54_;
		gint _tmp57_;
		gint _tmp58_;
		gint _tmp59_ = 0;
		gint _tmp60_;
		gint _tmp63_;
		gint _tmp64_;
		gint _tmp65_;
		gint _tmp66_;
		gint _tmp67_;
		gint _tmp68_;
		gint _tmp69_;
		gint _tmp70_;
		_tmp54_ = xBoardEnd;
		if (_tmp54_ > 0) {
			gint _tmp55_;
			_tmp55_ = halfGridSize;
			_tmp53_ = _tmp55_;
		} else {
			gint _tmp56_;
			_tmp56_ = halfGridSize;
			_tmp53_ = -_tmp56_;
		}
		_tmp57_ = xBoardEnd;
		_tmp58_ = _tmp53_;
		xBoardEnd = _tmp57_ + _tmp58_;
		_tmp60_ = yBoardEnd;
		if (_tmp60_ > 0) {
			gint _tmp61_;
			_tmp61_ = halfGridSize;
			_tmp59_ = _tmp61_;
		} else {
			gint _tmp62_;
			_tmp62_ = halfGridSize;
			_tmp59_ = -_tmp62_;
		}
		_tmp63_ = yBoardEnd;
		_tmp64_ = _tmp59_;
		yBoardEnd = _tmp63_ + _tmp64_;
		_tmp65_ = xBoardEnd;
		_tmp66_ = self->gridSize;
		_tmp67_ = self->gridSize;
		xBoardEnd = (_tmp65_ / _tmp66_) * _tmp67_;
		_tmp68_ = yBoardEnd;
		_tmp69_ = self->gridSize;
		_tmp70_ = self->gridSize;
		yBoardEnd = (_tmp68_ / _tmp69_) * _tmp70_;
	}
	_tmp71_ = xBoardEnd;
	_tmp72_ = xBoardStart;
	xBoardDiff = _tmp71_ - _tmp72_;
	_tmp73_ = yBoardEnd;
	_tmp74_ = yBoardStart;
	yBoardDiff = _tmp73_ - _tmp74_;
	_tmp76_ = yDiff;
	if (_tmp76_ > 0) {
		gint _tmp77_;
		_tmp77_ = yDiff;
		_tmp75_ = _tmp77_;
	} else {
		gint _tmp78_;
		_tmp78_ = yDiff;
		_tmp75_ = -_tmp78_;
	}
	_tmp79_ = _tmp75_;
	yDiffAbs = _tmp79_;
	_tmp80_ = self->priv->mouseMode;
	switch (_tmp80_) {
		case SIMULATOR_WINDOW_MOUSE_MODE_SCROLL:
		{
			gint _tmp81_;
			gint _tmp82_;
			gint _tmp83_;
			gint _tmp84_;
			_tmp81_ = self->priv->xView;
			_tmp82_ = xBoardDiff;
			self->priv->xView = _tmp81_ - _tmp82_;
			_tmp83_ = self->priv->yView;
			_tmp84_ = yBoardDiff;
			self->priv->yView = _tmp83_ - _tmp84_;
			simulator_window_render (self, TRUE, FALSE, NULL);
			break;
		}
		case SIMULATOR_WINDOW_MOUSE_MODE_ZOOM:
		{
			gint _tmp85_;
			_tmp85_ = yDiff;
			if (_tmp85_ > 0) {
				gfloat _tmp86_;
				gint _tmp87_;
				gint _tmp88_;
				_tmp86_ = self->zoom;
				_tmp87_ = yDiffAbs;
				_tmp88_ = height;
				self->zoom = _tmp86_ * (1.0f + (((gfloat) _tmp87_) / ((gfloat) _tmp88_)));
			} else {
				gfloat _tmp89_;
				gint _tmp90_;
				gint _tmp91_;
				_tmp89_ = self->zoom;
				_tmp90_ = yDiffAbs;
				_tmp91_ = height;
				self->zoom = _tmp89_ / (1.0f + (((gfloat) _tmp90_) / ((gfloat) _tmp91_)));
			}
			simulator_window_render (self, TRUE, FALSE, NULL);
			break;
		}
		case SIMULATOR_WINDOW_MOUSE_MODE_INTERACT:
		{
			CompiledCircuit* _tmp92_;
			gint _tmp93_;
			gint _tmp94_;
			_tmp92_ = self->priv->compiledCircuit;
			_tmp93_ = xBoardEnd;
			_tmp94_ = yBoardEnd;
			compiled_circuit_interact_components (_tmp92_, _tmp93_, _tmp94_);
			simulator_window_render (self, TRUE, TRUE, NULL);
			break;
		}
		case SIMULATOR_WINDOW_MOUSE_MODE_CONTEXT:
		{
			CompiledCircuit* _tmp95_;
			gint _tmp96_;
			gint _tmp97_;
			gint _tmp98_ = 0;
			gint _result_;
			gint _tmp99_;
			_tmp95_ = self->priv->compiledCircuit;
			_tmp96_ = xBoardEnd;
			_tmp97_ = yBoardEnd;
			_tmp98_ = compiled_circuit_expand_component (_tmp95_, _tmp96_, _tmp97_);
			_result_ = _tmp98_;
			_tmp99_ = _result_;
			switch (_tmp99_) {
				case 0:
				{
					gboolean _tmp100_;
					_tmp100_ = self->priv->autoFitDesign;
					if (_tmp100_) {
						simulator_window_fit_design (self);
					}
					simulator_window_render (self, TRUE, FALSE, NULL);
					break;
				}
				case 1:
				{
					CompiledCircuit* _tmp101_;
					gboolean _tmp102_;
					_tmp101_ = self->priv->compiledCircuit;
					compiled_circuit_shrink_component (_tmp101_);
					_tmp102_ = self->priv->autoFitDesign;
					if (_tmp102_) {
						simulator_window_fit_design (self);
					}
					simulator_window_render (self, TRUE, FALSE, NULL);
					break;
				}
				case 2:
				{
					CompiledCircuit* _tmp103_;
					gint _tmp104_;
					gint _tmp105_;
					_tmp103_ = self->priv->compiledCircuit;
					_tmp104_ = xBoardEnd;
					_tmp105_ = yBoardEnd;
					compiled_circuit_interact_components (_tmp103_, _tmp104_, _tmp105_);
					simulator_window_render (self, TRUE, TRUE, NULL);
					break;
				}
				default:
				break;
			}
			break;
		}
		case SIMULATOR_WINDOW_MOUSE_MODE_EXPLORE:
		{
			CompiledCircuit* _tmp106_;
			gint _tmp107_;
			gint _tmp108_;
			gint _tmp109_ = 0;
			gint _result_;
			gint _tmp110_;
			_tmp106_ = self->priv->compiledCircuit;
			_tmp107_ = xBoardEnd;
			_tmp108_ = yBoardEnd;
			_tmp109_ = compiled_circuit_expand_component (_tmp106_, _tmp107_, _tmp108_);
			_result_ = _tmp109_;
			_tmp110_ = _result_;
			switch (_tmp110_) {
				case 0:
				{
					gboolean _tmp111_;
					_tmp111_ = self->priv->autoFitDesign;
					if (_tmp111_) {
						simulator_window_fit_design (self);
					}
					simulator_window_render (self, TRUE, FALSE, NULL);
					break;
				}
				case 1:
				{
					CompiledCircuit* _tmp112_;
					gboolean _tmp113_;
					_tmp112_ = self->priv->compiledCircuit;
					compiled_circuit_shrink_component (_tmp112_);
					_tmp113_ = self->priv->autoFitDesign;
					if (_tmp113_) {
						simulator_window_fit_design (self);
					}
					simulator_window_render (self, TRUE, FALSE, NULL);
					break;
				}
				case 2:
				{
					break;
				}
				default:
				break;
			}
			break;
		}
		case SIMULATOR_WINDOW_MOUSE_MODE_WATCH:
		{
			CompiledCircuit* _tmp114_;
			gint _tmp115_;
			gint _tmp116_;
			WireState* _tmp117_ = NULL;
			WireState* wireState;
			WireState* _tmp118_;
			_tmp114_ = self->priv->compiledCircuit;
			_tmp115_ = xBoardEnd;
			_tmp116_ = yBoardEnd;
			_tmp117_ = compiled_circuit_find_wire (_tmp114_, _tmp115_, _tmp116_);
			wireState = _tmp117_;
			_tmp118_ = wireState;
			if (_tmp118_ != NULL) {
				TimingDiagram* _tmp119_;
				WireState* _tmp120_;
				_tmp119_ = self->priv->timingDiagram;
				_tmp120_ = wireState;
				timing_diagram_add_wire (_tmp119_, _tmp120_);
			}
			_wire_state_unref0 (wireState);
			break;
		}
		default:
		break;
	}
	result = FALSE;
	return result;
}


/**
 * Renders the currently viewed part of the simulation. If
 * //fullRefresh// is false, then the circuit design is not redrawn.
 */
static gpointer _cairo_reference0 (gpointer self) {
	return self ? cairo_reference (self) : NULL;
}


gboolean simulator_window_render (SimulatorWindow* self, gboolean fullRefresh, gboolean cancelIfRunning, cairo_t* passedDisplayContext) {
	gboolean result = FALSE;
	cairo_t* displayContext = NULL;
	gint width = 0;
	gint height = 0;
	GtkAllocation areaAllocation = {0};
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp3_;
	SimulatorWindowRunState _tmp4_;
	GtkDrawingArea* _tmp7_;
	GtkAllocation _tmp8_ = {0};
	GtkAllocation _tmp9_;
	gint _tmp10_;
	GtkAllocation _tmp11_;
	gint _tmp12_;
	cairo_t* _tmp13_;
	gboolean _tmp19_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = cancelIfRunning;
	if (_tmp1_) {
		SimulatorWindowRunState _tmp2_;
		_tmp2_ = self->priv->runState;
		_tmp0_ = _tmp2_ == SIMULATOR_WINDOW_RUN_STATE_RUNNING;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		result = FALSE;
		_cairo_destroy0 (displayContext);
		return result;
	}
	_tmp4_ = self->priv->runState;
	if (_tmp4_ == SIMULATOR_WINDOW_RUN_STATE_PAUSED) {
		gboolean _tmp5_;
		_tmp5_ = self->priv->inhibitRender;
		if (_tmp5_) {
			result = FALSE;
			_cairo_destroy0 (displayContext);
			return result;
		}
		self->priv->inhibitRender = TRUE;
		while (TRUE) {
			gboolean _tmp6_ = FALSE;
			_tmp6_ = gtk_events_pending ();
			if (!_tmp6_) {
				break;
			}
			gtk_main_iteration ();
		}
		self->priv->inhibitRender = FALSE;
	}
	_tmp7_ = self->priv->display;
	gtk_widget_get_allocation ((GtkWidget*) _tmp7_, &_tmp8_);
	areaAllocation = _tmp8_;
	_tmp9_ = areaAllocation;
	_tmp10_ = _tmp9_.width;
	width = _tmp10_;
	_tmp11_ = areaAllocation;
	_tmp12_ = _tmp11_.height;
	height = _tmp12_;
	_tmp13_ = passedDisplayContext;
	if (_tmp13_ == NULL) {
		GtkDrawingArea* _tmp14_;
		GdkWindow* _tmp15_ = NULL;
		cairo_t* _tmp16_ = NULL;
		_tmp14_ = self->priv->display;
		_tmp15_ = gtk_widget_get_window ((GtkWidget*) _tmp14_);
		_tmp16_ = gdk_cairo_create (_tmp15_);
		_cairo_destroy0 (displayContext);
		displayContext = _tmp16_;
	} else {
		cairo_t* _tmp17_;
		cairo_t* _tmp18_;
		_tmp17_ = passedDisplayContext;
		_tmp18_ = _cairo_reference0 (_tmp17_);
		_cairo_destroy0 (displayContext);
		displayContext = _tmp18_;
	}
	_tmp19_ = fullRefresh;
	if (_tmp19_) {
		cairo_t* _tmp20_;
		cairo_surface_t* _tmp21_ = NULL;
		cairo_t* _tmp22_;
		cairo_surface_t* _tmp23_ = NULL;
		cairo_content_t _tmp24_ = 0;
		gint _tmp25_;
		gint _tmp26_;
		cairo_surface_t* _tmp27_;
		cairo_surface_t* offScreenSurface;
		cairo_surface_t* _tmp28_;
		cairo_t* _tmp29_;
		cairo_t* context;
		cairo_t* _tmp30_;
		cairo_t* _tmp31_;
		cairo_t* _tmp32_;
		gint _tmp33_;
		gint _tmp34_;
		cairo_t* _tmp35_;
		gfloat _tmp36_;
		gfloat _tmp37_;
		cairo_t* _tmp38_;
		gint _tmp39_;
		gint _tmp40_;
		CompiledCircuit* _tmp41_;
		cairo_t* _tmp42_;
		gfloat _tmp43_;
		cairo_t* _tmp44_;
		cairo_surface_t* _tmp45_;
		cairo_t* _tmp46_;
		_tmp20_ = displayContext;
		_tmp21_ = cairo_get_target (_tmp20_);
		_tmp22_ = displayContext;
		_tmp23_ = cairo_get_target (_tmp22_);
		_tmp24_ = cairo_surface_get_content (_tmp23_);
		_tmp25_ = width;
		_tmp26_ = height;
		_tmp27_ = cairo_surface_create_similar (_tmp21_, _tmp24_, _tmp25_, _tmp26_);
		offScreenSurface = _tmp27_;
		_tmp28_ = offScreenSurface;
		_tmp29_ = cairo_create (_tmp28_);
		context = _tmp29_;
		_tmp30_ = context;
		cairo_set_source_rgb (_tmp30_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
		_tmp31_ = context;
		cairo_paint (_tmp31_);
		_tmp32_ = context;
		_tmp33_ = width;
		_tmp34_ = height;
		cairo_translate (_tmp32_, (gdouble) (_tmp33_ / 2), (gdouble) (_tmp34_ / 2));
		_tmp35_ = context;
		_tmp36_ = self->zoom;
		_tmp37_ = self->zoom;
		cairo_scale (_tmp35_, (gdouble) _tmp36_, (gdouble) _tmp37_);
		_tmp38_ = context;
		_tmp39_ = self->priv->xView;
		_tmp40_ = self->priv->yView;
		cairo_translate (_tmp38_, (gdouble) (-_tmp39_), (gdouble) (-_tmp40_));
		_tmp41_ = self->priv->compiledCircuit;
		_tmp42_ = context;
		_tmp43_ = self->zoom;
		compiled_circuit_render (_tmp41_, _tmp42_, TRUE, _tmp43_);
		_tmp44_ = displayContext;
		_tmp45_ = offScreenSurface;
		cairo_set_source_surface (_tmp44_, _tmp45_, (gdouble) 0, (gdouble) 0);
		_tmp46_ = displayContext;
		cairo_paint (_tmp46_);
		_cairo_destroy0 (context);
		_cairo_surface_destroy0 (offScreenSurface);
	} else {
		cairo_t* _tmp47_;
		gint _tmp48_;
		gint _tmp49_;
		cairo_t* _tmp50_;
		gfloat _tmp51_;
		gfloat _tmp52_;
		cairo_t* _tmp53_;
		gint _tmp54_;
		gint _tmp55_;
		CompiledCircuit* _tmp56_;
		cairo_t* _tmp57_;
		gfloat _tmp58_;
		_tmp47_ = displayContext;
		_tmp48_ = width;
		_tmp49_ = height;
		cairo_translate (_tmp47_, (gdouble) (_tmp48_ / 2), (gdouble) (_tmp49_ / 2));
		_tmp50_ = displayContext;
		_tmp51_ = self->zoom;
		_tmp52_ = self->zoom;
		cairo_scale (_tmp50_, (gdouble) _tmp51_, (gdouble) _tmp52_);
		_tmp53_ = displayContext;
		_tmp54_ = self->priv->xView;
		_tmp55_ = self->priv->yView;
		cairo_translate (_tmp53_, (gdouble) (-_tmp54_), (gdouble) (-_tmp55_));
		_tmp56_ = self->priv->compiledCircuit;
		_tmp57_ = displayContext;
		_tmp58_ = self->zoom;
		compiled_circuit_render (_tmp56_, _tmp57_, FALSE, _tmp58_);
	}
	result = FALSE;
	_cairo_destroy0 (displayContext);
	return result;
}


/**
 * Ends the simulation. Presenting a summary.
 */
void simulator_window_close_simulation (SimulatorWindow* self) {
	FILE* _tmp0_;
	TimingDiagram* _tmp1_;
	CompiledCircuit* _tmp2_;
	gint _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	CompiledCircuit* _tmp8_;
	Project* _tmp9_;
	g_return_if_fail (self != NULL);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "Ending Simulation.\n");
	self->priv->runState = SIMULATOR_WINDOW_RUN_STATE_HALTING;
	_tmp1_ = self->priv->timingDiagram;
	gtk_widget_destroy ((GtkWidget*) _tmp1_);
	_tmp2_ = self->priv->compiledCircuit;
	_tmp3_ = _tmp2_->iterationCount;
	_tmp4_ = g_strdup_printf ("%i", _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat ("Simulation Summary:\nIterations: ", _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	basic_dialog_information (NULL, _tmp7_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_tmp8_ = self->priv->compiledCircuit;
	_tmp9_ = _tmp8_->project;
	_tmp9_->running = FALSE;
}


static void simulator_window_class_init (SimulatorWindowClass * klass) {
	simulator_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SimulatorWindowPrivate));
	G_OBJECT_CLASS (klass)->finalize = simulator_window_finalize;
}


static void simulator_window_instance_init (SimulatorWindow * self) {
	self->priv = SIMULATOR_WINDOW_GET_PRIVATE (self);
	self->priv->mouseMode = SIMULATOR_WINDOW_MOUSE_MODE_CONTEXT;
	self->gridSize = 5;
	self->priv->xView = 0;
	self->priv->yView = 0;
	self->zoom = (gfloat) 1;
	self->priv->cycleDelay = 0;
	self->priv->multistepSize = 50;
	self->priv->stepsLeft = 0;
	self->priv->cycleSourceID = (guint) 0;
	self->priv->refreshSourceID = (guint) 0;
	self->priv->microCycleDelay = 0;
	self->priv->inhibitRender = FALSE;
	self->priv->autoFitDesign = TRUE;
}


static void simulator_window_finalize (GObject* obj) {
	SimulatorWindow * self;
	TimingDiagram* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SIMULATOR_WINDOW, SimulatorWindow);
	_tmp0_ = self->priv->timingDiagram;
	timing_diagram_close_diagram (_tmp0_);
	_g_object_unref0 (self->priv->vBox);
	_g_object_unref0 (self->priv->menubar);
	_g_object_unref0 (self->priv->menuSimulation);
	_g_object_unref0 (self->priv->menuSimulationMenu);
	_g_object_unref0 (self->priv->menuSimulationRun);
	_g_object_unref0 (self->priv->menuSimulationSeparator1);
	_g_object_unref0 (self->priv->menuSimulationExit);
	_g_object_unref0 (self->priv->menuView);
	_g_object_unref0 (self->priv->menuViewMenu);
	_g_object_unref0 (self->priv->menuViewFitdesign);
	_g_object_unref0 (self->priv->menuViewAutofitdesign);
	_g_object_unref0 (self->priv->menuViewSeparator1);
	_g_object_unref0 (self->priv->menuViewTimingdiagram);
	_g_object_unref0 (self->priv->toolbar);
	_g_object_unref0 (self->priv->toolScroll);
	_g_object_unref0 (self->priv->toolScrollImage);
	_g_object_unref0 (self->priv->toolZoom);
	_g_object_unref0 (self->priv->toolZoomImage);
	_g_object_unref0 (self->priv->toolSeparator1);
	_g_object_unref0 (self->priv->toolContext);
	_g_object_unref0 (self->priv->toolContextImage);
	_g_object_unref0 (self->priv->toolInteract);
	_g_object_unref0 (self->priv->toolInteractImage);
	_g_object_unref0 (self->priv->toolExplore);
	_g_object_unref0 (self->priv->toolExploreImage);
	_g_object_unref0 (self->priv->toolWatch);
	_g_object_unref0 (self->priv->toolWatchImage);
	_g_object_unref0 (self->priv->toolSeparator2);
	_g_object_unref0 (self->priv->toolShrink);
	_g_object_unref0 (self->priv->toolShrinkImage);
	_g_object_unref0 (self->priv->toolSeparator3);
	_g_object_unref0 (self->priv->toolRun);
	_g_object_unref0 (self->priv->toolRunImage);
	_g_object_unref0 (self->priv->toolSinglestep);
	_g_object_unref0 (self->priv->toolSinglestepImage);
	_g_object_unref0 (self->priv->toolMultistep);
	_g_object_unref0 (self->priv->toolMultistepImage);
	_g_object_unref0 (self->priv->toolSeparator4);
	_g_object_unref0 (self->priv->toolMaxspeed);
	_g_object_unref0 (self->priv->toolMaxspeedImage);
	_g_object_unref0 (self->priv->toolSpeed);
	_g_object_unref0 (self->priv->toolSpeedBox);
	_g_object_unref0 (self->priv->toolSpeedLabel);
	_g_object_unref0 (self->priv->toolSpeedSpin);
	_g_object_unref0 (self->priv->toolSeparator5);
	_g_object_unref0 (self->priv->toolStepsize);
	_g_object_unref0 (self->priv->toolStepsizeBox);
	_g_object_unref0 (self->priv->toolStepsizeLabel);
	_g_object_unref0 (self->priv->toolStepsizeSpin);
	_g_object_unref0 (self->priv->controller);
	_g_object_unref0 (self->priv->display);
	_compiled_circuit_unref0 (self->priv->compiledCircuit);
	_g_object_unref0 (self->priv->timingDiagram);
	G_OBJECT_CLASS (simulator_window_parent_class)->finalize (obj);
}


/**
 * Interface for the user when running a circuit.
 * 
 * Allows a user to control and explore a circuit, using the
 * CompiledCircuit as a back-end.
 */
GType simulator_window_get_type (void) {
	static volatile gsize simulator_window_type_id__volatile = 0;
	if (g_once_init_enter (&simulator_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SimulatorWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) simulator_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SimulatorWindow), 0, (GInstanceInitFunc) simulator_window_instance_init, NULL };
		GType simulator_window_type_id;
		simulator_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "SimulatorWindow", &g_define_type_info, 0);
		g_once_init_leave (&simulator_window_type_id__volatile, simulator_window_type_id);
	}
	return simulator_window_type_id__volatile;
}



