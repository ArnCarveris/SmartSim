/* componentdef.c generated by valac 0.20.1, the Vala compiler
 * generated from componentdef.vala, do not modify */

/* 
 * SmartSim - Digital Logic Circuit Designer and Simulator
 *   
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *   
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *   
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *   
 *   Filename: componentdef.vala
 *   
 *   Copyright Ashley Newson 2013
 */

#include <glib.h>
#include <glib-object.h>
#include <cairo.h>
#include <libxml/tree.h>
#include <libxml/xmlwriter.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <libxml/parser.h>
#include <config.h>
#include <gobject/gvaluecollector.h>


#define TYPE_COMPONENT_DEF (component_def_get_type ())
#define COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_DEF, ComponentDef))
#define COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_DEF, ComponentDefClass))
#define IS_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_DEF))
#define IS_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_DEF))
#define COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_DEF, ComponentDefClass))

typedef struct _ComponentDef ComponentDef;
typedef struct _ComponentDefClass ComponentDefClass;
typedef struct _ComponentDefPrivate ComponentDefPrivate;

#define TYPE_DIRECTION (direction_get_type ())

#define TYPE_COMPONENT_INST (component_inst_get_type ())
#define COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_INST, ComponentInst))
#define COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_INST, ComponentInstClass))
#define IS_COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_INST))
#define IS_COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_INST))
#define COMPONENT_INST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_INST, ComponentInstClass))

typedef struct _ComponentInst ComponentInst;
typedef struct _ComponentInstClass ComponentInstClass;

#define TYPE_PROJECT (project_get_type ())
#define PROJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROJECT, Project))
#define PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROJECT, ProjectClass))
#define IS_PROJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROJECT))
#define IS_PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROJECT))
#define PROJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROJECT, ProjectClass))

typedef struct _Project Project;
typedef struct _ProjectClass ProjectClass;

#define TYPE_CUSTOM_COMPONENT_DEF (custom_component_def_get_type ())
#define CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDef))
#define CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))
#define IS_CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_COMPONENT_DEF))
#define IS_CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOM_COMPONENT_DEF))
#define CUSTOM_COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))

typedef struct _CustomComponentDef CustomComponentDef;
typedef struct _CustomComponentDefClass CustomComponentDefClass;

#define TYPE_PROPERTY_ITEM (property_item_get_type ())
#define PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_ITEM, PropertyItem))
#define PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_ITEM, PropertyItemClass))
#define IS_PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_ITEM))
#define IS_PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_ITEM))
#define PROPERTY_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_ITEM, PropertyItemClass))

typedef struct _PropertyItem PropertyItem;
typedef struct _PropertyItemClass PropertyItemClass;

#define TYPE_PROPERTY_SET (property_set_get_type ())
#define PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_SET, PropertySet))
#define PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_SET, PropertySetClass))
#define IS_PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_SET))
#define IS_PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_SET))
#define PROPERTY_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_SET, PropertySetClass))

typedef struct _PropertySet PropertySet;
typedef struct _PropertySetClass PropertySetClass;

#define TYPE_COMPILED_CIRCUIT (compiled_circuit_get_type ())
#define COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuit))
#define COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))
#define IS_COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPILED_CIRCUIT))
#define IS_COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPILED_CIRCUIT))
#define COMPILED_CIRCUIT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))

typedef struct _CompiledCircuit CompiledCircuit;
typedef struct _CompiledCircuitClass CompiledCircuitClass;

#define TYPE_CONNECTION (connection_get_type ())
#define CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONNECTION, Connection))
#define CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONNECTION, ConnectionClass))
#define IS_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONNECTION))
#define IS_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONNECTION))
#define CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONNECTION, ConnectionClass))

typedef struct _Connection Connection;
typedef struct _ConnectionClass ConnectionClass;

#define TYPE_CIRCUIT_INFORMATION (circuit_information_get_type ())
#define CIRCUIT_INFORMATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CIRCUIT_INFORMATION, CircuitInformation))
#define CIRCUIT_INFORMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CIRCUIT_INFORMATION, CircuitInformationClass))
#define IS_CIRCUIT_INFORMATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CIRCUIT_INFORMATION))
#define IS_CIRCUIT_INFORMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CIRCUIT_INFORMATION))
#define CIRCUIT_INFORMATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CIRCUIT_INFORMATION, CircuitInformationClass))

typedef struct _CircuitInformation CircuitInformation;
typedef struct _CircuitInformationClass CircuitInformationClass;

#define TYPE_GRAPHIC (graphic_get_type ())
#define GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GRAPHIC, Graphic))
#define GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GRAPHIC, GraphicClass))
#define IS_GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GRAPHIC))
#define IS_GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GRAPHIC))
#define GRAPHIC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GRAPHIC, GraphicClass))

typedef struct _Graphic Graphic;
typedef struct _GraphicClass GraphicClass;

#define TYPE_PIN_DEF (pin_def_get_type ())
#define PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PIN_DEF, PinDef))
#define PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PIN_DEF, PinDefClass))
#define IS_PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PIN_DEF))
#define IS_PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PIN_DEF))
#define PIN_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PIN_DEF, PinDefClass))

typedef struct _PinDef PinDef;
typedef struct _PinDefClass PinDefClass;
#define _graphic_unref0(var) ((var == NULL) ? NULL : (var = (graphic_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_PLUGIN_COMPONENT_DEF (plugin_component_def_get_type ())
#define PLUGIN_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLUGIN_COMPONENT_DEF, PluginComponentDef))
#define PLUGIN_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLUGIN_COMPONENT_DEF, PluginComponentDefClass))
#define IS_PLUGIN_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLUGIN_COMPONENT_DEF))
#define IS_PLUGIN_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLUGIN_COMPONENT_DEF))
#define PLUGIN_COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLUGIN_COMPONENT_DEF, PluginComponentDefClass))

typedef struct _PluginComponentDef PluginComponentDef;
typedef struct _PluginComponentDefClass PluginComponentDefClass;

#define TYPE_VERSION_COMPARISON (version_comparison_get_type ())
#define _pin_def_unref0(var) ((var == NULL) ? NULL : (var = (pin_def_unref (var), NULL)))
typedef struct _ComponentInstPrivate ComponentInstPrivate;

#define TYPE_PIN_INST (pin_inst_get_type ())
#define PIN_INST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PIN_INST, PinInst))
#define PIN_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PIN_INST, PinInstClass))
#define IS_PIN_INST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PIN_INST))
#define IS_PIN_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PIN_INST))
#define PIN_INST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PIN_INST, PinInstClass))

typedef struct _PinInst PinInst;
typedef struct _PinInstClass PinInstClass;
typedef struct _PinInstPrivate PinInstPrivate;

#define TYPE_WIRE_INST (wire_inst_get_type ())
#define WIRE_INST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WIRE_INST, WireInst))
#define WIRE_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WIRE_INST, WireInstClass))
#define IS_WIRE_INST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WIRE_INST))
#define IS_WIRE_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WIRE_INST))
#define WIRE_INST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WIRE_INST, WireInstClass))

typedef struct _WireInst WireInst;
typedef struct _WireInstClass WireInstClass;
typedef struct _PinDefPrivate PinDefPrivate;

#define TYPE_FLOW (flow_get_type ())

#define PIN_DEF_TYPE_LABEL_TYPE (pin_def_label_type_get_type ())
#define _property_item_unref0(var) ((var == NULL) ? NULL : (var = (property_item_unref (var), NULL)))
typedef struct _ParamSpecComponentDef ParamSpecComponentDef;

/**
 * ComponentDef load from file errors.
 */
typedef enum  {
	COMPONENT_DEF_LOAD_ERROR_NOT_COMPONENT,
	COMPONENT_DEF_LOAD_ERROR_FILE,
	COMPONENT_DEF_LOAD_ERROR_LOAD,
	COMPONENT_DEF_LOAD_ERROR_CANCEL
} ComponentDefLoadError;
#define COMPONENT_DEF_LOAD_ERROR component_def_load_error_quark ()
typedef enum  {
	DIRECTION_NONE,
	DIRECTION_RIGHT,
	DIRECTION_DOWN,
	DIRECTION_LEFT,
	DIRECTION_UP,
	DIRECTION_HORIZONTAL,
	DIRECTION_VERTICAL,
	DIRECTION_DIAGONAL
} Direction;

struct _ComponentDef {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ComponentDefPrivate * priv;
	Graphic* graphic;
	gchar* name;
	gchar* description;
	gchar* iconFilename;
	gchar* label;
	PinDef** pinDefs;
	gint pinDefs_length1;
	gint rightBound;
	gint downBound;
	gint leftBound;
	gint upBound;
	gint backgroundAlpha;
	gint backgroundRed;
	gint backgroundGreen;
	gint backgroundBlue;
	gdouble backgroundAlphaF;
	gdouble backgroundRedF;
	gdouble backgroundGreenF;
	gdouble backgroundBlueF;
	gboolean drawBox;
	gchar* filename;
};

struct _ComponentDefClass {
	GTypeClass parent_class;
	void (*finalize) (ComponentDef *self);
	void (*extra_render) (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst);
	void (*extra_validate) (ComponentDef* self, Project* project, CustomComponentDef** componentChain, int componentChain_length1, ComponentInst* componentInst);
	void (*add_properties) (ComponentDef* self, PropertySet* queryProperty, PropertySet* configurationProperty);
	void (*get_properties) (ComponentDef* self, PropertySet* queryProperty, PropertySet** configurationProperty);
	void (*load_properties) (ComponentDef* self, xmlNode* xmlnode, PropertySet** configurationProperty);
	void (*save_properties) (ComponentDef* self, xmlTextWriter* xmlWriter, PropertySet* configurationProperty);
	void (*configure_inst) (ComponentDef* self, ComponentInst* componentInst, gboolean firstLoad);
	void (*compile_component) (ComponentDef* self, CompiledCircuit* compiledCircuit, ComponentInst* componentInst, Connection** connections, int connections_length1, ComponentInst** ancestry, int ancestry_length1);
	void (*create_information) (ComponentDef* self, CircuitInformation* circuitInformation);
};

typedef enum  {
	CUSTOM_COMPONENT_DEF_LOAD_ERROR_NOT_CUSTOM,
	CUSTOM_COMPONENT_DEF_LOAD_ERROR_MISSING_DEPENDENCY,
	CUSTOM_COMPONENT_DEF_LOAD_ERROR_NAME_CONFLICT,
	CUSTOM_COMPONENT_DEF_LOAD_ERROR_INVALID
} CustomComponentDefLoadError;
#define CUSTOM_COMPONENT_DEF_LOAD_ERROR custom_component_def_load_error_quark ()
typedef enum  {
	PLUGIN_COMPONENT_DEF_LOAD_ERROR_NOT_PLUGIN,
	PLUGIN_COMPONENT_DEF_LOAD_ERROR_INIT_ERROR,
	PLUGIN_COMPONENT_DEF_LOAD_ERROR_LIBRARY_NOT_ACCESSIBLE,
	PLUGIN_COMPONENT_DEF_LOAD_ERROR_LIBRARY_NOT_COMPATIBLE,
	PLUGIN_COMPONENT_DEF_LOAD_ERROR_NAME_CONFLICT,
	PLUGIN_COMPONENT_DEF_LOAD_ERROR_INVALID
} PluginComponentDefLoadError;
#define PLUGIN_COMPONENT_DEF_LOAD_ERROR plugin_component_def_load_error_quark ()
typedef enum  {
	VERSION_COMPARISON_EQUAL,
	VERSION_COMPARISON_LESS,
	VERSION_COMPARISON_GREATER
} VersionComparison;

struct _ComponentInst {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ComponentInstPrivate * priv;
	ComponentDef* componentDef;
	gint myID;
	gint xPosition;
	gint yPosition;
	Direction direction;
	gboolean flipped;
	gint rightBound;
	gint downBound;
	gint leftBound;
	gint upBound;
	PropertySet* configuration;
	gboolean selected;
	gboolean errorMark;
	PinInst** pinInsts;
	gint pinInsts_length1;
};

struct _ComponentInstClass {
	GTypeClass parent_class;
	void (*finalize) (ComponentInst *self);
};

struct _PinInst {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PinInstPrivate * priv;
	gint* x;
	gint x_length1;
	gint* y;
	gint y_length1;
	gint* xConnect;
	gint xConnect_length1;
	gint* yConnect;
	gint yConnect_length1;
	gint xLabel;
	gint yLabel;
	WireInst** wireInsts;
	gint wireInsts_length1;
	gboolean* invert;
	gint invert_length1;
	PinDef* pinDef;
	gint arraySize;
	gint xMin;
	gint xMax;
	gint yMin;
	gint yMax;
	gboolean show;
};

struct _PinInstClass {
	GTypeClass parent_class;
	void (*finalize) (PinInst *self);
};

typedef enum  {
	FLOW_NONE,
	FLOW_IN,
	FLOW_OUT,
	FLOW_BIDIRECTIONAL
} Flow;

typedef enum  {
	PIN_DEF_LABEL_TYPE_NONE,
	PIN_DEF_LABEL_TYPE_TEXT,
	PIN_DEF_LABEL_TYPE_TEXTBAR,
	PIN_DEF_LABEL_TYPE_CLOCK
} PinDefLabelType;

struct _PinDef {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PinDefPrivate * priv;
	gint x;
	gint y;
	gint xLabel;
	gint yLabel;
	gint xConnect;
	gint yConnect;
	Direction direction;
	gint length;
	gboolean array;
	Flow flow;
	gint defaultArraySize;
	gint idealSpace;
	gfloat minSpace;
	gchar* label;
	gboolean required;
	gboolean userArrayResize;
	gboolean showDefault;
	PinDefLabelType labelType;
};

struct _PinDefClass {
	GTypeClass parent_class;
	void (*finalize) (PinDef *self);
};

struct _ParamSpecComponentDef {
	GParamSpec parent_instance;
};


static gpointer component_def_parent_class = NULL;

GQuark component_def_load_error_quark (void);
gpointer component_def_ref (gpointer instance);
void component_def_unref (gpointer instance);
GParamSpec* param_spec_component_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_def (GValue* value, gpointer v_object);
void value_take_component_def (GValue* value, gpointer v_object);
gpointer value_get_component_def (const GValue* value);
GType component_def_get_type (void) G_GNUC_CONST;
GType direction_get_type (void) G_GNUC_CONST;
gpointer component_inst_ref (gpointer instance);
void component_inst_unref (gpointer instance);
GParamSpec* param_spec_component_inst (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_inst (GValue* value, gpointer v_object);
void value_take_component_inst (GValue* value, gpointer v_object);
gpointer value_get_component_inst (const GValue* value);
GType component_inst_get_type (void) G_GNUC_CONST;
gpointer project_ref (gpointer instance);
void project_unref (gpointer instance);
GParamSpec* param_spec_project (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_project (GValue* value, gpointer v_object);
void value_take_project (GValue* value, gpointer v_object);
gpointer value_get_project (const GValue* value);
GType project_get_type (void) G_GNUC_CONST;
GType custom_component_def_get_type (void) G_GNUC_CONST;
gpointer property_item_ref (gpointer instance);
void property_item_unref (gpointer instance);
GParamSpec* param_spec_property_item (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_property_item (GValue* value, gpointer v_object);
void value_take_property_item (GValue* value, gpointer v_object);
gpointer value_get_property_item (const GValue* value);
GType property_item_get_type (void) G_GNUC_CONST;
GType property_set_get_type (void) G_GNUC_CONST;
gpointer compiled_circuit_ref (gpointer instance);
void compiled_circuit_unref (gpointer instance);
GParamSpec* param_spec_compiled_circuit (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_compiled_circuit (GValue* value, gpointer v_object);
void value_take_compiled_circuit (GValue* value, gpointer v_object);
gpointer value_get_compiled_circuit (const GValue* value);
GType compiled_circuit_get_type (void) G_GNUC_CONST;
gpointer connection_ref (gpointer instance);
void connection_unref (gpointer instance);
GParamSpec* param_spec_connection (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_connection (GValue* value, gpointer v_object);
void value_take_connection (GValue* value, gpointer v_object);
gpointer value_get_connection (const GValue* value);
GType connection_get_type (void) G_GNUC_CONST;
gpointer circuit_information_ref (gpointer instance);
void circuit_information_unref (gpointer instance);
GParamSpec* param_spec_circuit_information (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_circuit_information (GValue* value, gpointer v_object);
void value_take_circuit_information (GValue* value, gpointer v_object);
gpointer value_get_circuit_information (const GValue* value);
GType circuit_information_get_type (void) G_GNUC_CONST;
gpointer graphic_ref (gpointer instance);
void graphic_unref (gpointer instance);
GParamSpec* param_spec_graphic (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_graphic (GValue* value, gpointer v_object);
void value_take_graphic (GValue* value, gpointer v_object);
gpointer value_get_graphic (const GValue* value);
GType graphic_get_type (void) G_GNUC_CONST;
gpointer pin_def_ref (gpointer instance);
void pin_def_unref (gpointer instance);
GParamSpec* param_spec_pin_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_pin_def (GValue* value, gpointer v_object);
void value_take_pin_def (GValue* value, gpointer v_object);
gpointer value_get_pin_def (const GValue* value);
GType pin_def_get_type (void) G_GNUC_CONST;
enum  {
	COMPONENT_DEF_DUMMY_PROPERTY
};
GQuark custom_component_def_load_error_quark (void);
GQuark plugin_component_def_load_error_quark (void);
void component_def_load_from_file (ComponentDef* self, const gchar* infoFilename, GError** error);
GType plugin_component_def_get_type (void) G_GNUC_CONST;
GType version_comparison_get_type (void) G_GNUC_CONST;
VersionComparison core_compare_versions (const gchar* whatVersion, const gchar* withVersion);
#define CORE_shortVersionString PACKAGE_VERSION
gboolean core_version_ignored (const gchar* extra);
Graphic* graphic_new_from_file (const gchar* filename);
Graphic* graphic_construct_from_file (GType object_type, const gchar* filename);
PinDef* pin_def_new_load (xmlNode* xmlnode);
PinDef* pin_def_construct_load (GType object_type, xmlNode* xmlnode);
static void _vala_array_add26 (PinDef*** array, int* length, int* size, PinDef* value);
static PinDef** _vala_array_dup5 (PinDef** self, int length);
void component_def_render (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst, gboolean colourBackground);
void graphic_render (Graphic* self, cairo_t* context);
void component_def_render_box (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, gboolean colourBackground, ComponentInst* componentInst);
void component_def_extra_render (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst);
gpointer pin_inst_ref (gpointer instance);
void pin_inst_unref (gpointer instance);
GParamSpec* param_spec_pin_inst (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_pin_inst (GValue* value, gpointer v_object);
void value_take_pin_inst (GValue* value, gpointer v_object);
gpointer value_get_pin_inst (const GValue* value);
GType pin_inst_get_type (void) G_GNUC_CONST;
gpointer wire_inst_ref (gpointer instance);
void wire_inst_unref (gpointer instance);
GParamSpec* param_spec_wire_inst (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_wire_inst (GValue* value, gpointer v_object);
void value_take_wire_inst (GValue* value, gpointer v_object);
gpointer value_get_wire_inst (const GValue* value);
GType wire_inst_get_type (void) G_GNUC_CONST;
GType flow_get_type (void) G_GNUC_CONST;
GType pin_def_label_type_get_type (void) G_GNUC_CONST;
static void component_def_real_extra_render (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst);
void component_def_extra_validate (ComponentDef* self, Project* project, CustomComponentDef** componentChain, int componentChain_length1, ComponentInst* componentInst);
static void component_def_real_extra_validate (ComponentDef* self, Project* project, CustomComponentDef** componentChain, int componentChain_length1, ComponentInst* componentInst);
void component_def_add_properties (ComponentDef* self, PropertySet* queryProperty, PropertySet* configurationProperty);
static void component_def_real_add_properties (ComponentDef* self, PropertySet* queryProperty, PropertySet* configurationProperty);
void component_def_get_properties (ComponentDef* self, PropertySet* queryProperty, PropertySet** configurationProperty);
static void component_def_real_get_properties (ComponentDef* self, PropertySet* queryProperty, PropertySet** configurationProperty);
PropertySet* property_set_new (const gchar* name, const gchar* description);
PropertySet* property_set_construct (GType object_type, const gchar* name, const gchar* description);
void component_def_load_properties (ComponentDef* self, xmlNode* xmlnode, PropertySet** configurationProperty);
static void component_def_real_load_properties (ComponentDef* self, xmlNode* xmlnode, PropertySet** configurationProperty);
void component_def_save_properties (ComponentDef* self, xmlTextWriter* xmlWriter, PropertySet* configurationProperty);
static void component_def_real_save_properties (ComponentDef* self, xmlTextWriter* xmlWriter, PropertySet* configurationProperty);
void component_def_configure_inst (ComponentDef* self, ComponentInst* componentInst, gboolean firstLoad);
static void component_def_real_configure_inst (ComponentDef* self, ComponentInst* componentInst, gboolean firstLoad);
void component_def_compile_component (ComponentDef* self, CompiledCircuit* compiledCircuit, ComponentInst* componentInst, Connection** connections, int connections_length1, ComponentInst** ancestry, int ancestry_length1);
static void component_def_real_compile_component (ComponentDef* self, CompiledCircuit* compiledCircuit, ComponentInst* componentInst, Connection** connections, int connections_length1, ComponentInst** ancestry, int ancestry_length1);
void component_def_create_information (ComponentDef* self, CircuitInformation* circuitInformation);
static void component_def_real_create_information (ComponentDef* self, CircuitInformation* circuitInformation);
void circuit_information_count_component (CircuitInformation* self, ComponentDef* componentDef);
ComponentDef* component_def_construct (GType object_type);
static void component_def_finalize (ComponentDef* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


GQuark component_def_load_error_quark (void) {
	return g_quark_from_static_string ("component_def_load_error-quark");
}


/**
 * Loads a component definition from a file.
 */
static gboolean bool_parse (const gchar* str) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	g_return_val_if_fail (str != NULL, FALSE);
	_tmp0_ = str;
	if (g_strcmp0 (_tmp0_, "true") == 0) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


static gpointer _pin_def_ref0 (gpointer self) {
	return self ? pin_def_ref (self) : NULL;
}


static void _vala_array_add26 (PinDef*** array, int* length, int* size, PinDef* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (PinDef*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static PinDef** _vala_array_dup5 (PinDef** self, int length) {
	PinDef** result;
	int i;
	result = g_new0 (PinDef*, length + 1);
	for (i = 0; i < length; i++) {
		PinDef* _tmp0_;
		_tmp0_ = _pin_def_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


void component_def_load_from_file (ComponentDef* self, const gchar* infoFilename, GError** error) {
	const gchar* _tmp0_;
	FILE* _tmp2_;
	const gchar* _tmp3_;
	xmlDoc* xmldoc = NULL;
	xmlNode* xmlroot = NULL;
	xmlNode* xmlnode = NULL;
	const gchar* _tmp4_;
	xmlDoc* _tmp5_ = NULL;
	xmlDoc* _tmp6_;
	xmlDoc* _tmp11_;
	xmlNode* _tmp12_ = NULL;
	xmlNode* _tmp13_;
	PinDef** _tmp63_ = NULL;
	PinDef** pinDefs;
	gint pinDefs_length1;
	gint _pinDefs_size_;
	xmlDoc* _tmp247_;
	PinDef** _tmp248_;
	gint _tmp248__length1;
	PinDef** _tmp249_;
	gint _tmp249__length1;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (infoFilename != NULL);
	_tmp0_ = infoFilename;
	if (g_strcmp0 (_tmp0_, "") == 0) {
		FILE* _tmp1_;
		_tmp1_ = stdout;
		fprintf (_tmp1_, "Defining component later\n");
		return;
	}
	_tmp2_ = stdout;
	_tmp3_ = infoFilename;
	fprintf (_tmp2_, "Loading component info \"%s\"\n", _tmp3_);
	_tmp4_ = infoFilename;
	_tmp5_ = xmlParseFile (_tmp4_);
	xmldoc = _tmp5_;
	_tmp6_ = xmldoc;
	if (_tmp6_ == NULL) {
		FILE* _tmp7_;
		const gchar* _tmp8_;
		FILE* _tmp9_;
		GError* _tmp10_;
		_tmp7_ = stdout;
		_tmp8_ = infoFilename;
		fprintf (_tmp7_, "Error loading info xml file \"%s\".\n", _tmp8_);
		_tmp9_ = stdout;
		fprintf (_tmp9_, "File inaccessible.\n");
		_tmp10_ = g_error_new_literal (COMPONENT_DEF_LOAD_ERROR, COMPONENT_DEF_LOAD_ERROR_FILE, "File inaccessible");
		_inner_error_ = _tmp10_;
		if (((_inner_error_->domain == COMPONENT_DEF_LOAD_ERROR) || (_inner_error_->domain == CUSTOM_COMPONENT_DEF_LOAD_ERROR)) || (_inner_error_->domain == PLUGIN_COMPONENT_DEF_LOAD_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp11_ = xmldoc;
	_tmp12_ = xmlDocGetRootElement (_tmp11_);
	xmlroot = _tmp12_;
	_tmp13_ = xmlroot;
	if (_tmp13_ == NULL) {
		FILE* _tmp14_;
		const gchar* _tmp15_;
		FILE* _tmp16_;
		GError* _tmp17_;
		_tmp14_ = stdout;
		_tmp15_ = infoFilename;
		fprintf (_tmp14_, "Error loading info xml file \"%s\".\n", _tmp15_);
		_tmp16_ = stdout;
		fprintf (_tmp16_, "File is empty.\n");
		_tmp17_ = g_error_new_literal (COMPONENT_DEF_LOAD_ERROR, COMPONENT_DEF_LOAD_ERROR_FILE, "File empty");
		_inner_error_ = _tmp17_;
		if (((_inner_error_->domain == COMPONENT_DEF_LOAD_ERROR) || (_inner_error_->domain == CUSTOM_COMPONENT_DEF_LOAD_ERROR)) || (_inner_error_->domain == PLUGIN_COMPONENT_DEF_LOAD_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (self, TYPE_CUSTOM_COMPONENT_DEF)) {
		xmlNode* _tmp18_;
		const gchar* _tmp19_;
		_tmp18_ = xmlroot;
		_tmp19_ = _tmp18_->name;
		if (g_strcmp0 (_tmp19_, "custom_component") != 0) {
			FILE* _tmp20_;
			const gchar* _tmp21_;
			FILE* _tmp22_;
			xmlNode* _tmp23_;
			const gchar* _tmp24_;
			xmlNode* _tmp25_;
			const gchar* _tmp26_;
			gchar* _tmp27_;
			gchar* _tmp28_;
			gchar* _tmp29_;
			gchar* _tmp30_;
			GError* _tmp31_;
			GError* _tmp32_;
			_tmp20_ = stdout;
			_tmp21_ = infoFilename;
			fprintf (_tmp20_, "Error loading info xml file \"%s\".\n", _tmp21_);
			_tmp22_ = stdout;
			_tmp23_ = xmlroot;
			_tmp24_ = _tmp23_->name;
			fprintf (_tmp22_, "Wanted \"custom_component\" info, but got \"%s\"\n", _tmp24_);
			_tmp25_ = xmlroot;
			_tmp26_ = _tmp25_->name;
			_tmp27_ = g_strconcat ("Wanted \"custom_component\" info, but got \"", _tmp26_, NULL);
			_tmp28_ = _tmp27_;
			_tmp29_ = g_strconcat (_tmp28_, "\"", NULL);
			_tmp30_ = _tmp29_;
			_tmp31_ = g_error_new_literal (CUSTOM_COMPONENT_DEF_LOAD_ERROR, CUSTOM_COMPONENT_DEF_LOAD_ERROR_NOT_CUSTOM, _tmp30_);
			_tmp32_ = _tmp31_;
			_g_free0 (_tmp30_);
			_g_free0 (_tmp28_);
			_inner_error_ = _tmp32_;
			if (((_inner_error_->domain == COMPONENT_DEF_LOAD_ERROR) || (_inner_error_->domain == CUSTOM_COMPONENT_DEF_LOAD_ERROR)) || (_inner_error_->domain == PLUGIN_COMPONENT_DEF_LOAD_ERROR)) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	} else {
		if (G_TYPE_CHECK_INSTANCE_TYPE (self, TYPE_PLUGIN_COMPONENT_DEF)) {
			xmlNode* _tmp33_;
			const gchar* _tmp34_;
			_tmp33_ = xmlroot;
			_tmp34_ = _tmp33_->name;
			if (g_strcmp0 (_tmp34_, "plugin_component") != 0) {
				FILE* _tmp35_;
				const gchar* _tmp36_;
				FILE* _tmp37_;
				xmlNode* _tmp38_;
				const gchar* _tmp39_;
				xmlNode* _tmp40_;
				const gchar* _tmp41_;
				gchar* _tmp42_;
				gchar* _tmp43_;
				gchar* _tmp44_;
				gchar* _tmp45_;
				GError* _tmp46_;
				GError* _tmp47_;
				_tmp35_ = stdout;
				_tmp36_ = infoFilename;
				fprintf (_tmp35_, "Error loading info xml file \"%s\".\n", _tmp36_);
				_tmp37_ = stdout;
				_tmp38_ = xmlroot;
				_tmp39_ = _tmp38_->name;
				fprintf (_tmp37_, "Wanted \"plugin_component\" info, but got \"%s\"\n", _tmp39_);
				_tmp40_ = xmlroot;
				_tmp41_ = _tmp40_->name;
				_tmp42_ = g_strconcat ("Wanted \"plugin_component\" info, but got \"", _tmp41_, NULL);
				_tmp43_ = _tmp42_;
				_tmp44_ = g_strconcat (_tmp43_, "\"", NULL);
				_tmp45_ = _tmp44_;
				_tmp46_ = g_error_new_literal (PLUGIN_COMPONENT_DEF_LOAD_ERROR, PLUGIN_COMPONENT_DEF_LOAD_ERROR_NOT_PLUGIN, _tmp45_);
				_tmp47_ = _tmp46_;
				_g_free0 (_tmp45_);
				_g_free0 (_tmp43_);
				_inner_error_ = _tmp47_;
				if (((_inner_error_->domain == COMPONENT_DEF_LOAD_ERROR) || (_inner_error_->domain == CUSTOM_COMPONENT_DEF_LOAD_ERROR)) || (_inner_error_->domain == PLUGIN_COMPONENT_DEF_LOAD_ERROR)) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		} else {
			xmlNode* _tmp48_;
			const gchar* _tmp49_;
			_tmp48_ = xmlroot;
			_tmp49_ = _tmp48_->name;
			if (g_strcmp0 (_tmp49_, "component") != 0) {
				FILE* _tmp50_;
				const gchar* _tmp51_;
				FILE* _tmp52_;
				xmlNode* _tmp53_;
				const gchar* _tmp54_;
				xmlNode* _tmp55_;
				const gchar* _tmp56_;
				gchar* _tmp57_;
				gchar* _tmp58_;
				gchar* _tmp59_;
				gchar* _tmp60_;
				GError* _tmp61_;
				GError* _tmp62_;
				_tmp50_ = stdout;
				_tmp51_ = infoFilename;
				fprintf (_tmp50_, "Error loading info xml file \"%s\".\n", _tmp51_);
				_tmp52_ = stdout;
				_tmp53_ = xmlroot;
				_tmp54_ = _tmp53_->name;
				fprintf (_tmp52_, "Wanted \"component\" info, but got \"%s\"\n", _tmp54_);
				_tmp55_ = xmlroot;
				_tmp56_ = _tmp55_->name;
				_tmp57_ = g_strconcat ("Wanted \"component\" info, but got \"", _tmp56_, NULL);
				_tmp58_ = _tmp57_;
				_tmp59_ = g_strconcat (_tmp58_, "\"", NULL);
				_tmp60_ = _tmp59_;
				_tmp61_ = g_error_new_literal (COMPONENT_DEF_LOAD_ERROR, COMPONENT_DEF_LOAD_ERROR_NOT_COMPONENT, _tmp60_);
				_tmp62_ = _tmp61_;
				_g_free0 (_tmp60_);
				_g_free0 (_tmp58_);
				_inner_error_ = _tmp62_;
				if (((_inner_error_->domain == COMPONENT_DEF_LOAD_ERROR) || (_inner_error_->domain == CUSTOM_COMPONENT_DEF_LOAD_ERROR)) || (_inner_error_->domain == PLUGIN_COMPONENT_DEF_LOAD_ERROR)) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
	_tmp63_ = g_new0 (PinDef*, 0 + 1);
	pinDefs = _tmp63_;
	pinDefs_length1 = 0;
	_pinDefs_size_ = pinDefs_length1;
	{
		xmlNode* _tmp64_;
		xmlNode* _tmp65_;
		gboolean _tmp66_;
		_tmp64_ = xmlroot;
		_tmp65_ = _tmp64_->children;
		xmlnode = _tmp65_;
		_tmp66_ = TRUE;
		while (TRUE) {
			gboolean _tmp67_;
			xmlNode* _tmp70_;
			xmlNode* _tmp71_;
			xmlElementType _tmp72_;
			xmlNode* _tmp73_;
			const gchar* _tmp74_;
			const gchar* _tmp75_;
			GQuark _tmp77_ = 0U;
			static GQuark _tmp76_label0 = 0;
			static GQuark _tmp76_label1 = 0;
			static GQuark _tmp76_label2 = 0;
			static GQuark _tmp76_label3 = 0;
			static GQuark _tmp76_label4 = 0;
			static GQuark _tmp76_label5 = 0;
			static GQuark _tmp76_label6 = 0;
			static GQuark _tmp76_label7 = 0;
			static GQuark _tmp76_label8 = 0;
			static GQuark _tmp76_label9 = 0;
			_tmp67_ = _tmp66_;
			if (!_tmp67_) {
				xmlNode* _tmp68_;
				xmlNode* _tmp69_;
				_tmp68_ = xmlnode;
				_tmp69_ = _tmp68_->next;
				xmlnode = _tmp69_;
			}
			_tmp66_ = FALSE;
			_tmp70_ = xmlnode;
			if (!(_tmp70_ != NULL)) {
				break;
			}
			_tmp71_ = xmlnode;
			_tmp72_ = _tmp71_->type;
			if (_tmp72_ != XML_ELEMENT_NODE) {
				continue;
			}
			_tmp73_ = xmlnode;
			_tmp74_ = _tmp73_->name;
			_tmp75_ = _tmp74_;
			_tmp77_ = (NULL == _tmp75_) ? 0 : g_quark_from_string (_tmp75_);
			if (_tmp77_ == ((0 != _tmp76_label0) ? _tmp76_label0 : (_tmp76_label0 = g_quark_from_static_string ("metadata")))) {
				switch (0) {
					default:
					{
						{
							{
								xmlNode* _tmp78_;
								xmlNode* _tmp79_;
								xmlNode* xmldata;
								_tmp78_ = xmlnode;
								_tmp79_ = _tmp78_->children;
								xmldata = _tmp79_;
								{
									gboolean _tmp80_;
									_tmp80_ = TRUE;
									while (TRUE) {
										gboolean _tmp81_;
										xmlNode* _tmp84_;
										xmlNode* _tmp85_;
										xmlElementType _tmp86_;
										xmlNode* _tmp87_;
										const gchar* _tmp88_;
										const gchar* _tmp89_;
										GQuark _tmp91_ = 0U;
										static GQuark _tmp90_label0 = 0;
										_tmp81_ = _tmp80_;
										if (!_tmp81_) {
											xmlNode* _tmp82_;
											xmlNode* _tmp83_;
											_tmp82_ = xmldata;
											_tmp83_ = _tmp82_->next;
											xmldata = _tmp83_;
										}
										_tmp80_ = FALSE;
										_tmp84_ = xmldata;
										if (!(_tmp84_ != NULL)) {
											break;
										}
										_tmp85_ = xmldata;
										_tmp86_ = _tmp85_->type;
										if (_tmp86_ != XML_ELEMENT_NODE) {
											continue;
										}
										_tmp87_ = xmldata;
										_tmp88_ = _tmp87_->name;
										_tmp89_ = _tmp88_;
										_tmp91_ = (NULL == _tmp89_) ? 0 : g_quark_from_string (_tmp89_);
										if (_tmp91_ == ((0 != _tmp90_label0) ? _tmp90_label0 : (_tmp90_label0 = g_quark_from_static_string ("version")))) {
											switch (0) {
												default:
												{
													{
														{
															xmlNode* _tmp92_;
															xmlAttr* _tmp93_;
															xmlAttr* xmlattr;
															_tmp92_ = xmldata;
															_tmp93_ = _tmp92_->properties;
															xmlattr = _tmp93_;
															{
																gboolean _tmp94_;
																_tmp94_ = TRUE;
																while (TRUE) {
																	gboolean _tmp95_;
																	xmlAttr* _tmp98_;
																	xmlAttr* _tmp99_;
																	const gchar* _tmp100_;
																	const gchar* _tmp101_;
																	GQuark _tmp103_ = 0U;
																	static GQuark _tmp102_label0 = 0;
																	_tmp95_ = _tmp94_;
																	if (!_tmp95_) {
																		xmlAttr* _tmp96_;
																		xmlAttr* _tmp97_;
																		_tmp96_ = xmlattr;
																		_tmp97_ = _tmp96_->next;
																		xmlattr = _tmp97_;
																	}
																	_tmp94_ = FALSE;
																	_tmp98_ = xmlattr;
																	if (!(_tmp98_ != NULL)) {
																		break;
																	}
																	_tmp99_ = xmlattr;
																	_tmp100_ = _tmp99_->name;
																	_tmp101_ = _tmp100_;
																	_tmp103_ = (NULL == _tmp101_) ? 0 : g_quark_from_string (_tmp101_);
																	if (_tmp103_ == ((0 != _tmp102_label0) ? _tmp102_label0 : (_tmp102_label0 = g_quark_from_static_string ("smartsim")))) {
																		switch (0) {
																			default:
																			{
																				xmlAttr* _tmp104_;
																				xmlNode* _tmp105_;
																				const gchar* _tmp106_;
																				VersionComparison _tmp107_ = 0;
																				_tmp104_ = xmlattr;
																				_tmp105_ = _tmp104_->children;
																				_tmp106_ = _tmp105_->content;
																				_tmp107_ = core_compare_versions (_tmp106_, CORE_shortVersionString);
																				if (_tmp107_ == VERSION_COMPARISON_GREATER) {
																					const gchar* _tmp108_;
																					gchar* _tmp109_;
																					gchar* _tmp110_;
																					gchar* _tmp111_;
																					gchar* _tmp112_;
																					gboolean _tmp113_ = FALSE;
																					gboolean _tmp114_;
																					_tmp108_ = infoFilename;
																					_tmp109_ = g_strconcat ("Component File: \"", _tmp108_, NULL);
																					_tmp110_ = _tmp109_;
																					_tmp111_ = g_strconcat (_tmp110_, "\"", NULL);
																					_tmp112_ = _tmp111_;
																					_tmp113_ = core_version_ignored (_tmp112_);
																					_tmp114_ = _tmp113_ == FALSE;
																					_g_free0 (_tmp112_);
																					_g_free0 (_tmp110_);
																					if (_tmp114_) {
																						GError* _tmp115_;
																						_tmp115_ = g_error_new_literal (COMPONENT_DEF_LOAD_ERROR, COMPONENT_DEF_LOAD_ERROR_CANCEL, "SmartSim version of component is higher than running version.");
																						_inner_error_ = _tmp115_;
																						if (((_inner_error_->domain == COMPONENT_DEF_LOAD_ERROR) || (_inner_error_->domain == CUSTOM_COMPONENT_DEF_LOAD_ERROR)) || (_inner_error_->domain == PLUGIN_COMPONENT_DEF_LOAD_ERROR)) {
																							g_propagate_error (error, _inner_error_);
																							pinDefs = (_vala_array_free (pinDefs, pinDefs_length1, (GDestroyNotify) pin_def_unref), NULL);
																							return;
																						} else {
																							pinDefs = (_vala_array_free (pinDefs, pinDefs_length1, (GDestroyNotify) pin_def_unref), NULL);
																							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
																							g_clear_error (&_inner_error_);
																							return;
																						}
																					}
																				}
																				break;
																			}
																		}
																	}
																}
															}
														}
													}
													break;
												}
											}
										}
									}
								}
							}
						}
						break;
					}
				}
			} else if (_tmp77_ == ((0 != _tmp76_label1) ? _tmp76_label1 : (_tmp76_label1 = g_quark_from_static_string ("name")))) {
				switch (0) {
					default:
					{
						{
							{
								xmlNode* _tmp116_;
								xmlNode* _tmp117_;
								xmlNode* xmldata;
								_tmp116_ = xmlnode;
								_tmp117_ = _tmp116_->children;
								xmldata = _tmp117_;
								{
									gboolean _tmp118_;
									_tmp118_ = TRUE;
									while (TRUE) {
										gboolean _tmp119_;
										xmlNode* _tmp122_;
										xmlNode* _tmp123_;
										xmlElementType _tmp124_;
										xmlNode* _tmp125_;
										const gchar* _tmp126_;
										gchar* _tmp127_;
										_tmp119_ = _tmp118_;
										if (!_tmp119_) {
											xmlNode* _tmp120_;
											xmlNode* _tmp121_;
											_tmp120_ = xmldata;
											_tmp121_ = _tmp120_->next;
											xmldata = _tmp121_;
										}
										_tmp118_ = FALSE;
										_tmp122_ = xmldata;
										if (!(_tmp122_ != NULL)) {
											break;
										}
										_tmp123_ = xmlnode;
										_tmp124_ = _tmp123_->type;
										if (_tmp124_ != XML_ELEMENT_NODE) {
											continue;
										}
										_tmp125_ = xmldata;
										_tmp126_ = _tmp125_->content;
										_tmp127_ = g_strdup (_tmp126_);
										_g_free0 (self->name);
										self->name = _tmp127_;
									}
								}
							}
						}
						break;
					}
				}
			} else if (_tmp77_ == ((0 != _tmp76_label2) ? _tmp76_label2 : (_tmp76_label2 = g_quark_from_static_string ("description")))) {
				switch (0) {
					default:
					{
						{
							{
								xmlNode* _tmp128_;
								xmlNode* _tmp129_;
								xmlNode* xmldata;
								_tmp128_ = xmlnode;
								_tmp129_ = _tmp128_->children;
								xmldata = _tmp129_;
								{
									gboolean _tmp130_;
									_tmp130_ = TRUE;
									while (TRUE) {
										gboolean _tmp131_;
										xmlNode* _tmp134_;
										xmlNode* _tmp135_;
										xmlElementType _tmp136_;
										xmlNode* _tmp137_;
										const gchar* _tmp138_;
										gchar* _tmp139_;
										_tmp131_ = _tmp130_;
										if (!_tmp131_) {
											xmlNode* _tmp132_;
											xmlNode* _tmp133_;
											_tmp132_ = xmldata;
											_tmp133_ = _tmp132_->next;
											xmldata = _tmp133_;
										}
										_tmp130_ = FALSE;
										_tmp134_ = xmldata;
										if (!(_tmp134_ != NULL)) {
											break;
										}
										_tmp135_ = xmlnode;
										_tmp136_ = _tmp135_->type;
										if (_tmp136_ != XML_ELEMENT_NODE) {
											continue;
										}
										_tmp137_ = xmldata;
										_tmp138_ = _tmp137_->content;
										_tmp139_ = g_strdup (_tmp138_);
										_g_free0 (self->description);
										self->description = _tmp139_;
									}
								}
							}
						}
						break;
					}
				}
			} else if (_tmp77_ == ((0 != _tmp76_label3) ? _tmp76_label3 : (_tmp76_label3 = g_quark_from_static_string ("icon")))) {
				switch (0) {
					default:
					{
						{
							{
								xmlNode* _tmp140_;
								xmlNode* _tmp141_;
								xmlNode* xmldata;
								_tmp140_ = xmlnode;
								_tmp141_ = _tmp140_->children;
								xmldata = _tmp141_;
								{
									gboolean _tmp142_;
									_tmp142_ = TRUE;
									while (TRUE) {
										gboolean _tmp143_;
										xmlNode* _tmp146_;
										xmlNode* _tmp147_;
										xmlElementType _tmp148_;
										xmlNode* _tmp149_;
										const gchar* _tmp150_;
										gchar* _tmp151_;
										_tmp143_ = _tmp142_;
										if (!_tmp143_) {
											xmlNode* _tmp144_;
											xmlNode* _tmp145_;
											_tmp144_ = xmldata;
											_tmp145_ = _tmp144_->next;
											xmldata = _tmp145_;
										}
										_tmp142_ = FALSE;
										_tmp146_ = xmldata;
										if (!(_tmp146_ != NULL)) {
											break;
										}
										_tmp147_ = xmlnode;
										_tmp148_ = _tmp147_->type;
										if (_tmp148_ != XML_ELEMENT_NODE) {
											continue;
										}
										_tmp149_ = xmldata;
										_tmp150_ = _tmp149_->content;
										_tmp151_ = g_strdup (_tmp150_);
										_g_free0 (self->iconFilename);
										self->iconFilename = _tmp151_;
									}
								}
							}
						}
						break;
					}
				}
			} else if (_tmp77_ == ((0 != _tmp76_label4) ? _tmp76_label4 : (_tmp76_label4 = g_quark_from_static_string ("graphic")))) {
				switch (0) {
					default:
					{
						{
							{
								xmlNode* _tmp152_;
								xmlNode* _tmp153_;
								xmlNode* xmldata;
								_tmp152_ = xmlnode;
								_tmp153_ = _tmp152_->children;
								xmldata = _tmp153_;
								{
									gboolean _tmp154_;
									_tmp154_ = TRUE;
									while (TRUE) {
										gboolean _tmp155_;
										xmlNode* _tmp158_;
										xmlNode* _tmp159_;
										xmlElementType _tmp160_;
										xmlNode* _tmp161_;
										const gchar* _tmp162_;
										gchar* _tmp163_;
										gchar* _tmp164_;
										Graphic* _tmp165_;
										_tmp155_ = _tmp154_;
										if (!_tmp155_) {
											xmlNode* _tmp156_;
											xmlNode* _tmp157_;
											_tmp156_ = xmldata;
											_tmp157_ = _tmp156_->next;
											xmldata = _tmp157_;
										}
										_tmp154_ = FALSE;
										_tmp158_ = xmldata;
										if (!(_tmp158_ != NULL)) {
											break;
										}
										_tmp159_ = xmlnode;
										_tmp160_ = _tmp159_->type;
										if (_tmp160_ != XML_ELEMENT_NODE) {
											continue;
										}
										_tmp161_ = xmldata;
										_tmp162_ = _tmp161_->content;
										_tmp163_ = g_strconcat (PACKAGE_DATADIR "components/graphics/", _tmp162_, NULL);
										_tmp164_ = _tmp163_;
										_tmp165_ = graphic_new_from_file (_tmp164_);
										_graphic_unref0 (self->graphic);
										self->graphic = _tmp165_;
										_g_free0 (_tmp164_);
									}
								}
							}
						}
						break;
					}
				}
			} else if (_tmp77_ == ((0 != _tmp76_label5) ? _tmp76_label5 : (_tmp76_label5 = g_quark_from_static_string ("label")))) {
				switch (0) {
					default:
					{
						{
							{
								xmlNode* _tmp166_;
								xmlNode* _tmp167_;
								xmlNode* xmldata;
								_tmp166_ = xmlnode;
								_tmp167_ = _tmp166_->children;
								xmldata = _tmp167_;
								{
									gboolean _tmp168_;
									_tmp168_ = TRUE;
									while (TRUE) {
										gboolean _tmp169_;
										xmlNode* _tmp172_;
										xmlNode* _tmp173_;
										xmlElementType _tmp174_;
										xmlNode* _tmp175_;
										const gchar* _tmp176_;
										gchar* _tmp177_;
										_tmp169_ = _tmp168_;
										if (!_tmp169_) {
											xmlNode* _tmp170_;
											xmlNode* _tmp171_;
											_tmp170_ = xmldata;
											_tmp171_ = _tmp170_->next;
											xmldata = _tmp171_;
										}
										_tmp168_ = FALSE;
										_tmp172_ = xmldata;
										if (!(_tmp172_ != NULL)) {
											break;
										}
										_tmp173_ = xmlnode;
										_tmp174_ = _tmp173_->type;
										if (_tmp174_ != XML_ELEMENT_NODE) {
											continue;
										}
										_tmp175_ = xmldata;
										_tmp176_ = _tmp175_->content;
										_tmp177_ = g_strdup (_tmp176_);
										_g_free0 (self->label);
										self->label = _tmp177_;
									}
								}
							}
						}
						break;
					}
				}
			} else if (_tmp77_ == ((0 != _tmp76_label6) ? _tmp76_label6 : (_tmp76_label6 = g_quark_from_static_string ("bound")))) {
				switch (0) {
					default:
					{
						{
							{
								xmlNode* _tmp178_;
								xmlAttr* _tmp179_;
								xmlAttr* xmlattr;
								_tmp178_ = xmlnode;
								_tmp179_ = _tmp178_->properties;
								xmlattr = _tmp179_;
								{
									gboolean _tmp180_;
									_tmp180_ = TRUE;
									while (TRUE) {
										gboolean _tmp181_;
										xmlAttr* _tmp184_;
										xmlAttr* _tmp185_;
										const gchar* _tmp186_;
										const gchar* _tmp187_;
										GQuark _tmp189_ = 0U;
										static GQuark _tmp188_label0 = 0;
										static GQuark _tmp188_label1 = 0;
										static GQuark _tmp188_label2 = 0;
										static GQuark _tmp188_label3 = 0;
										static GQuark _tmp188_label4 = 0;
										_tmp181_ = _tmp180_;
										if (!_tmp181_) {
											xmlAttr* _tmp182_;
											xmlAttr* _tmp183_;
											_tmp182_ = xmlattr;
											_tmp183_ = _tmp182_->next;
											xmlattr = _tmp183_;
										}
										_tmp180_ = FALSE;
										_tmp184_ = xmlattr;
										if (!(_tmp184_ != NULL)) {
											break;
										}
										_tmp185_ = xmlattr;
										_tmp186_ = _tmp185_->name;
										_tmp187_ = _tmp186_;
										_tmp189_ = (NULL == _tmp187_) ? 0 : g_quark_from_string (_tmp187_);
										if (_tmp189_ == ((0 != _tmp188_label0) ? _tmp188_label0 : (_tmp188_label0 = g_quark_from_static_string ("right")))) {
											switch (0) {
												default:
												{
													xmlAttr* _tmp190_;
													xmlNode* _tmp191_;
													const gchar* _tmp192_;
													gint _tmp193_ = 0;
													_tmp190_ = xmlattr;
													_tmp191_ = _tmp190_->children;
													_tmp192_ = _tmp191_->content;
													_tmp193_ = atoi (_tmp192_);
													self->rightBound = _tmp193_;
													break;
												}
											}
										} else if (_tmp189_ == ((0 != _tmp188_label1) ? _tmp188_label1 : (_tmp188_label1 = g_quark_from_static_string ("down")))) {
											switch (0) {
												default:
												{
													xmlAttr* _tmp194_;
													xmlNode* _tmp195_;
													const gchar* _tmp196_;
													gint _tmp197_ = 0;
													_tmp194_ = xmlattr;
													_tmp195_ = _tmp194_->children;
													_tmp196_ = _tmp195_->content;
													_tmp197_ = atoi (_tmp196_);
													self->downBound = _tmp197_;
													break;
												}
											}
										} else if (_tmp189_ == ((0 != _tmp188_label2) ? _tmp188_label2 : (_tmp188_label2 = g_quark_from_static_string ("left")))) {
											switch (0) {
												default:
												{
													xmlAttr* _tmp198_;
													xmlNode* _tmp199_;
													const gchar* _tmp200_;
													gint _tmp201_ = 0;
													_tmp198_ = xmlattr;
													_tmp199_ = _tmp198_->children;
													_tmp200_ = _tmp199_->content;
													_tmp201_ = atoi (_tmp200_);
													self->leftBound = _tmp201_;
													break;
												}
											}
										} else if (_tmp189_ == ((0 != _tmp188_label3) ? _tmp188_label3 : (_tmp188_label3 = g_quark_from_static_string ("up")))) {
											switch (0) {
												default:
												{
													xmlAttr* _tmp202_;
													xmlNode* _tmp203_;
													const gchar* _tmp204_;
													gint _tmp205_ = 0;
													_tmp202_ = xmlattr;
													_tmp203_ = _tmp202_->children;
													_tmp204_ = _tmp203_->content;
													_tmp205_ = atoi (_tmp204_);
													self->upBound = _tmp205_;
													break;
												}
											}
										} else if (_tmp189_ == ((0 != _tmp188_label4) ? _tmp188_label4 : (_tmp188_label4 = g_quark_from_static_string ("drawbox")))) {
											switch (0) {
												default:
												{
													xmlAttr* _tmp206_;
													xmlNode* _tmp207_;
													const gchar* _tmp208_;
													gboolean _tmp209_ = FALSE;
													_tmp206_ = xmlattr;
													_tmp207_ = _tmp206_->children;
													_tmp208_ = _tmp207_->content;
													_tmp209_ = bool_parse (_tmp208_);
													self->drawBox = _tmp209_;
													break;
												}
											}
										}
									}
								}
							}
						}
						break;
					}
				}
			} else if ((_tmp77_ == ((0 != _tmp76_label7) ? _tmp76_label7 : (_tmp76_label7 = g_quark_from_static_string ("color")))) || (_tmp77_ == ((0 != _tmp76_label8) ? _tmp76_label8 : (_tmp76_label8 = g_quark_from_static_string ("colour"))))) {
				switch (0) {
					default:
					{
						{
							{
								xmlNode* _tmp210_;
								xmlAttr* _tmp211_;
								xmlAttr* xmlattr;
								_tmp210_ = xmlnode;
								_tmp211_ = _tmp210_->properties;
								xmlattr = _tmp211_;
								{
									gboolean _tmp212_;
									_tmp212_ = TRUE;
									while (TRUE) {
										gboolean _tmp213_;
										xmlAttr* _tmp216_;
										xmlAttr* _tmp217_;
										const gchar* _tmp218_;
										const gchar* _tmp219_;
										GQuark _tmp221_ = 0U;
										static GQuark _tmp220_label0 = 0;
										static GQuark _tmp220_label1 = 0;
										static GQuark _tmp220_label2 = 0;
										static GQuark _tmp220_label3 = 0;
										_tmp213_ = _tmp212_;
										if (!_tmp213_) {
											xmlAttr* _tmp214_;
											xmlAttr* _tmp215_;
											_tmp214_ = xmlattr;
											_tmp215_ = _tmp214_->next;
											xmlattr = _tmp215_;
										}
										_tmp212_ = FALSE;
										_tmp216_ = xmlattr;
										if (!(_tmp216_ != NULL)) {
											break;
										}
										_tmp217_ = xmlattr;
										_tmp218_ = _tmp217_->name;
										_tmp219_ = _tmp218_;
										_tmp221_ = (NULL == _tmp219_) ? 0 : g_quark_from_string (_tmp219_);
										if (_tmp221_ == ((0 != _tmp220_label0) ? _tmp220_label0 : (_tmp220_label0 = g_quark_from_static_string ("a")))) {
											switch (0) {
												default:
												{
													xmlAttr* _tmp222_;
													xmlNode* _tmp223_;
													const gchar* _tmp224_;
													gint _tmp225_ = 0;
													gint _tmp226_;
													_tmp222_ = xmlattr;
													_tmp223_ = _tmp222_->children;
													_tmp224_ = _tmp223_->content;
													_tmp225_ = atoi (_tmp224_);
													self->backgroundAlpha = _tmp225_;
													_tmp226_ = self->backgroundAlpha;
													self->backgroundAlphaF = ((gdouble) _tmp226_) / 255.0;
													break;
												}
											}
										} else if (_tmp221_ == ((0 != _tmp220_label1) ? _tmp220_label1 : (_tmp220_label1 = g_quark_from_static_string ("r")))) {
											switch (0) {
												default:
												{
													xmlAttr* _tmp227_;
													xmlNode* _tmp228_;
													const gchar* _tmp229_;
													gint _tmp230_ = 0;
													gint _tmp231_;
													_tmp227_ = xmlattr;
													_tmp228_ = _tmp227_->children;
													_tmp229_ = _tmp228_->content;
													_tmp230_ = atoi (_tmp229_);
													self->backgroundRed = _tmp230_;
													_tmp231_ = self->backgroundRed;
													self->backgroundRedF = ((gdouble) _tmp231_) / 255.0;
													break;
												}
											}
										} else if (_tmp221_ == ((0 != _tmp220_label2) ? _tmp220_label2 : (_tmp220_label2 = g_quark_from_static_string ("g")))) {
											switch (0) {
												default:
												{
													xmlAttr* _tmp232_;
													xmlNode* _tmp233_;
													const gchar* _tmp234_;
													gint _tmp235_ = 0;
													gint _tmp236_;
													_tmp232_ = xmlattr;
													_tmp233_ = _tmp232_->children;
													_tmp234_ = _tmp233_->content;
													_tmp235_ = atoi (_tmp234_);
													self->backgroundGreen = _tmp235_;
													_tmp236_ = self->backgroundGreen;
													self->backgroundGreenF = ((gdouble) _tmp236_) / 255.0;
													break;
												}
											}
										} else if (_tmp221_ == ((0 != _tmp220_label3) ? _tmp220_label3 : (_tmp220_label3 = g_quark_from_static_string ("b")))) {
											switch (0) {
												default:
												{
													xmlAttr* _tmp237_;
													xmlNode* _tmp238_;
													const gchar* _tmp239_;
													gint _tmp240_ = 0;
													gint _tmp241_;
													_tmp237_ = xmlattr;
													_tmp238_ = _tmp237_->children;
													_tmp239_ = _tmp238_->content;
													_tmp240_ = atoi (_tmp239_);
													self->backgroundBlue = _tmp240_;
													_tmp241_ = self->backgroundBlue;
													self->backgroundBlueF = ((gdouble) _tmp241_) / 255.0;
													break;
												}
											}
										}
									}
								}
							}
						}
						break;
					}
				}
			} else if (_tmp77_ == ((0 != _tmp76_label9) ? _tmp76_label9 : (_tmp76_label9 = g_quark_from_static_string ("pin")))) {
				switch (0) {
					default:
					{
						{
							xmlNode* _tmp242_;
							PinDef* _tmp243_;
							PinDef* pinDef;
							PinDef** _tmp244_;
							gint _tmp244__length1;
							PinDef* _tmp245_;
							PinDef* _tmp246_;
							_tmp242_ = xmlnode;
							_tmp243_ = pin_def_new_load (_tmp242_);
							pinDef = _tmp243_;
							_tmp244_ = pinDefs;
							_tmp244__length1 = pinDefs_length1;
							_tmp245_ = pinDef;
							_tmp246_ = _pin_def_ref0 (_tmp245_);
							_vala_array_add26 (&pinDefs, &pinDefs_length1, &_pinDefs_size_, _tmp246_);
							_pin_def_unref0 (pinDef);
						}
						break;
					}
				}
			}
		}
	}
	_tmp247_ = xmldoc;
	xmlFreeDoc (_tmp247_);
	_tmp248_ = pinDefs;
	_tmp248__length1 = pinDefs_length1;
	_tmp249_ = (_tmp248_ != NULL) ? _vala_array_dup5 (_tmp248_, _tmp248__length1) : ((gpointer) _tmp248_);
	_tmp249__length1 = _tmp248__length1;
	self->pinDefs = (_vala_array_free (self->pinDefs, self->pinDefs_length1, (GDestroyNotify) pin_def_unref), NULL);
	self->pinDefs = _tmp249_;
	self->pinDefs_length1 = _tmp249__length1;
	pinDefs = (_vala_array_free (pinDefs, pinDefs_length1, (GDestroyNotify) pin_def_unref), NULL);
	return;
}


/**
 * Render the component's image, excluding pins. Either renders the
 * graphic or box diagram.
 */
void component_def_render (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst, gboolean colourBackground) {
	Graphic* _tmp0_;
	cairo_t* _tmp17_;
	Direction _tmp18_;
	gboolean _tmp19_;
	ComponentInst* _tmp20_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = self->graphic;
	if (_tmp0_ != NULL) {
		cairo_matrix_t oldmatrix = {0};
		cairo_t* _tmp1_;
		cairo_matrix_t _tmp2_ = {0};
		gdouble angle;
		Direction _tmp3_;
		cairo_t* _tmp4_;
		gdouble _tmp5_;
		gboolean _tmp6_;
		Graphic* _tmp8_;
		cairo_t* _tmp9_;
		cairo_t* _tmp10_;
		cairo_matrix_t _tmp11_;
		_tmp1_ = context;
		cairo_get_matrix (_tmp1_, &_tmp2_);
		oldmatrix = _tmp2_;
		angle = (gdouble) 0;
		_tmp3_ = direction;
		switch (_tmp3_) {
			case DIRECTION_RIGHT:
			{
				angle = (gdouble) 0;
				break;
			}
			case DIRECTION_DOWN:
			{
				angle = G_PI * 0.5;
				break;
			}
			case DIRECTION_LEFT:
			{
				angle = G_PI;
				break;
			}
			case DIRECTION_UP:
			{
				angle = G_PI * 1.5;
				break;
			}
			default:
			break;
		}
		_tmp4_ = context;
		_tmp5_ = angle;
		cairo_rotate (_tmp4_, _tmp5_);
		_tmp6_ = flipped;
		if (_tmp6_) {
			cairo_t* _tmp7_;
			_tmp7_ = context;
			cairo_scale (_tmp7_, 1.0, -1.0);
		}
		_tmp8_ = self->graphic;
		_tmp9_ = context;
		graphic_render (_tmp8_, _tmp9_);
		_tmp10_ = context;
		_tmp11_ = oldmatrix;
		cairo_set_matrix (_tmp10_, &_tmp11_);
	} else {
		cairo_t* _tmp12_;
		Direction _tmp13_;
		gboolean _tmp14_;
		gboolean _tmp15_;
		ComponentInst* _tmp16_;
		_tmp12_ = context;
		_tmp13_ = direction;
		_tmp14_ = flipped;
		_tmp15_ = colourBackground;
		_tmp16_ = componentInst;
		component_def_render_box (self, _tmp12_, _tmp13_, _tmp14_, _tmp15_, _tmp16_);
	}
	_tmp17_ = context;
	_tmp18_ = direction;
	_tmp19_ = flipped;
	_tmp20_ = componentInst;
	component_def_extra_render (self, _tmp17_, _tmp18_, _tmp19_, _tmp20_);
}


/**
 * Renders the box diagram. Used when there is no graphic.
 */
void component_def_render_box (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, gboolean colourBackground, ComponentInst* componentInst) {
	cairo_matrix_t oldmatrix = {0};
	cairo_matrix_t oldmatrix2 = {0};
	cairo_text_extents_t textExtents = {0};
	gint rightBound = 0;
	gint downBound = 0;
	gint leftBound = 0;
	gint upBound = 0;
	ComponentInst* _tmp0_;
	cairo_t* _tmp13_;
	cairo_matrix_t _tmp14_ = {0};
	cairo_t* _tmp15_;
	gdouble angle;
	Direction _tmp16_;
	cairo_t* _tmp17_;
	gdouble _tmp18_;
	gboolean _tmp19_;
	cairo_t* _tmp21_;
	gboolean _tmp22_;
	cairo_t* _tmp67_;
	cairo_matrix_t _tmp68_ = {0};
	cairo_t* _tmp69_;
	cairo_matrix_t _tmp70_;
	cairo_t* _tmp71_;
	cairo_t* _tmp72_;
	const gchar* _tmp73_;
	cairo_text_extents_t _tmp74_ = {0};
	cairo_t* _tmp75_;
	cairo_text_extents_t _tmp76_;
	gdouble _tmp77_;
	cairo_text_extents_t _tmp78_;
	gdouble _tmp79_;
	cairo_t* _tmp80_;
	const gchar* _tmp81_;
	cairo_t* _tmp82_;
	cairo_matrix_t _tmp83_;
	cairo_t* _tmp84_;
	cairo_t* _tmp187_;
	cairo_matrix_t _tmp188_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = componentInst;
	if (_tmp0_ == NULL) {
		gint _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		_tmp1_ = self->rightBound;
		rightBound = _tmp1_;
		_tmp2_ = self->downBound;
		downBound = _tmp2_;
		_tmp3_ = self->leftBound;
		leftBound = _tmp3_;
		_tmp4_ = self->upBound;
		upBound = _tmp4_;
	} else {
		ComponentInst* _tmp5_;
		gint _tmp6_;
		ComponentInst* _tmp7_;
		gint _tmp8_;
		ComponentInst* _tmp9_;
		gint _tmp10_;
		ComponentInst* _tmp11_;
		gint _tmp12_;
		_tmp5_ = componentInst;
		_tmp6_ = _tmp5_->rightBound;
		rightBound = _tmp6_;
		_tmp7_ = componentInst;
		_tmp8_ = _tmp7_->downBound;
		downBound = _tmp8_;
		_tmp9_ = componentInst;
		_tmp10_ = _tmp9_->leftBound;
		leftBound = _tmp10_;
		_tmp11_ = componentInst;
		_tmp12_ = _tmp11_->upBound;
		upBound = _tmp12_;
	}
	_tmp13_ = context;
	cairo_get_matrix (_tmp13_, &_tmp14_);
	oldmatrix = _tmp14_;
	_tmp15_ = context;
	cairo_set_source_rgba (_tmp15_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 1);
	angle = (gdouble) 0;
	_tmp16_ = direction;
	switch (_tmp16_) {
		case DIRECTION_RIGHT:
		{
			angle = (gdouble) 0;
			break;
		}
		case DIRECTION_DOWN:
		{
			angle = G_PI * 0.5;
			break;
		}
		case DIRECTION_LEFT:
		{
			angle = G_PI;
			break;
		}
		case DIRECTION_UP:
		{
			angle = G_PI * 1.5;
			break;
		}
		default:
		break;
	}
	_tmp17_ = context;
	_tmp18_ = angle;
	cairo_rotate (_tmp17_, _tmp18_);
	_tmp19_ = flipped;
	if (_tmp19_) {
		cairo_t* _tmp20_;
		_tmp20_ = context;
		cairo_scale (_tmp20_, 1.0, -1.0);
	}
	_tmp21_ = context;
	cairo_set_line_width (_tmp21_, (gdouble) 2);
	_tmp22_ = self->drawBox;
	if (_tmp22_) {
		gboolean _tmp23_ = FALSE;
		gint _tmp24_;
		gint _tmp25_;
		gboolean _tmp28_;
		_tmp24_ = leftBound;
		_tmp25_ = rightBound;
		if ((_tmp24_ - _tmp25_) == 0) {
			gint _tmp26_;
			gint _tmp27_;
			_tmp26_ = upBound;
			_tmp27_ = downBound;
			_tmp23_ = (_tmp26_ - _tmp27_) == 0;
		} else {
			_tmp23_ = FALSE;
		}
		_tmp28_ = _tmp23_;
		if (_tmp28_) {
			cairo_t* _tmp29_;
			cairo_t* _tmp30_;
			cairo_line_cap_t _tmp31_ = 0;
			cairo_line_cap_t oldLineCap;
			cairo_t* _tmp32_;
			cairo_t* _tmp33_;
			gint _tmp34_;
			gint _tmp35_;
			cairo_t* _tmp36_;
			gint _tmp37_;
			gint _tmp38_;
			cairo_t* _tmp39_;
			cairo_t* _tmp40_;
			cairo_line_cap_t _tmp41_;
			cairo_t* _tmp42_;
			_tmp29_ = context;
			cairo_set_line_width (_tmp29_, (gdouble) 5);
			_tmp30_ = context;
			_tmp31_ = cairo_get_line_cap (_tmp30_);
			oldLineCap = _tmp31_;
			_tmp32_ = context;
			cairo_set_line_cap (_tmp32_, CAIRO_LINE_CAP_ROUND);
			_tmp33_ = context;
			_tmp34_ = rightBound;
			_tmp35_ = downBound;
			cairo_move_to (_tmp33_, (gdouble) _tmp34_, (gdouble) _tmp35_);
			_tmp36_ = context;
			_tmp37_ = rightBound;
			_tmp38_ = downBound;
			cairo_line_to (_tmp36_, (gdouble) _tmp37_, (gdouble) _tmp38_);
			_tmp39_ = context;
			cairo_stroke (_tmp39_);
			_tmp40_ = context;
			_tmp41_ = oldLineCap;
			cairo_set_line_cap (_tmp40_, _tmp41_);
			_tmp42_ = context;
			cairo_stroke (_tmp42_);
		} else {
			gboolean _tmp43_;
			cairo_t* _tmp58_;
			cairo_t* _tmp59_;
			gint _tmp60_;
			gint _tmp61_;
			gint _tmp62_;
			gint _tmp63_;
			gint _tmp64_;
			gint _tmp65_;
			cairo_t* _tmp66_;
			_tmp43_ = colourBackground;
			if (_tmp43_) {
				cairo_t* _tmp44_;
				gdouble _tmp45_;
				gdouble _tmp46_;
				gdouble _tmp47_;
				gdouble _tmp48_;
				cairo_t* _tmp49_;
				gint _tmp50_;
				gint _tmp51_;
				gint _tmp52_;
				gint _tmp53_;
				gint _tmp54_;
				gint _tmp55_;
				cairo_t* _tmp56_;
				cairo_t* _tmp57_;
				_tmp44_ = context;
				_tmp45_ = self->backgroundRedF;
				_tmp46_ = self->backgroundGreenF;
				_tmp47_ = self->backgroundBlueF;
				_tmp48_ = self->backgroundAlphaF;
				cairo_set_source_rgba (_tmp44_, _tmp45_, _tmp46_, _tmp47_, _tmp48_);
				_tmp49_ = context;
				_tmp50_ = leftBound;
				_tmp51_ = upBound;
				_tmp52_ = rightBound;
				_tmp53_ = leftBound;
				_tmp54_ = downBound;
				_tmp55_ = upBound;
				cairo_rectangle (_tmp49_, (gdouble) _tmp50_, (gdouble) _tmp51_, (gdouble) (_tmp52_ - _tmp53_), (gdouble) (_tmp54_ - _tmp55_));
				_tmp56_ = context;
				cairo_fill (_tmp56_);
				_tmp57_ = context;
				cairo_stroke (_tmp57_);
			}
			_tmp58_ = context;
			cairo_set_source_rgba (_tmp58_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 1);
			_tmp59_ = context;
			_tmp60_ = leftBound;
			_tmp61_ = upBound;
			_tmp62_ = rightBound;
			_tmp63_ = leftBound;
			_tmp64_ = downBound;
			_tmp65_ = upBound;
			cairo_rectangle (_tmp59_, (gdouble) _tmp60_, (gdouble) _tmp61_, (gdouble) (_tmp62_ - _tmp63_), (gdouble) (_tmp64_ - _tmp65_));
			_tmp66_ = context;
			cairo_stroke (_tmp66_);
		}
	}
	_tmp67_ = context;
	cairo_get_matrix (_tmp67_, &_tmp68_);
	oldmatrix2 = _tmp68_;
	_tmp69_ = context;
	_tmp70_ = oldmatrix;
	cairo_set_matrix (_tmp69_, &_tmp70_);
	_tmp71_ = context;
	cairo_set_font_size (_tmp71_, (gdouble) 16);
	_tmp72_ = context;
	_tmp73_ = self->label;
	cairo_text_extents (_tmp72_, _tmp73_, &_tmp74_);
	textExtents = _tmp74_;
	_tmp75_ = context;
	_tmp76_ = textExtents;
	_tmp77_ = _tmp76_.width;
	_tmp78_ = textExtents;
	_tmp79_ = _tmp78_.height;
	cairo_move_to (_tmp75_, (-_tmp77_) / 2, (+_tmp79_) / 2);
	_tmp80_ = context;
	_tmp81_ = self->label;
	cairo_show_text (_tmp80_, _tmp81_);
	_tmp82_ = context;
	_tmp83_ = oldmatrix2;
	cairo_set_matrix (_tmp82_, &_tmp83_);
	_tmp84_ = context;
	cairo_set_line_width (_tmp84_, (gdouble) 1);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp85_;
			_tmp85_ = TRUE;
			while (TRUE) {
				gboolean _tmp86_;
				gint _tmp88_;
				PinDef** _tmp89_;
				gint _tmp89__length1;
				ComponentInst* _tmp90_;
				PinDef** _tmp99_;
				gint _tmp99__length1;
				gint _tmp100_;
				PinDef* _tmp101_;
				PinDef* _tmp102_;
				PinDef* pinDef;
				PinDef* _tmp103_;
				PinDefLabelType _tmp104_;
				_tmp86_ = _tmp85_;
				if (!_tmp86_) {
					gint _tmp87_;
					_tmp87_ = i;
					i = _tmp87_ + 1;
				}
				_tmp85_ = FALSE;
				_tmp88_ = i;
				_tmp89_ = self->pinDefs;
				_tmp89__length1 = self->pinDefs_length1;
				if (!(_tmp88_ < _tmp89__length1)) {
					break;
				}
				_tmp90_ = componentInst;
				if (_tmp90_ != NULL) {
					gint _tmp91_;
					ComponentInst* _tmp92_;
					PinInst** _tmp93_;
					gint _tmp93__length1;
					ComponentInst* _tmp94_;
					PinInst** _tmp95_;
					gint _tmp95__length1;
					gint _tmp96_;
					PinInst* _tmp97_;
					gboolean _tmp98_;
					_tmp91_ = i;
					_tmp92_ = componentInst;
					_tmp93_ = _tmp92_->pinInsts;
					_tmp93__length1 = _tmp92_->pinInsts_length1;
					if (_tmp91_ >= _tmp93__length1) {
						break;
					}
					_tmp94_ = componentInst;
					_tmp95_ = _tmp94_->pinInsts;
					_tmp95__length1 = _tmp94_->pinInsts_length1;
					_tmp96_ = i;
					_tmp97_ = _tmp95_[_tmp96_];
					_tmp98_ = _tmp97_->show;
					if (!_tmp98_) {
						continue;
					}
				}
				_tmp99_ = self->pinDefs;
				_tmp99__length1 = self->pinDefs_length1;
				_tmp100_ = i;
				_tmp101_ = _tmp99_[_tmp100_];
				_tmp102_ = _pin_def_ref0 (_tmp101_);
				pinDef = _tmp102_;
				_tmp103_ = pinDef;
				_tmp104_ = _tmp103_->labelType;
				switch (_tmp104_) {
					case PIN_DEF_LABEL_TYPE_TEXT:
					case PIN_DEF_LABEL_TYPE_TEXTBAR:
					{
						cairo_t* _tmp105_;
						cairo_matrix_t _tmp106_ = {0};
						ComponentInst* _tmp107_;
						gboolean _tmp124_;
						cairo_t* _tmp126_;
						gdouble _tmp127_;
						cairo_t* _tmp128_;
						cairo_t* _tmp129_;
						PinDef* _tmp130_;
						const gchar* _tmp131_;
						cairo_text_extents_t _tmp132_ = {0};
						cairo_t* _tmp133_;
						cairo_text_extents_t _tmp134_;
						gdouble _tmp135_;
						cairo_text_extents_t _tmp136_;
						gdouble _tmp137_;
						cairo_t* _tmp138_;
						PinDef* _tmp139_;
						const gchar* _tmp140_;
						PinDef* _tmp141_;
						PinDefLabelType _tmp142_;
						cairo_t* _tmp154_;
						cairo_matrix_t _tmp155_;
						_tmp105_ = context;
						cairo_get_matrix (_tmp105_, &_tmp106_);
						oldmatrix2 = _tmp106_;
						_tmp107_ = componentInst;
						if (_tmp107_ == NULL) {
							cairo_t* _tmp108_;
							PinDef* _tmp109_;
							gint _tmp110_;
							PinDef* _tmp111_;
							gint _tmp112_;
							_tmp108_ = context;
							_tmp109_ = pinDef;
							_tmp110_ = _tmp109_->xLabel;
							_tmp111_ = pinDef;
							_tmp112_ = _tmp111_->yLabel;
							cairo_translate (_tmp108_, (gdouble) _tmp110_, (gdouble) _tmp112_);
						} else {
							cairo_t* _tmp113_;
							ComponentInst* _tmp114_;
							PinInst** _tmp115_;
							gint _tmp115__length1;
							gint _tmp116_;
							PinInst* _tmp117_;
							gint _tmp118_;
							ComponentInst* _tmp119_;
							PinInst** _tmp120_;
							gint _tmp120__length1;
							gint _tmp121_;
							PinInst* _tmp122_;
							gint _tmp123_;
							_tmp113_ = context;
							_tmp114_ = componentInst;
							_tmp115_ = _tmp114_->pinInsts;
							_tmp115__length1 = _tmp114_->pinInsts_length1;
							_tmp116_ = i;
							_tmp117_ = _tmp115_[_tmp116_];
							_tmp118_ = _tmp117_->xLabel;
							_tmp119_ = componentInst;
							_tmp120_ = _tmp119_->pinInsts;
							_tmp120__length1 = _tmp119_->pinInsts_length1;
							_tmp121_ = i;
							_tmp122_ = _tmp120_[_tmp121_];
							_tmp123_ = _tmp122_->yLabel;
							cairo_translate (_tmp113_, (gdouble) _tmp118_, (gdouble) _tmp123_);
						}
						_tmp124_ = flipped;
						if (_tmp124_) {
							cairo_t* _tmp125_;
							_tmp125_ = context;
							cairo_scale (_tmp125_, 1.0, -1.0);
						}
						_tmp126_ = context;
						_tmp127_ = angle;
						cairo_rotate (_tmp126_, -_tmp127_);
						_tmp128_ = context;
						cairo_set_font_size (_tmp128_, (gdouble) 8);
						_tmp129_ = context;
						_tmp130_ = pinDef;
						_tmp131_ = _tmp130_->label;
						cairo_text_extents (_tmp129_, _tmp131_, &_tmp132_);
						textExtents = _tmp132_;
						_tmp133_ = context;
						_tmp134_ = textExtents;
						_tmp135_ = _tmp134_.width;
						_tmp136_ = textExtents;
						_tmp137_ = _tmp136_.height;
						cairo_move_to (_tmp133_, (-_tmp135_) / 2, (+_tmp137_) / 2);
						_tmp138_ = context;
						_tmp139_ = pinDef;
						_tmp140_ = _tmp139_->label;
						cairo_show_text (_tmp138_, _tmp140_);
						_tmp141_ = pinDef;
						_tmp142_ = _tmp141_->labelType;
						if (_tmp142_ == PIN_DEF_LABEL_TYPE_TEXTBAR) {
							cairo_t* _tmp143_;
							cairo_text_extents_t _tmp144_;
							gdouble _tmp145_;
							cairo_text_extents_t _tmp146_;
							gdouble _tmp147_;
							cairo_t* _tmp148_;
							cairo_text_extents_t _tmp149_;
							gdouble _tmp150_;
							cairo_text_extents_t _tmp151_;
							gdouble _tmp152_;
							cairo_t* _tmp153_;
							_tmp143_ = context;
							_tmp144_ = textExtents;
							_tmp145_ = _tmp144_.width;
							_tmp146_ = textExtents;
							_tmp147_ = _tmp146_.height;
							cairo_move_to (_tmp143_, (-_tmp145_) / 2, (-1) - (_tmp147_ / 2));
							_tmp148_ = context;
							_tmp149_ = textExtents;
							_tmp150_ = _tmp149_.width;
							_tmp151_ = textExtents;
							_tmp152_ = _tmp151_.height;
							cairo_line_to (_tmp148_, _tmp150_ / 2, (-1) - (_tmp152_ / 2));
							_tmp153_ = context;
							cairo_stroke (_tmp153_);
						}
						_tmp154_ = context;
						_tmp155_ = oldmatrix2;
						cairo_set_matrix (_tmp154_, &_tmp155_);
						break;
					}
					case PIN_DEF_LABEL_TYPE_CLOCK:
					{
						cairo_t* _tmp156_;
						cairo_matrix_t _tmp157_ = {0};
						ComponentInst* _tmp158_;
						gdouble angle2;
						PinDef* _tmp177_;
						Direction _tmp178_;
						cairo_t* _tmp179_;
						gdouble _tmp180_;
						cairo_t* _tmp181_;
						cairo_t* _tmp182_;
						cairo_t* _tmp183_;
						cairo_t* _tmp184_;
						cairo_t* _tmp185_;
						cairo_matrix_t _tmp186_;
						_tmp156_ = context;
						cairo_get_matrix (_tmp156_, &_tmp157_);
						oldmatrix2 = _tmp157_;
						_tmp158_ = componentInst;
						if (_tmp158_ == NULL) {
							cairo_t* _tmp159_;
							PinDef* _tmp160_;
							gint _tmp161_;
							PinDef* _tmp162_;
							gint _tmp163_;
							_tmp159_ = context;
							_tmp160_ = pinDef;
							_tmp161_ = _tmp160_->x;
							_tmp162_ = pinDef;
							_tmp163_ = _tmp162_->y;
							cairo_translate (_tmp159_, (gdouble) _tmp161_, (gdouble) _tmp163_);
						} else {
							cairo_t* _tmp164_;
							ComponentInst* _tmp165_;
							PinInst** _tmp166_;
							gint _tmp166__length1;
							gint _tmp167_;
							PinInst* _tmp168_;
							gint* _tmp169_;
							gint _tmp169__length1;
							gint _tmp170_;
							ComponentInst* _tmp171_;
							PinInst** _tmp172_;
							gint _tmp172__length1;
							gint _tmp173_;
							PinInst* _tmp174_;
							gint* _tmp175_;
							gint _tmp175__length1;
							gint _tmp176_;
							_tmp164_ = context;
							_tmp165_ = componentInst;
							_tmp166_ = _tmp165_->pinInsts;
							_tmp166__length1 = _tmp165_->pinInsts_length1;
							_tmp167_ = i;
							_tmp168_ = _tmp166_[_tmp167_];
							_tmp169_ = _tmp168_->x;
							_tmp169__length1 = _tmp168_->x_length1;
							_tmp170_ = _tmp169_[0];
							_tmp171_ = componentInst;
							_tmp172_ = _tmp171_->pinInsts;
							_tmp172__length1 = _tmp171_->pinInsts_length1;
							_tmp173_ = i;
							_tmp174_ = _tmp172_[_tmp173_];
							_tmp175_ = _tmp174_->y;
							_tmp175__length1 = _tmp174_->y_length1;
							_tmp176_ = _tmp175_[0];
							cairo_translate (_tmp164_, (gdouble) _tmp170_, (gdouble) _tmp176_);
						}
						angle2 = (gdouble) 0;
						_tmp177_ = pinDef;
						_tmp178_ = _tmp177_->direction;
						switch (_tmp178_) {
							case DIRECTION_RIGHT:
							{
								angle2 = (gdouble) 0;
								break;
							}
							case DIRECTION_DOWN:
							{
								angle2 = G_PI * 0.5;
								break;
							}
							case DIRECTION_LEFT:
							{
								angle2 = G_PI;
								break;
							}
							case DIRECTION_UP:
							{
								angle2 = G_PI * 1.5;
								break;
							}
							default:
							break;
						}
						_tmp179_ = context;
						_tmp180_ = angle2;
						cairo_rotate (_tmp179_, _tmp180_);
						_tmp181_ = context;
						cairo_move_to (_tmp181_, (gdouble) 0, (gdouble) (-6));
						_tmp182_ = context;
						cairo_line_to (_tmp182_, (gdouble) (-9), (gdouble) 0);
						_tmp183_ = context;
						cairo_line_to (_tmp183_, (gdouble) 0, (gdouble) 6);
						_tmp184_ = context;
						cairo_stroke (_tmp184_);
						_tmp185_ = context;
						_tmp186_ = oldmatrix2;
						cairo_set_matrix (_tmp185_, &_tmp186_);
						break;
					}
					default:
					break;
				}
				_pin_def_unref0 (pinDef);
			}
		}
	}
	_tmp187_ = context;
	_tmp188_ = oldmatrix;
	cairo_set_matrix (_tmp187_, &_tmp188_);
}


/**
 * Some ComponentDefs do extra rendering.
 */
static void component_def_real_extra_render (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst) {
	g_return_if_fail (context != NULL);
}


void component_def_extra_render (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst) {
	g_return_if_fail (self != NULL);
	COMPONENT_DEF_GET_CLASS (self)->extra_render (self, context, direction, flipped, componentInst);
}


/**
 * Some ComponentDefs do extra validation. CURRENTLY UNUSED.
 */
static void component_def_real_extra_validate (ComponentDef* self, Project* project, CustomComponentDef** componentChain, int componentChain_length1, ComponentInst* componentInst) {
	g_return_if_fail (project != NULL);
}


void component_def_extra_validate (ComponentDef* self, Project* project, CustomComponentDef** componentChain, int componentChain_length1, ComponentInst* componentInst) {
	g_return_if_fail (self != NULL);
	COMPONENT_DEF_GET_CLASS (self)->extra_validate (self, project, componentChain, componentChain_length1, componentInst);
}


/**
 * Some ComponentInsts need to hold extra information which they
 * cannot process. This helps create a PropertySet for a 
 * PropertiesQuery.
 */
static void component_def_real_add_properties (ComponentDef* self, PropertySet* queryProperty, PropertySet* configurationProperty) {
	g_return_if_fail (queryProperty != NULL);
	g_return_if_fail (configurationProperty != NULL);
}


void component_def_add_properties (ComponentDef* self, PropertySet* queryProperty, PropertySet* configurationProperty) {
	g_return_if_fail (self != NULL);
	COMPONENT_DEF_GET_CLASS (self)->add_properties (self, queryProperty, configurationProperty);
}


/**
 * Some ComponentInsts need to hold extra information which they
 * cannot process. This is used to extract the user input from a 
 * PropertiesQuery stored in a PropertySet into another PropertySet.
 */
static void component_def_real_get_properties (ComponentDef* self, PropertySet* queryProperty, PropertySet** configurationProperty) {
	PropertySet* _vala_configurationProperty = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	PropertySet* _tmp3_;
	g_return_if_fail (queryProperty != NULL);
	_tmp0_ = self->name;
	_tmp1_ = g_strconcat (_tmp0_, " configuration", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = property_set_new (_tmp2_, "");
	_property_item_unref0 (_vala_configurationProperty);
	_vala_configurationProperty = _tmp3_;
	_g_free0 (_tmp2_);
	if (configurationProperty) {
		*configurationProperty = _vala_configurationProperty;
	} else {
		_property_item_unref0 (_vala_configurationProperty);
	}
}


void component_def_get_properties (ComponentDef* self, PropertySet* queryProperty, PropertySet** configurationProperty) {
	g_return_if_fail (self != NULL);
	COMPONENT_DEF_GET_CLASS (self)->get_properties (self, queryProperty, configurationProperty);
}


/**
 * Some ComponentInsts need to hold extra information which they
 * cannot process. This loads properties from a file using libxml.
 */
static void component_def_real_load_properties (ComponentDef* self, xmlNode* xmlnode, PropertySet** configurationProperty) {
	PropertySet* _vala_configurationProperty = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	PropertySet* _tmp3_;
	_tmp0_ = self->name;
	_tmp1_ = g_strconcat (_tmp0_, " configuration", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = property_set_new (_tmp2_, "");
	_property_item_unref0 (_vala_configurationProperty);
	_vala_configurationProperty = _tmp3_;
	_g_free0 (_tmp2_);
	if (configurationProperty) {
		*configurationProperty = _vala_configurationProperty;
	} else {
		_property_item_unref0 (_vala_configurationProperty);
	}
}


void component_def_load_properties (ComponentDef* self, xmlNode* xmlnode, PropertySet** configurationProperty) {
	g_return_if_fail (self != NULL);
	COMPONENT_DEF_GET_CLASS (self)->load_properties (self, xmlnode, configurationProperty);
}


/**
 * Some ComponentInsts need to hold extra information which they
 * cannot process. This saves properties to a file using libxml.
 */
static void component_def_real_save_properties (ComponentDef* self, xmlTextWriter* xmlWriter, PropertySet* configurationProperty) {
	g_return_if_fail (xmlWriter != NULL);
	g_return_if_fail (configurationProperty != NULL);
}


void component_def_save_properties (ComponentDef* self, xmlTextWriter* xmlWriter, PropertySet* configurationProperty) {
	g_return_if_fail (self != NULL);
	COMPONENT_DEF_GET_CLASS (self)->save_properties (self, xmlWriter, configurationProperty);
}


static void component_def_real_configure_inst (ComponentDef* self, ComponentInst* componentInst, gboolean firstLoad) {
	g_return_if_fail (componentInst != NULL);
}


void component_def_configure_inst (ComponentDef* self, ComponentInst* componentInst, gboolean firstLoad) {
	g_return_if_fail (self != NULL);
	COMPONENT_DEF_GET_CLASS (self)->configure_inst (self, componentInst, firstLoad);
}


/**
 * Low level compilation. Handled differently for each ComponentDef
 * sub class.
 */
static void component_def_real_compile_component (ComponentDef* self, CompiledCircuit* compiledCircuit, ComponentInst* componentInst, Connection** connections, int connections_length1, ComponentInst** ancestry, int ancestry_length1) {
	g_critical ("Type `%s' does not implement abstract method `component_def_compile_component'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void component_def_compile_component (ComponentDef* self, CompiledCircuit* compiledCircuit, ComponentInst* componentInst, Connection** connections, int connections_length1, ComponentInst** ancestry, int ancestry_length1) {
	g_return_if_fail (self != NULL);
	COMPONENT_DEF_GET_CLASS (self)->compile_component (self, compiledCircuit, componentInst, connections, connections_length1, ancestry, ancestry_length1);
}


static void component_def_real_create_information (ComponentDef* self, CircuitInformation* circuitInformation) {
	CircuitInformation* _tmp0_;
	g_return_if_fail (circuitInformation != NULL);
	_tmp0_ = circuitInformation;
	circuit_information_count_component (_tmp0_, self);
}


void component_def_create_information (ComponentDef* self, CircuitInformation* circuitInformation) {
	g_return_if_fail (self != NULL);
	COMPONENT_DEF_GET_CLASS (self)->create_information (self, circuitInformation);
}


ComponentDef* component_def_construct (GType object_type) {
	ComponentDef* self = NULL;
	self = (ComponentDef*) g_type_create_instance (object_type);
	return self;
}


static void value_component_def_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_component_def_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		component_def_unref (value->data[0].v_pointer);
	}
}


static void value_component_def_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = component_def_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_component_def_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_component_def_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ComponentDef* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = component_def_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_component_def_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ComponentDef** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = component_def_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_component_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecComponentDef* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_COMPONENT_DEF), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_component_def (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_COMPONENT_DEF), NULL);
	return value->data[0].v_pointer;
}


void value_set_component_def (GValue* value, gpointer v_object) {
	ComponentDef* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_COMPONENT_DEF));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_COMPONENT_DEF));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		component_def_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		component_def_unref (old);
	}
}


void value_take_component_def (GValue* value, gpointer v_object) {
	ComponentDef* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_COMPONENT_DEF));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_COMPONENT_DEF));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		component_def_unref (old);
	}
}


static void component_def_class_init (ComponentDefClass * klass) {
	component_def_parent_class = g_type_class_peek_parent (klass);
	COMPONENT_DEF_CLASS (klass)->finalize = component_def_finalize;
	COMPONENT_DEF_CLASS (klass)->extra_render = component_def_real_extra_render;
	COMPONENT_DEF_CLASS (klass)->extra_validate = component_def_real_extra_validate;
	COMPONENT_DEF_CLASS (klass)->add_properties = component_def_real_add_properties;
	COMPONENT_DEF_CLASS (klass)->get_properties = component_def_real_get_properties;
	COMPONENT_DEF_CLASS (klass)->load_properties = component_def_real_load_properties;
	COMPONENT_DEF_CLASS (klass)->save_properties = component_def_real_save_properties;
	COMPONENT_DEF_CLASS (klass)->configure_inst = component_def_real_configure_inst;
	COMPONENT_DEF_CLASS (klass)->compile_component = component_def_real_compile_component;
	COMPONENT_DEF_CLASS (klass)->create_information = component_def_real_create_information;
}


static void component_def_instance_init (ComponentDef * self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = g_strdup ("");
	self->name = _tmp0_;
	_tmp1_ = g_strdup ("");
	self->description = _tmp1_;
	_tmp2_ = g_strdup ("");
	self->iconFilename = _tmp2_;
	_tmp3_ = g_strdup ("");
	self->label = _tmp3_;
	self->backgroundAlpha = 0;
	self->backgroundRed = 255;
	self->backgroundGreen = 255;
	self->backgroundBlue = 255;
	self->backgroundAlphaF = (gdouble) 0;
	self->backgroundRedF = (gdouble) 1;
	self->backgroundGreenF = (gdouble) 1;
	self->backgroundBlueF = (gdouble) 1;
	self->drawBox = TRUE;
	_tmp4_ = g_strdup ("");
	self->filename = _tmp4_;
	self->ref_count = 1;
}


static void component_def_finalize (ComponentDef* obj) {
	ComponentDef * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_COMPONENT_DEF, ComponentDef);
	_graphic_unref0 (self->graphic);
	_g_free0 (self->name);
	_g_free0 (self->description);
	_g_free0 (self->iconFilename);
	_g_free0 (self->label);
	self->pinDefs = (_vala_array_free (self->pinDefs, self->pinDefs_length1, (GDestroyNotify) pin_def_unref), NULL);
	_g_free0 (self->filename);
}


/**
 * Definition of a component
 * 
 * Used to describe a component's appearance, compile ComponentStates,
 * and handle special properties held by ComponentInsts.
 */
GType component_def_get_type (void) {
	static volatile gsize component_def_type_id__volatile = 0;
	if (g_once_init_enter (&component_def_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_component_def_init, value_component_def_free_value, value_component_def_copy_value, value_component_def_peek_pointer, "p", value_component_def_collect_value, "p", value_component_def_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ComponentDefClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) component_def_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ComponentDef), 0, (GInstanceInitFunc) component_def_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType component_def_type_id;
		component_def_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ComponentDef", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&component_def_type_id__volatile, component_def_type_id);
	}
	return component_def_type_id__volatile;
}


gpointer component_def_ref (gpointer instance) {
	ComponentDef* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void component_def_unref (gpointer instance) {
	ComponentDef* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		COMPONENT_DEF_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



