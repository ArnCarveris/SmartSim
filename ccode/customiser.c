/* customiser.c generated by valac 0.20.1, the Vala compiler
 * generated from customiser.vala, do not modify */

/* 
 * SmartSim - Digital Logic Circuit Designer and Simulator
 *   
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *   
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *   
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *   
 *   Filename: customiser.vala
 *   
 *   Copyright Ashley Newson 2013
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <cairo.h>
#include <libxml/tree.h>
#include <libxml/xmlwriter.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_CUSTOMISER (customiser_get_type ())
#define CUSTOMISER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOMISER, Customiser))
#define CUSTOMISER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOMISER, CustomiserClass))
#define IS_CUSTOMISER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOMISER))
#define IS_CUSTOMISER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOMISER))
#define CUSTOMISER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOMISER, CustomiserClass))

typedef struct _Customiser Customiser;
typedef struct _CustomiserClass CustomiserClass;
typedef struct _CustomiserPrivate CustomiserPrivate;

#define TYPE_COMPONENT_DEF (component_def_get_type ())
#define COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_DEF, ComponentDef))
#define COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_DEF, ComponentDefClass))
#define IS_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_DEF))
#define IS_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_DEF))
#define COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_DEF, ComponentDefClass))

typedef struct _ComponentDef ComponentDef;
typedef struct _ComponentDefClass ComponentDefClass;

#define TYPE_CUSTOM_COMPONENT_DEF (custom_component_def_get_type ())
#define CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDef))
#define CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))
#define IS_CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_COMPONENT_DEF))
#define IS_CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOM_COMPONENT_DEF))
#define CUSTOM_COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))

typedef struct _CustomComponentDef CustomComponentDef;
typedef struct _CustomComponentDefClass CustomComponentDefClass;

#define TYPE_DESIGNER_WINDOW (designer_window_get_type ())
#define DESIGNER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DESIGNER_WINDOW, DesignerWindow))
#define DESIGNER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DESIGNER_WINDOW, DesignerWindowClass))
#define IS_DESIGNER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DESIGNER_WINDOW))
#define IS_DESIGNER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DESIGNER_WINDOW))
#define DESIGNER_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DESIGNER_WINDOW, DesignerWindowClass))

typedef struct _DesignerWindow DesignerWindow;
typedef struct _DesignerWindowClass DesignerWindowClass;

#define TYPE_PROJECT (project_get_type ())
#define PROJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROJECT, Project))
#define PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROJECT, ProjectClass))
#define IS_PROJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROJECT))
#define IS_PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROJECT))
#define PROJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROJECT, ProjectClass))

typedef struct _Project Project;
typedef struct _ProjectClass ProjectClass;

#define TYPE_PIN_DEF (pin_def_get_type ())
#define PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PIN_DEF, PinDef))
#define PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PIN_DEF, PinDefClass))
#define IS_PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PIN_DEF))
#define IS_PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PIN_DEF))
#define PIN_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PIN_DEF, PinDefClass))

typedef struct _PinDef PinDef;
typedef struct _PinDefClass PinDefClass;

#define TYPE_TAG (tag_get_type ())
#define TAG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TAG, Tag))
#define TAG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TAG, TagClass))
#define IS_TAG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TAG))
#define IS_TAG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TAG))
#define TAG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TAG, TagClass))

typedef struct _Tag Tag;
typedef struct _TagClass TagClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _component_def_unref0(var) ((var == NULL) ? NULL : (var = (component_def_unref (var), NULL)))
#define _project_unref0(var) ((var == NULL) ? NULL : (var = (project_unref (var), NULL)))
#define _pin_def_unref0(var) ((var == NULL) ? NULL : (var = (pin_def_unref (var), NULL)))
#define _tag_unref0(var) ((var == NULL) ? NULL : (var = (tag_unref (var), NULL)))
typedef struct _ComponentDefPrivate ComponentDefPrivate;

#define TYPE_DIRECTION (direction_get_type ())

#define TYPE_COMPONENT_INST (component_inst_get_type ())
#define COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_INST, ComponentInst))
#define COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_INST, ComponentInstClass))
#define IS_COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_INST))
#define IS_COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_INST))
#define COMPONENT_INST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_INST, ComponentInstClass))

typedef struct _ComponentInst ComponentInst;
typedef struct _ComponentInstClass ComponentInstClass;

#define TYPE_PROPERTY_ITEM (property_item_get_type ())
#define PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_ITEM, PropertyItem))
#define PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_ITEM, PropertyItemClass))
#define IS_PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_ITEM))
#define IS_PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_ITEM))
#define PROPERTY_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_ITEM, PropertyItemClass))

typedef struct _PropertyItem PropertyItem;
typedef struct _PropertyItemClass PropertyItemClass;

#define TYPE_PROPERTY_SET (property_set_get_type ())
#define PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_SET, PropertySet))
#define PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_SET, PropertySetClass))
#define IS_PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_SET))
#define IS_PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_SET))
#define PROPERTY_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_SET, PropertySetClass))

typedef struct _PropertySet PropertySet;
typedef struct _PropertySetClass PropertySetClass;

#define TYPE_COMPILED_CIRCUIT (compiled_circuit_get_type ())
#define COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuit))
#define COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))
#define IS_COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPILED_CIRCUIT))
#define IS_COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPILED_CIRCUIT))
#define COMPILED_CIRCUIT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))

typedef struct _CompiledCircuit CompiledCircuit;
typedef struct _CompiledCircuitClass CompiledCircuitClass;

#define TYPE_CONNECTION (connection_get_type ())
#define CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONNECTION, Connection))
#define CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONNECTION, ConnectionClass))
#define IS_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONNECTION))
#define IS_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONNECTION))
#define CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONNECTION, ConnectionClass))

typedef struct _Connection Connection;
typedef struct _ConnectionClass ConnectionClass;

#define TYPE_CIRCUIT_INFORMATION (circuit_information_get_type ())
#define CIRCUIT_INFORMATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CIRCUIT_INFORMATION, CircuitInformation))
#define CIRCUIT_INFORMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CIRCUIT_INFORMATION, CircuitInformationClass))
#define IS_CIRCUIT_INFORMATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CIRCUIT_INFORMATION))
#define IS_CIRCUIT_INFORMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CIRCUIT_INFORMATION))
#define CIRCUIT_INFORMATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CIRCUIT_INFORMATION, CircuitInformationClass))

typedef struct _CircuitInformation CircuitInformation;
typedef struct _CircuitInformationClass CircuitInformationClass;

#define TYPE_GRAPHIC (graphic_get_type ())
#define GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GRAPHIC, Graphic))
#define GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GRAPHIC, GraphicClass))
#define IS_GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GRAPHIC))
#define IS_GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GRAPHIC))
#define GRAPHIC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GRAPHIC, GraphicClass))

typedef struct _Graphic Graphic;
typedef struct _GraphicClass GraphicClass;
typedef struct _TagPrivate TagPrivate;

#define TYPE_FLOW (flow_get_type ())

#define PIN_DEF_TYPE_LABEL_TYPE (pin_def_label_type_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _PinDefPrivate PinDefPrivate;
typedef struct _DesignerWindowPrivate DesignerWindowPrivate;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
typedef struct _ParamSpecCustomiser ParamSpecCustomiser;

struct _Customiser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	CustomiserPrivate * priv;
};

struct _CustomiserClass {
	GTypeClass parent_class;
	void (*finalize) (Customiser *self);
};

struct _CustomiserPrivate {
	GtkDialog* dialog;
	GtkBox* layoutHBox;
	GtkEventBox* controller;
	GtkDrawingArea* display;
	GtkBox* controlsVBox;
	GtkBox* nameHBox;
	GtkEntry* nameEntry;
	GtkLabel* nameLabel;
	GtkBox* descriptionHBox;
	GtkEntry* descriptionEntry;
	GtkLabel* descriptionLabel;
	GtkBox* labelHBox;
	GtkEntry* labelEntry;
	GtkLabel* labelLabel;
	GtkBox* pinHBox;
	GtkSpinButton* pinSpinButton;
	GtkLabel* pinLabel;
	GtkLabel* tagNameLabel;
	GtkCheckButton* requiredCheck;
	GtkBox* labelTypeVBox;
	GtkLabel* labelTypeLabel;
	GtkRadioButton* labelTypeNoneRadio;
	GtkRadioButton* labelTypeTextRadio;
	GtkRadioButton* labelTypeTextBarRadio;
	GtkRadioButton* labelTypeClockRadio;
	GtkBox* pinLabelHBox;
	GtkEntry* pinLabelEntry;
	GtkLabel* pinLabelLabel;
	GtkLabel* boundsLabel;
	GtkGrid* boundsGrid;
	GtkLabel* rightBoundLabel;
	GtkSpinButton* rightBoundSpinButton;
	GtkLabel* downBoundLabel;
	GtkSpinButton* downBoundSpinButton;
	GtkLabel* leftBoundLabel;
	GtkSpinButton* leftBoundSpinButton;
	GtkLabel* upBoundLabel;
	GtkSpinButton* upBoundSpinButton;
	GtkButton* colourButton;
	GtkButton* closeButton;
	cairo_surface_t* gridCache;
	CustomComponentDef* customComponentDef;
	DesignerWindow* parent;
	Project* project;
	gint selectedPinID;
	PinDef* selectedPin;
	gint xMouseStart;
	gint yMouseStart;
	Tag* tag;
};

typedef enum  {
	DIRECTION_NONE,
	DIRECTION_RIGHT,
	DIRECTION_DOWN,
	DIRECTION_LEFT,
	DIRECTION_UP,
	DIRECTION_HORIZONTAL,
	DIRECTION_VERTICAL,
	DIRECTION_DIAGONAL
} Direction;

struct _ComponentDef {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ComponentDefPrivate * priv;
	Graphic* graphic;
	gchar* graphicReferenceFilename;
	gchar* name;
	gchar* description;
	gchar* iconFilename;
	gchar* label;
	PinDef** pinDefs;
	gint pinDefs_length1;
	gint rightBound;
	gint downBound;
	gint leftBound;
	gint upBound;
	gint backgroundAlpha;
	gint backgroundRed;
	gint backgroundGreen;
	gint backgroundBlue;
	gdouble backgroundAlphaF;
	gdouble backgroundRedF;
	gdouble backgroundGreenF;
	gdouble backgroundBlueF;
	gboolean drawBox;
	gchar* filename;
};

struct _ComponentDefClass {
	GTypeClass parent_class;
	void (*finalize) (ComponentDef *self);
	void (*extra_render) (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst);
	void (*extra_validate) (ComponentDef* self, Project* project, CustomComponentDef** componentChain, int componentChain_length1, ComponentInst* componentInst);
	void (*add_properties) (ComponentDef* self, PropertySet* queryProperty, PropertySet* configurationProperty);
	void (*get_properties) (ComponentDef* self, PropertySet* queryProperty, PropertySet** configurationProperty);
	void (*load_properties) (ComponentDef* self, xmlNode* xmlnode, PropertySet** configurationProperty);
	void (*save_properties) (ComponentDef* self, xmlTextWriter* xmlWriter, PropertySet* configurationProperty);
	void (*configure_inst) (ComponentDef* self, ComponentInst* componentInst, gboolean firstLoad);
	void (*compile_component) (ComponentDef* self, CompiledCircuit* compiledCircuit, ComponentInst* componentInst, Connection** connections, int connections_length1, ComponentInst** ancestry, int ancestry_length1);
	void (*create_information) (ComponentDef* self, CircuitInformation* circuitInformation);
};

typedef enum  {
	FLOW_NONE,
	FLOW_IN,
	FLOW_OUT,
	FLOW_BIDIRECTIONAL
} Flow;

struct _Tag {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TagPrivate * priv;
	gchar* text;
	gint xTag;
	gint yTag;
	gint xWire;
	gint yWire;
	gint pinid;
	Flow flow;
	Direction direction;
	gint rightBound;
	gint downBound;
	gint leftBound;
	gint upBound;
};

struct _TagClass {
	GTypeClass parent_class;
	void (*finalize) (Tag *self);
};

typedef enum  {
	PIN_DEF_LABEL_TYPE_NONE,
	PIN_DEF_LABEL_TYPE_TEXT,
	PIN_DEF_LABEL_TYPE_TEXTBAR,
	PIN_DEF_LABEL_TYPE_CLOCK
} PinDefLabelType;

struct _PinDef {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PinDefPrivate * priv;
	gint x;
	gint y;
	gint xLabel;
	gint yLabel;
	gint xConnect;
	gint yConnect;
	Direction direction;
	gint length;
	gboolean array;
	Flow flow;
	gint defaultArraySize;
	gint idealSpace;
	gfloat minSpace;
	gchar* label;
	gboolean required;
	gboolean userArrayResize;
	gboolean showDefault;
	PinDefLabelType labelType;
};

struct _PinDefClass {
	GTypeClass parent_class;
	void (*finalize) (PinDef *self);
};

struct _DesignerWindow {
	GtkWindow parent_instance;
	DesignerWindowPrivate * priv;
	gint myID;
	gchar* componentFileName;
	gint gridSize;
	gfloat zoom;
	gboolean showGrid;
	gboolean liveScrollUpdate;
	gboolean shadowComponent;
};

struct _DesignerWindowClass {
	GtkWindowClass parent_class;
};

struct _ParamSpecCustomiser {
	GParamSpec parent_instance;
};


static gpointer customiser_parent_class = NULL;

gpointer customiser_ref (gpointer instance);
void customiser_unref (gpointer instance);
GParamSpec* param_spec_customiser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_customiser (GValue* value, gpointer v_object);
void value_take_customiser (GValue* value, gpointer v_object);
gpointer value_get_customiser (const GValue* value);
GType customiser_get_type (void) G_GNUC_CONST;
gpointer component_def_ref (gpointer instance);
void component_def_unref (gpointer instance);
GParamSpec* param_spec_component_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_def (GValue* value, gpointer v_object);
void value_take_component_def (GValue* value, gpointer v_object);
gpointer value_get_component_def (const GValue* value);
GType component_def_get_type (void) G_GNUC_CONST;
GType custom_component_def_get_type (void) G_GNUC_CONST;
GType designer_window_get_type (void) G_GNUC_CONST;
gpointer project_ref (gpointer instance);
void project_unref (gpointer instance);
GParamSpec* param_spec_project (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_project (GValue* value, gpointer v_object);
void value_take_project (GValue* value, gpointer v_object);
gpointer value_get_project (const GValue* value);
GType project_get_type (void) G_GNUC_CONST;
gpointer pin_def_ref (gpointer instance);
void pin_def_unref (gpointer instance);
GParamSpec* param_spec_pin_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_pin_def (GValue* value, gpointer v_object);
void value_take_pin_def (GValue* value, gpointer v_object);
gpointer value_get_pin_def (const GValue* value);
GType pin_def_get_type (void) G_GNUC_CONST;
gpointer tag_ref (gpointer instance);
void tag_unref (gpointer instance);
GParamSpec* param_spec_tag (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_tag (GValue* value, gpointer v_object);
void value_take_tag (GValue* value, gpointer v_object);
gpointer value_get_tag (const GValue* value);
GType tag_get_type (void) G_GNUC_CONST;
#define CUSTOMISER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CUSTOMISER, CustomiserPrivate))
enum  {
	CUSTOMISER_DUMMY_PROPERTY
};
Customiser* customiser_new (DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project);
Customiser* customiser_construct (GType object_type, DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project);
gint custom_component_def_count_tags (CustomComponentDef* self);
GType direction_get_type (void) G_GNUC_CONST;
gpointer component_inst_ref (gpointer instance);
void component_inst_unref (gpointer instance);
GParamSpec* param_spec_component_inst (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_inst (GValue* value, gpointer v_object);
void value_take_component_inst (GValue* value, gpointer v_object);
gpointer value_get_component_inst (const GValue* value);
GType component_inst_get_type (void) G_GNUC_CONST;
gpointer property_item_ref (gpointer instance);
void property_item_unref (gpointer instance);
GParamSpec* param_spec_property_item (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_property_item (GValue* value, gpointer v_object);
void value_take_property_item (GValue* value, gpointer v_object);
gpointer value_get_property_item (const GValue* value);
GType property_item_get_type (void) G_GNUC_CONST;
GType property_set_get_type (void) G_GNUC_CONST;
gpointer compiled_circuit_ref (gpointer instance);
void compiled_circuit_unref (gpointer instance);
GParamSpec* param_spec_compiled_circuit (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_compiled_circuit (GValue* value, gpointer v_object);
void value_take_compiled_circuit (GValue* value, gpointer v_object);
gpointer value_get_compiled_circuit (const GValue* value);
GType compiled_circuit_get_type (void) G_GNUC_CONST;
gpointer connection_ref (gpointer instance);
void connection_unref (gpointer instance);
GParamSpec* param_spec_connection (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_connection (GValue* value, gpointer v_object);
void value_take_connection (GValue* value, gpointer v_object);
gpointer value_get_connection (const GValue* value);
GType connection_get_type (void) G_GNUC_CONST;
gpointer circuit_information_ref (gpointer instance);
void circuit_information_unref (gpointer instance);
GParamSpec* param_spec_circuit_information (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_circuit_information (GValue* value, gpointer v_object);
void value_take_circuit_information (GValue* value, gpointer v_object);
gpointer value_get_circuit_information (const GValue* value);
GType circuit_information_get_type (void) G_GNUC_CONST;
gpointer graphic_ref (gpointer instance);
void graphic_unref (gpointer instance);
GParamSpec* param_spec_graphic (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_graphic (GValue* value, gpointer v_object);
void value_take_graphic (GValue* value, gpointer v_object);
gpointer value_get_graphic (const GValue* value);
GType graphic_get_type (void) G_GNUC_CONST;
Tag* custom_component_def_resolve_tag_id (CustomComponentDef* self, gint tagID);
GType flow_get_type (void) G_GNUC_CONST;
GType pin_def_label_type_get_type (void) G_GNUC_CONST;
PinDef* pin_def_new (gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault);
PinDef* pin_def_construct (GType object_type, gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault);
gint custom_component_def_validate_interfaces (CustomComponentDef* self);
void basic_dialog_warning (GtkWindow* window, const gchar* text);
static void customiser_populate (Customiser* self);
void customiser_update_selection (Customiser* self);
static gboolean customiser_mouse_down (Customiser* self, GdkEventButton* event);
static gboolean _customiser_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean customiser_mouse_up (Customiser* self, GdkEventButton* event);
static gboolean _customiser_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean __lambda56_ (Customiser* self, cairo_t* context);
gboolean customiser_render_def (Customiser* self, cairo_t* passedDisplayContext);
static gboolean ___lambda56__gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self);
static gboolean __lambda57_ (Customiser* self);
static gboolean ___lambda57__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
static void __lambda58_ (Customiser* self);
static void ___lambda58__gtk_editable_changed (GtkEditable* _sender, gpointer self);
static void _customiser_update_selection_gtk_editable_changed (GtkEditable* _sender, gpointer self);
static void ___lambda59_ (Customiser* self);
static void ____lambda59__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
void customiser_update_label_type (Customiser* self);
static void _customiser_update_label_type_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void ___lambda60_ (Customiser* self);
static void ____lambda60__gtk_editable_changed (GtkEditable* _sender, gpointer self);
void customiser_update_bounds (Customiser* self);
static void _customiser_update_bounds_gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self);
static void __lambda61_ (Customiser* self);
void customiser_set_colour (Customiser* self);
static void ___lambda61__gtk_button_clicked (GtkButton* _sender, gpointer self);
void customiser_response_handler (Customiser* self, gint response_id);
static void _customiser_response_handler_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
void pin_def_set_position (PinDef* self, gint x, gint y, gint length, Direction direction);
void customiser_update_values (Customiser* self);
void customiser_run (Customiser* self);
ComponentDef* project_resolve_def_name (Project* self, const gchar* name);
void basic_dialog_error (GtkWindow* window, const gchar* text);
void component_def_render (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst, gboolean colourBackground);
void pin_def_render (PinDef* self, cairo_t* context, gboolean invert);
static void customiser_finalize (Customiser* obj);


/**
 * Start the customiser, setting the caller DesignerWindow, target 
 * custom component and its project.
 */
static gpointer _component_def_ref0 (gpointer self) {
	return self ? component_def_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _project_ref0 (gpointer self) {
	return self ? project_ref (self) : NULL;
}


Customiser* customiser_construct (GType object_type, DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project) {
	Customiser* self = NULL;
	CustomComponentDef* _tmp0_;
	CustomComponentDef* _tmp1_;
	DesignerWindow* _tmp2_;
	DesignerWindow* _tmp3_;
	Project* _tmp4_;
	Project* _tmp5_;
	CustomComponentDef* _tmp6_;
	gint _tmp7_ = 0;
	gint tagCount;
	CustomComponentDef* _tmp8_;
	gint _tmp9_;
	gint _tmp10_ = 0;
	CustomComponentDef* _tmp36_;
	gint _tmp37_ = 0;
	g_return_val_if_fail (customComponentDef != NULL, NULL);
	g_return_val_if_fail (project != NULL, NULL);
	self = (Customiser*) g_type_create_instance (object_type);
	_tmp0_ = customComponentDef;
	_tmp1_ = _component_def_ref0 (_tmp0_);
	_component_def_unref0 (self->priv->customComponentDef);
	self->priv->customComponentDef = _tmp1_;
	_tmp2_ = parent;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp3_;
	_tmp4_ = project;
	_tmp5_ = _project_ref0 (_tmp4_);
	_project_unref0 (self->priv->project);
	self->priv->project = _tmp5_;
	_tmp6_ = customComponentDef;
	_tmp7_ = custom_component_def_count_tags (_tmp6_);
	tagCount = _tmp7_;
	_tmp8_ = customComponentDef;
	_tmp9_ = tagCount;
	_tmp10_ = _tmp9_;
	((ComponentDef*) _tmp8_)->pinDefs = g_renew (PinDef*, ((ComponentDef*) _tmp8_)->pinDefs, _tmp9_);
	(_tmp10_ > ((ComponentDef*) _tmp8_)->pinDefs_length1) ? memset (((ComponentDef*) _tmp8_)->pinDefs + ((ComponentDef*) _tmp8_)->pinDefs_length1, 0, sizeof (PinDef*) * (_tmp10_ - ((ComponentDef*) _tmp8_)->pinDefs_length1)) : NULL;
	((ComponentDef*) _tmp8_)->pinDefs_length1 = _tmp10_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp11_;
			_tmp11_ = TRUE;
			while (TRUE) {
				gboolean _tmp12_;
				gint _tmp14_;
				gint _tmp15_;
				CustomComponentDef* _tmp16_;
				PinDef** _tmp17_;
				gint _tmp17__length1;
				gint _tmp18_;
				PinDef* _tmp19_;
				_tmp12_ = _tmp11_;
				if (!_tmp12_) {
					gint _tmp13_;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp11_ = FALSE;
				_tmp14_ = i;
				_tmp15_ = tagCount;
				if (!(_tmp14_ < _tmp15_)) {
					break;
				}
				_tmp16_ = customComponentDef;
				_tmp17_ = ((ComponentDef*) _tmp16_)->pinDefs;
				_tmp17__length1 = ((ComponentDef*) _tmp16_)->pinDefs_length1;
				_tmp18_ = i;
				_tmp19_ = _tmp17_[_tmp18_];
				if (_tmp19_ == NULL) {
					CustomComponentDef* _tmp20_;
					gint _tmp21_;
					Tag* _tmp22_ = NULL;
					Tag* resolvedTag;
					Tag* _tmp23_;
					_tmp20_ = customComponentDef;
					_tmp21_ = i;
					_tmp22_ = custom_component_def_resolve_tag_id (_tmp20_, _tmp21_);
					resolvedTag = _tmp22_;
					_tmp23_ = resolvedTag;
					if (_tmp23_ != NULL) {
						CustomComponentDef* _tmp24_;
						PinDef** _tmp25_;
						gint _tmp25__length1;
						gint _tmp26_;
						Tag* _tmp27_;
						Flow _tmp28_;
						PinDef* _tmp29_;
						PinDef* _tmp30_;
						_tmp24_ = customComponentDef;
						_tmp25_ = ((ComponentDef*) _tmp24_)->pinDefs;
						_tmp25__length1 = ((ComponentDef*) _tmp24_)->pinDefs_length1;
						_tmp26_ = i;
						_tmp27_ = resolvedTag;
						_tmp28_ = _tmp27_->flow;
						_tmp29_ = pin_def_new (0, 0, DIRECTION_RIGHT, _tmp28_, 0, FALSE, 1, 0, (gfloat) 0, "", PIN_DEF_LABEL_TYPE_NONE, TRUE, TRUE, TRUE);
						_pin_def_unref0 (_tmp25_[_tmp26_]);
						_tmp25_[_tmp26_] = _tmp29_;
						_tmp30_ = _tmp25_[_tmp26_];
					} else {
						CustomComponentDef* _tmp31_;
						PinDef** _tmp32_;
						gint _tmp32__length1;
						gint _tmp33_;
						PinDef* _tmp34_;
						PinDef* _tmp35_;
						_tmp31_ = customComponentDef;
						_tmp32_ = ((ComponentDef*) _tmp31_)->pinDefs;
						_tmp32__length1 = ((ComponentDef*) _tmp31_)->pinDefs_length1;
						_tmp33_ = i;
						_tmp34_ = pin_def_new (0, 0, DIRECTION_RIGHT, FLOW_NONE, 0, FALSE, 1, 0, (gfloat) 0, "", PIN_DEF_LABEL_TYPE_NONE, TRUE, TRUE, TRUE);
						_pin_def_unref0 (_tmp32_[_tmp33_]);
						_tmp32_[_tmp33_] = _tmp34_;
						_tmp35_ = _tmp32_[_tmp33_];
					}
					_tag_unref0 (resolvedTag);
				}
			}
		}
	}
	_tmp36_ = customComponentDef;
	_tmp37_ = custom_component_def_validate_interfaces (_tmp36_);
	if (_tmp37_ != 0) {
		basic_dialog_warning (NULL, "Warning:\n" \
"Could not associate all pins with interface tags. Make sure that all t" \
"ags have unique and sequential IDs starting with 0. You can cycle thro" \
"ugh the pins to check the associations.\n");
	}
	customiser_populate (self);
	customiser_update_selection (self);
	return self;
}


Customiser* customiser_new (DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project) {
	return customiser_construct (TYPE_CUSTOMISER, parent, customComponentDef, project);
}


/**
 * Create a new Gtk Dialog and populate it with widgets
 */
static gboolean _customiser_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = customiser_mouse_down (self, event);
	return result;
}


static gboolean _customiser_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = customiser_mouse_up (self, event);
	return result;
}


static gboolean __lambda56_ (Customiser* self, cairo_t* context) {
	gboolean result = FALSE;
	cairo_t* _tmp0_;
	g_return_val_if_fail (context != NULL, FALSE);
	_tmp0_ = context;
	customiser_render_def (self, _tmp0_);
	result = FALSE;
	return result;
}


static gboolean ___lambda56__gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self) {
	gboolean result;
	result = __lambda56_ (self, cr);
	return result;
}


static gboolean __lambda57_ (Customiser* self) {
	gboolean result = FALSE;
	_cairo_surface_destroy0 (self->priv->gridCache);
	self->priv->gridCache = NULL;
	customiser_render_def (self, NULL);
	result = FALSE;
	return result;
}


static gboolean ___lambda57__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = __lambda57_ (self);
	return result;
}


static void __lambda58_ (Customiser* self) {
	CustomComponentDef* _tmp0_;
	GtkEntry* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = self->priv->customComponentDef;
	_tmp1_ = self->priv->labelEntry;
	_tmp2_ = gtk_entry_get_text (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 (((ComponentDef*) _tmp0_)->label);
	((ComponentDef*) _tmp0_)->label = _tmp4_;
	customiser_render_def (self, NULL);
}


static void ___lambda58__gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	__lambda58_ (self);
}


static gpointer _pin_def_ref0 (gpointer self) {
	return self ? pin_def_ref (self) : NULL;
}


static void _customiser_update_selection_gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	customiser_update_selection (self);
}


static void ___lambda59_ (Customiser* self) {
	PinDef* _tmp0_;
	_tmp0_ = self->priv->selectedPin;
	if (_tmp0_ != NULL) {
		PinDef* _tmp1_;
		GtkCheckButton* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp1_ = self->priv->selectedPin;
		_tmp2_ = self->priv->requiredCheck;
		_tmp3_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp1_->required = _tmp4_;
	}
}


static void ____lambda59__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	___lambda59_ (self);
}


static void _customiser_update_label_type_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	customiser_update_label_type (self);
}


static void ___lambda60_ (Customiser* self) {
	PinDef* _tmp0_;
	_tmp0_ = self->priv->selectedPin;
	if (_tmp0_ != NULL) {
		PinDef* _tmp1_;
		GtkEntry* _tmp2_;
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		gchar* _tmp5_;
		_tmp1_ = self->priv->selectedPin;
		_tmp2_ = self->priv->pinLabelEntry;
		_tmp3_ = gtk_entry_get_text (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (_tmp1_->label);
		_tmp1_->label = _tmp5_;
		customiser_render_def (self, NULL);
	}
}


static void ____lambda60__gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	___lambda60_ (self);
}


static void _customiser_update_bounds_gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self) {
	customiser_update_bounds (self);
}


static void __lambda61_ (Customiser* self) {
	customiser_set_colour (self);
}


static void ___lambda61__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda61_ (self);
}


static void _customiser_response_handler_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	customiser_response_handler (self, response_id);
}


static void customiser_populate (Customiser* self) {
	DesignerWindow* _tmp0_;
	GtkDialog* _tmp1_;
	GtkDialog* _tmp2_;
	GtkBox* _tmp3_ = NULL;
	GtkBox* _tmp4_;
	GtkBox* content;
	GtkDialog* _tmp5_;
	GtkDialog* _tmp6_;
	GtkBox* _tmp7_;
	GtkBox* _tmp8_;
	GtkBox* _tmp9_;
	GtkEventBox* _tmp10_;
	GtkBox* _tmp11_;
	GtkEventBox* _tmp12_;
	GtkEventBox* _tmp13_;
	GtkEventBox* _tmp14_;
	GtkDrawingArea* _tmp15_;
	GtkEventBox* _tmp16_;
	GtkDrawingArea* _tmp17_;
	GtkDrawingArea* _tmp18_;
	GtkDrawingArea* _tmp19_;
	GtkBox* _tmp20_;
	GtkBox* _tmp21_;
	GtkBox* _tmp22_;
	GtkBox* _tmp23_;
	GtkBox* _tmp24_;
	GtkBox* _tmp25_;
	GtkLabel* _tmp26_;
	GtkBox* _tmp27_;
	GtkLabel* _tmp28_;
	GtkEntry* _tmp29_;
	GtkEntry* _tmp30_;
	CustomComponentDef* _tmp31_;
	const gchar* _tmp32_;
	GtkBox* _tmp33_;
	GtkEntry* _tmp34_;
	GtkBox* _tmp35_;
	GtkBox* _tmp36_;
	GtkBox* _tmp37_;
	GtkLabel* _tmp38_;
	GtkBox* _tmp39_;
	GtkLabel* _tmp40_;
	GtkEntry* _tmp41_;
	GtkEntry* _tmp42_;
	CustomComponentDef* _tmp43_;
	const gchar* _tmp44_;
	GtkBox* _tmp45_;
	GtkEntry* _tmp46_;
	GtkBox* _tmp47_;
	GtkBox* _tmp48_;
	GtkBox* _tmp49_;
	GtkLabel* _tmp50_;
	GtkBox* _tmp51_;
	GtkLabel* _tmp52_;
	GtkEntry* _tmp53_;
	GtkEntry* _tmp54_;
	CustomComponentDef* _tmp55_;
	const gchar* _tmp56_;
	GtkEntry* _tmp57_;
	GtkBox* _tmp58_;
	GtkEntry* _tmp59_;
	CustomComponentDef* _tmp60_;
	PinDef** _tmp61_;
	gint _tmp61__length1;
	GtkLabel* _tmp137_;
	GtkBox* _tmp138_;
	GtkLabel* _tmp139_;
	GtkGrid* _tmp140_;
	GtkBox* _tmp141_;
	GtkGrid* _tmp142_;
	GtkLabel* _tmp143_;
	GtkGrid* _tmp144_;
	GtkLabel* _tmp145_;
	gint _tmp146_;
	GtkSpinButton* _tmp147_;
	GtkSpinButton* _tmp148_;
	CustomComponentDef* _tmp149_;
	gint _tmp150_;
	GtkSpinButton* _tmp151_;
	GtkGrid* _tmp152_;
	GtkSpinButton* _tmp153_;
	GtkLabel* _tmp154_;
	GtkGrid* _tmp155_;
	GtkLabel* _tmp156_;
	gint _tmp157_;
	GtkSpinButton* _tmp158_;
	GtkSpinButton* _tmp159_;
	CustomComponentDef* _tmp160_;
	gint _tmp161_;
	GtkSpinButton* _tmp162_;
	GtkGrid* _tmp163_;
	GtkSpinButton* _tmp164_;
	GtkLabel* _tmp165_;
	GtkGrid* _tmp166_;
	GtkLabel* _tmp167_;
	gint _tmp168_;
	GtkSpinButton* _tmp169_;
	GtkSpinButton* _tmp170_;
	CustomComponentDef* _tmp171_;
	gint _tmp172_;
	GtkSpinButton* _tmp173_;
	GtkGrid* _tmp174_;
	GtkSpinButton* _tmp175_;
	GtkLabel* _tmp176_;
	GtkGrid* _tmp177_;
	GtkLabel* _tmp178_;
	gint _tmp179_;
	GtkSpinButton* _tmp180_;
	GtkSpinButton* _tmp181_;
	CustomComponentDef* _tmp182_;
	gint _tmp183_;
	GtkSpinButton* _tmp184_;
	GtkGrid* _tmp185_;
	GtkSpinButton* _tmp186_;
	GtkButton* _tmp187_;
	GtkButton* _tmp188_;
	GtkBox* _tmp189_;
	GtkButton* _tmp190_;
	GtkDialog* _tmp191_;
	GtkButton* _tmp192_;
	GtkDialog* _tmp193_;
	GtkButton* _tmp194_;
	GtkDialog* _tmp195_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->parent;
	_tmp1_ = (GtkDialog*) gtk_dialog_new_with_buttons ("Customise Component", (GtkWindow*) _tmp0_, GTK_DIALOG_MODAL, NULL);
	g_object_ref_sink (_tmp1_);
	_g_object_unref0 (self->priv->dialog);
	self->priv->dialog = _tmp1_;
	_tmp2_ = self->priv->dialog;
	_tmp3_ = gtk_dialog_get_content_area (_tmp2_);
	_tmp4_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, GTK_TYPE_BOX) ? ((GtkBox*) _tmp3_) : NULL);
	content = _tmp4_;
	_tmp5_ = self->priv->dialog;
	gtk_window_set_default_size ((GtkWindow*) _tmp5_, 600, 200);
	_tmp6_ = self->priv->dialog;
	gtk_container_set_border_width ((GtkContainer*) _tmp6_, (guint) 1);
	_tmp7_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
	g_object_ref_sink (_tmp7_);
	_g_object_unref0 (self->priv->layoutHBox);
	self->priv->layoutHBox = _tmp7_;
	_tmp8_ = content;
	_tmp9_ = self->priv->layoutHBox;
	gtk_box_pack_start (_tmp8_, (GtkWidget*) _tmp9_, TRUE, TRUE, (guint) 1);
	_tmp10_ = (GtkEventBox*) gtk_event_box_new ();
	g_object_ref_sink (_tmp10_);
	_g_object_unref0 (self->priv->controller);
	self->priv->controller = _tmp10_;
	_tmp11_ = self->priv->layoutHBox;
	_tmp12_ = self->priv->controller;
	gtk_box_pack_start (_tmp11_, (GtkWidget*) _tmp12_, TRUE, TRUE, (guint) 1);
	_tmp13_ = self->priv->controller;
	g_signal_connect ((GtkWidget*) _tmp13_, "button-press-event", (GCallback) _customiser_mouse_down_gtk_widget_button_press_event, self);
	_tmp14_ = self->priv->controller;
	g_signal_connect ((GtkWidget*) _tmp14_, "button-release-event", (GCallback) _customiser_mouse_up_gtk_widget_button_release_event, self);
	_tmp15_ = (GtkDrawingArea*) gtk_drawing_area_new ();
	g_object_ref_sink (_tmp15_);
	_g_object_unref0 (self->priv->display);
	self->priv->display = _tmp15_;
	_tmp16_ = self->priv->controller;
	_tmp17_ = self->priv->display;
	gtk_container_add ((GtkContainer*) _tmp16_, (GtkWidget*) _tmp17_);
	_tmp18_ = self->priv->display;
	g_signal_connect ((GtkWidget*) _tmp18_, "draw", (GCallback) ___lambda56__gtk_widget_draw, self);
	_tmp19_ = self->priv->display;
	g_signal_connect ((GtkWidget*) _tmp19_, "configure-event", (GCallback) ___lambda57__gtk_widget_configure_event, self);
	_tmp20_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
	g_object_ref_sink (_tmp20_);
	_g_object_unref0 (self->priv->controlsVBox);
	self->priv->controlsVBox = _tmp20_;
	_tmp21_ = self->priv->layoutHBox;
	_tmp22_ = self->priv->controlsVBox;
	gtk_box_pack_start (_tmp21_, (GtkWidget*) _tmp22_, FALSE, TRUE, (guint) 1);
	_tmp23_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
	g_object_ref_sink (_tmp23_);
	_g_object_unref0 (self->priv->nameHBox);
	self->priv->nameHBox = _tmp23_;
	_tmp24_ = self->priv->controlsVBox;
	_tmp25_ = self->priv->nameHBox;
	gtk_box_pack_start (_tmp24_, (GtkWidget*) _tmp25_, FALSE, TRUE, (guint) 1);
	_tmp26_ = (GtkLabel*) gtk_label_new ("Name:");
	g_object_ref_sink (_tmp26_);
	_g_object_unref0 (self->priv->nameLabel);
	self->priv->nameLabel = _tmp26_;
	_tmp27_ = self->priv->nameHBox;
	_tmp28_ = self->priv->nameLabel;
	gtk_box_pack_start (_tmp27_, (GtkWidget*) _tmp28_, FALSE, TRUE, (guint) 1);
	_tmp29_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp29_);
	_g_object_unref0 (self->priv->nameEntry);
	self->priv->nameEntry = _tmp29_;
	_tmp30_ = self->priv->nameEntry;
	_tmp31_ = self->priv->customComponentDef;
	_tmp32_ = ((ComponentDef*) _tmp31_)->name;
	gtk_entry_set_text (_tmp30_, _tmp32_);
	_tmp33_ = self->priv->nameHBox;
	_tmp34_ = self->priv->nameEntry;
	gtk_box_pack_start (_tmp33_, (GtkWidget*) _tmp34_, TRUE, TRUE, (guint) 1);
	_tmp35_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
	g_object_ref_sink (_tmp35_);
	_g_object_unref0 (self->priv->descriptionHBox);
	self->priv->descriptionHBox = _tmp35_;
	_tmp36_ = self->priv->controlsVBox;
	_tmp37_ = self->priv->descriptionHBox;
	gtk_box_pack_start (_tmp36_, (GtkWidget*) _tmp37_, FALSE, TRUE, (guint) 1);
	_tmp38_ = (GtkLabel*) gtk_label_new ("Description:");
	g_object_ref_sink (_tmp38_);
	_g_object_unref0 (self->priv->descriptionLabel);
	self->priv->descriptionLabel = _tmp38_;
	_tmp39_ = self->priv->descriptionHBox;
	_tmp40_ = self->priv->descriptionLabel;
	gtk_box_pack_start (_tmp39_, (GtkWidget*) _tmp40_, FALSE, TRUE, (guint) 1);
	_tmp41_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp41_);
	_g_object_unref0 (self->priv->descriptionEntry);
	self->priv->descriptionEntry = _tmp41_;
	_tmp42_ = self->priv->descriptionEntry;
	_tmp43_ = self->priv->customComponentDef;
	_tmp44_ = ((ComponentDef*) _tmp43_)->description;
	gtk_entry_set_text (_tmp42_, _tmp44_);
	_tmp45_ = self->priv->descriptionHBox;
	_tmp46_ = self->priv->descriptionEntry;
	gtk_box_pack_start (_tmp45_, (GtkWidget*) _tmp46_, TRUE, TRUE, (guint) 1);
	_tmp47_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
	g_object_ref_sink (_tmp47_);
	_g_object_unref0 (self->priv->labelHBox);
	self->priv->labelHBox = _tmp47_;
	_tmp48_ = self->priv->controlsVBox;
	_tmp49_ = self->priv->labelHBox;
	gtk_box_pack_start (_tmp48_, (GtkWidget*) _tmp49_, FALSE, TRUE, (guint) 1);
	_tmp50_ = (GtkLabel*) gtk_label_new ("Box Label:");
	g_object_ref_sink (_tmp50_);
	_g_object_unref0 (self->priv->labelLabel);
	self->priv->labelLabel = _tmp50_;
	_tmp51_ = self->priv->labelHBox;
	_tmp52_ = self->priv->labelLabel;
	gtk_box_pack_start (_tmp51_, (GtkWidget*) _tmp52_, FALSE, TRUE, (guint) 1);
	_tmp53_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp53_);
	_g_object_unref0 (self->priv->labelEntry);
	self->priv->labelEntry = _tmp53_;
	_tmp54_ = self->priv->labelEntry;
	_tmp55_ = self->priv->customComponentDef;
	_tmp56_ = ((ComponentDef*) _tmp55_)->label;
	gtk_entry_set_text (_tmp54_, _tmp56_);
	_tmp57_ = self->priv->labelEntry;
	g_signal_connect ((GtkEditable*) _tmp57_, "changed", (GCallback) ___lambda58__gtk_editable_changed, self);
	_tmp58_ = self->priv->labelHBox;
	_tmp59_ = self->priv->labelEntry;
	gtk_box_pack_start (_tmp58_, (GtkWidget*) _tmp59_, TRUE, TRUE, (guint) 1);
	_tmp60_ = self->priv->customComponentDef;
	_tmp61_ = ((ComponentDef*) _tmp60_)->pinDefs;
	_tmp61__length1 = ((ComponentDef*) _tmp60_)->pinDefs_length1;
	if (_tmp61__length1 > 0) {
		CustomComponentDef* _tmp62_;
		PinDef** _tmp63_;
		gint _tmp63__length1;
		gint _tmp64_;
		PinDef* _tmp65_;
		PinDef* _tmp66_;
		CustomComponentDef* _tmp67_;
		gint _tmp68_;
		Tag* _tmp69_ = NULL;
		GtkBox* _tmp70_;
		GtkBox* _tmp71_;
		GtkBox* _tmp72_;
		GtkLabel* _tmp73_;
		GtkBox* _tmp74_;
		GtkLabel* _tmp75_;
		CustomComponentDef* _tmp76_;
		PinDef** _tmp77_;
		gint _tmp77__length1;
		GtkSpinButton* _tmp78_;
		GtkSpinButton* _tmp79_;
		GtkSpinButton* _tmp80_;
		GtkBox* _tmp81_;
		GtkSpinButton* _tmp82_;
		Tag* _tmp83_;
		GtkBox* _tmp90_;
		GtkLabel* _tmp91_;
		GtkCheckButton* _tmp92_;
		GtkCheckButton* _tmp93_;
		PinDef* _tmp94_;
		gboolean _tmp95_;
		GtkCheckButton* _tmp96_;
		GtkBox* _tmp97_;
		GtkCheckButton* _tmp98_;
		GtkBox* _tmp99_;
		GtkBox* _tmp100_;
		GtkBox* _tmp101_;
		GtkLabel* _tmp102_;
		GtkBox* _tmp103_;
		GtkLabel* _tmp104_;
		GtkRadioButton* _tmp105_;
		GtkRadioButton* _tmp106_;
		GtkBox* _tmp107_;
		GtkRadioButton* _tmp108_;
		GtkRadioButton* _tmp109_;
		GtkRadioButton* _tmp110_;
		GtkRadioButton* _tmp111_;
		GtkBox* _tmp112_;
		GtkRadioButton* _tmp113_;
		GtkRadioButton* _tmp114_;
		GtkRadioButton* _tmp115_;
		GtkRadioButton* _tmp116_;
		GtkBox* _tmp117_;
		GtkRadioButton* _tmp118_;
		GtkRadioButton* _tmp119_;
		GtkRadioButton* _tmp120_;
		GtkRadioButton* _tmp121_;
		GtkBox* _tmp122_;
		GtkRadioButton* _tmp123_;
		GtkBox* _tmp124_;
		GtkBox* _tmp125_;
		GtkBox* _tmp126_;
		GtkLabel* _tmp127_;
		GtkBox* _tmp128_;
		GtkLabel* _tmp129_;
		GtkEntry* _tmp130_;
		GtkEntry* _tmp131_;
		PinDef* _tmp132_;
		const gchar* _tmp133_;
		GtkEntry* _tmp134_;
		GtkBox* _tmp135_;
		GtkEntry* _tmp136_;
		self->priv->selectedPinID = 0;
		_tmp62_ = self->priv->customComponentDef;
		_tmp63_ = ((ComponentDef*) _tmp62_)->pinDefs;
		_tmp63__length1 = ((ComponentDef*) _tmp62_)->pinDefs_length1;
		_tmp64_ = self->priv->selectedPinID;
		_tmp65_ = _tmp63_[_tmp64_];
		_tmp66_ = _pin_def_ref0 (_tmp65_);
		_pin_def_unref0 (self->priv->selectedPin);
		self->priv->selectedPin = _tmp66_;
		_tmp67_ = self->priv->customComponentDef;
		_tmp68_ = self->priv->selectedPinID;
		_tmp69_ = custom_component_def_resolve_tag_id (_tmp67_, _tmp68_);
		_tag_unref0 (self->priv->tag);
		self->priv->tag = _tmp69_;
		_tmp70_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
		g_object_ref_sink (_tmp70_);
		_g_object_unref0 (self->priv->pinHBox);
		self->priv->pinHBox = _tmp70_;
		_tmp71_ = self->priv->controlsVBox;
		_tmp72_ = self->priv->pinHBox;
		gtk_box_pack_start (_tmp71_, (GtkWidget*) _tmp72_, FALSE, TRUE, (guint) 1);
		_tmp73_ = (GtkLabel*) gtk_label_new ("Pin Select:");
		g_object_ref_sink (_tmp73_);
		_g_object_unref0 (self->priv->pinLabel);
		self->priv->pinLabel = _tmp73_;
		_tmp74_ = self->priv->pinHBox;
		_tmp75_ = self->priv->pinLabel;
		gtk_box_pack_start (_tmp74_, (GtkWidget*) _tmp75_, FALSE, TRUE, (guint) 1);
		_tmp76_ = self->priv->customComponentDef;
		_tmp77_ = ((ComponentDef*) _tmp76_)->pinDefs;
		_tmp77__length1 = ((ComponentDef*) _tmp76_)->pinDefs_length1;
		_tmp78_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) (_tmp77__length1 - 1), (gdouble) 1);
		g_object_ref_sink (_tmp78_);
		_g_object_unref0 (self->priv->pinSpinButton);
		self->priv->pinSpinButton = _tmp78_;
		_tmp79_ = self->priv->pinSpinButton;
		gtk_spin_button_set_value (_tmp79_, (gdouble) 0);
		_tmp80_ = self->priv->pinSpinButton;
		g_signal_connect ((GtkEditable*) _tmp80_, "changed", (GCallback) _customiser_update_selection_gtk_editable_changed, self);
		_tmp81_ = self->priv->pinHBox;
		_tmp82_ = self->priv->pinSpinButton;
		gtk_box_pack_start (_tmp81_, (GtkWidget*) _tmp82_, TRUE, TRUE, (guint) 1);
		_tmp83_ = self->priv->tag;
		if (_tmp83_ != NULL) {
			Tag* _tmp84_;
			const gchar* _tmp85_;
			gchar* _tmp86_;
			gchar* _tmp87_;
			GtkLabel* _tmp88_;
			_tmp84_ = self->priv->tag;
			_tmp85_ = _tmp84_->text;
			_tmp86_ = g_strconcat ("Maps to: ", _tmp85_, NULL);
			_tmp87_ = _tmp86_;
			_tmp88_ = (GtkLabel*) gtk_label_new (_tmp87_);
			g_object_ref_sink (_tmp88_);
			_g_object_unref0 (self->priv->tagNameLabel);
			self->priv->tagNameLabel = _tmp88_;
			_g_free0 (_tmp87_);
		} else {
			GtkLabel* _tmp89_;
			_tmp89_ = (GtkLabel*) gtk_label_new ("There is no matching tag!");
			g_object_ref_sink (_tmp89_);
			_g_object_unref0 (self->priv->tagNameLabel);
			self->priv->tagNameLabel = _tmp89_;
		}
		_tmp90_ = self->priv->controlsVBox;
		_tmp91_ = self->priv->tagNameLabel;
		gtk_box_pack_start (_tmp90_, (GtkWidget*) _tmp91_, FALSE, TRUE, (guint) 1);
		_tmp92_ = (GtkCheckButton*) gtk_check_button_new_with_label ("Connection Required");
		g_object_ref_sink (_tmp92_);
		_g_object_unref0 (self->priv->requiredCheck);
		self->priv->requiredCheck = _tmp92_;
		_tmp93_ = self->priv->requiredCheck;
		_tmp94_ = self->priv->selectedPin;
		_tmp95_ = _tmp94_->required;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp93_, _tmp95_);
		_tmp96_ = self->priv->requiredCheck;
		g_signal_connect ((GtkToggleButton*) _tmp96_, "toggled", (GCallback) ____lambda59__gtk_toggle_button_toggled, self);
		_tmp97_ = self->priv->controlsVBox;
		_tmp98_ = self->priv->requiredCheck;
		gtk_box_pack_start (_tmp97_, (GtkWidget*) _tmp98_, FALSE, TRUE, (guint) 1);
		_tmp99_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
		g_object_ref_sink (_tmp99_);
		_g_object_unref0 (self->priv->labelTypeVBox);
		self->priv->labelTypeVBox = _tmp99_;
		_tmp100_ = self->priv->controlsVBox;
		_tmp101_ = self->priv->labelTypeVBox;
		gtk_box_pack_start (_tmp100_, (GtkWidget*) _tmp101_, FALSE, TRUE, (guint) 1);
		_tmp102_ = (GtkLabel*) gtk_label_new ("Pin labels can be text or a symbol:");
		g_object_ref_sink (_tmp102_);
		_g_object_unref0 (self->priv->labelTypeLabel);
		self->priv->labelTypeLabel = _tmp102_;
		_tmp103_ = self->priv->labelTypeVBox;
		_tmp104_ = self->priv->labelTypeLabel;
		gtk_box_pack_start (_tmp103_, (GtkWidget*) _tmp104_, FALSE, TRUE, (guint) 1);
		_tmp105_ = (GtkRadioButton*) gtk_radio_button_new_with_label (NULL, "No Label");
		g_object_ref_sink (_tmp105_);
		_g_object_unref0 (self->priv->labelTypeNoneRadio);
		self->priv->labelTypeNoneRadio = _tmp105_;
		_tmp106_ = self->priv->labelTypeNoneRadio;
		g_signal_connect ((GtkToggleButton*) _tmp106_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp107_ = self->priv->labelTypeVBox;
		_tmp108_ = self->priv->labelTypeNoneRadio;
		gtk_box_pack_start (_tmp107_, (GtkWidget*) _tmp108_, FALSE, TRUE, (guint) 1);
		_tmp109_ = self->priv->labelTypeNoneRadio;
		_tmp110_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp109_, "Text");
		g_object_ref_sink (_tmp110_);
		_g_object_unref0 (self->priv->labelTypeTextRadio);
		self->priv->labelTypeTextRadio = _tmp110_;
		_tmp111_ = self->priv->labelTypeTextRadio;
		g_signal_connect ((GtkToggleButton*) _tmp111_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp112_ = self->priv->labelTypeVBox;
		_tmp113_ = self->priv->labelTypeTextRadio;
		gtk_box_pack_start (_tmp112_, (GtkWidget*) _tmp113_, FALSE, TRUE, (guint) 1);
		_tmp114_ = self->priv->labelTypeNoneRadio;
		_tmp115_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp114_, "Text With Bar");
		g_object_ref_sink (_tmp115_);
		_g_object_unref0 (self->priv->labelTypeTextBarRadio);
		self->priv->labelTypeTextBarRadio = _tmp115_;
		_tmp116_ = self->priv->labelTypeTextBarRadio;
		g_signal_connect ((GtkToggleButton*) _tmp116_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp117_ = self->priv->labelTypeVBox;
		_tmp118_ = self->priv->labelTypeTextBarRadio;
		gtk_box_pack_start (_tmp117_, (GtkWidget*) _tmp118_, FALSE, TRUE, (guint) 1);
		_tmp119_ = self->priv->labelTypeNoneRadio;
		_tmp120_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp119_, "Clock");
		g_object_ref_sink (_tmp120_);
		_g_object_unref0 (self->priv->labelTypeClockRadio);
		self->priv->labelTypeClockRadio = _tmp120_;
		_tmp121_ = self->priv->labelTypeClockRadio;
		g_signal_connect ((GtkToggleButton*) _tmp121_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp122_ = self->priv->labelTypeVBox;
		_tmp123_ = self->priv->labelTypeClockRadio;
		gtk_box_pack_start (_tmp122_, (GtkWidget*) _tmp123_, FALSE, TRUE, (guint) 1);
		_tmp124_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
		g_object_ref_sink (_tmp124_);
		_g_object_unref0 (self->priv->pinLabelHBox);
		self->priv->pinLabelHBox = _tmp124_;
		_tmp125_ = self->priv->controlsVBox;
		_tmp126_ = self->priv->pinLabelHBox;
		gtk_box_pack_start (_tmp125_, (GtkWidget*) _tmp126_, FALSE, TRUE, (guint) 1);
		_tmp127_ = (GtkLabel*) gtk_label_new ("Pin Label:");
		g_object_ref_sink (_tmp127_);
		_g_object_unref0 (self->priv->pinLabelLabel);
		self->priv->pinLabelLabel = _tmp127_;
		_tmp128_ = self->priv->pinLabelHBox;
		_tmp129_ = self->priv->pinLabelLabel;
		gtk_box_pack_start (_tmp128_, (GtkWidget*) _tmp129_, FALSE, TRUE, (guint) 1);
		_tmp130_ = (GtkEntry*) gtk_entry_new ();
		g_object_ref_sink (_tmp130_);
		_g_object_unref0 (self->priv->pinLabelEntry);
		self->priv->pinLabelEntry = _tmp130_;
		_tmp131_ = self->priv->pinLabelEntry;
		_tmp132_ = self->priv->selectedPin;
		_tmp133_ = _tmp132_->label;
		gtk_entry_set_text (_tmp131_, _tmp133_);
		_tmp134_ = self->priv->pinLabelEntry;
		g_signal_connect ((GtkEditable*) _tmp134_, "changed", (GCallback) ____lambda60__gtk_editable_changed, self);
		_tmp135_ = self->priv->pinLabelHBox;
		_tmp136_ = self->priv->pinLabelEntry;
		gtk_box_pack_start (_tmp135_, (GtkWidget*) _tmp136_, TRUE, TRUE, (guint) 1);
	}
	_tmp137_ = (GtkLabel*) gtk_label_new ("Bounds define the visual size:");
	g_object_ref_sink (_tmp137_);
	_g_object_unref0 (self->priv->boundsLabel);
	self->priv->boundsLabel = _tmp137_;
	_tmp138_ = self->priv->controlsVBox;
	_tmp139_ = self->priv->boundsLabel;
	gtk_box_pack_start (_tmp138_, (GtkWidget*) _tmp139_, FALSE, TRUE, (guint) 1);
	_tmp140_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp140_);
	_g_object_unref0 (self->priv->boundsGrid);
	self->priv->boundsGrid = _tmp140_;
	_tmp141_ = self->priv->controlsVBox;
	_tmp142_ = self->priv->boundsGrid;
	gtk_box_pack_start (_tmp141_, (GtkWidget*) _tmp142_, FALSE, TRUE, (guint) 1);
	_tmp143_ = (GtkLabel*) gtk_label_new ("Right:");
	g_object_ref_sink (_tmp143_);
	_g_object_unref0 (self->priv->rightBoundLabel);
	self->priv->rightBoundLabel = _tmp143_;
	_tmp144_ = self->priv->boundsGrid;
	_tmp145_ = self->priv->rightBoundLabel;
	gtk_grid_attach (_tmp144_, (GtkWidget*) _tmp145_, 0, 0, 1, 1);
	_tmp146_ = G_MAXINT;
	_tmp147_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) _tmp146_, (gdouble) 5);
	g_object_ref_sink (_tmp147_);
	_g_object_unref0 (self->priv->rightBoundSpinButton);
	self->priv->rightBoundSpinButton = _tmp147_;
	_tmp148_ = self->priv->rightBoundSpinButton;
	_tmp149_ = self->priv->customComponentDef;
	_tmp150_ = ((ComponentDef*) _tmp149_)->rightBound;
	gtk_spin_button_set_value (_tmp148_, (gdouble) _tmp150_);
	_tmp151_ = self->priv->rightBoundSpinButton;
	g_signal_connect (_tmp151_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp152_ = self->priv->boundsGrid;
	_tmp153_ = self->priv->rightBoundSpinButton;
	gtk_grid_attach (_tmp152_, (GtkWidget*) _tmp153_, 1, 0, 1, 1);
	_tmp154_ = (GtkLabel*) gtk_label_new ("Down:");
	g_object_ref_sink (_tmp154_);
	_g_object_unref0 (self->priv->downBoundLabel);
	self->priv->downBoundLabel = _tmp154_;
	_tmp155_ = self->priv->boundsGrid;
	_tmp156_ = self->priv->downBoundLabel;
	gtk_grid_attach (_tmp155_, (GtkWidget*) _tmp156_, 0, 1, 1, 1);
	_tmp157_ = G_MAXINT;
	_tmp158_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) _tmp157_, (gdouble) 5);
	g_object_ref_sink (_tmp158_);
	_g_object_unref0 (self->priv->downBoundSpinButton);
	self->priv->downBoundSpinButton = _tmp158_;
	_tmp159_ = self->priv->downBoundSpinButton;
	_tmp160_ = self->priv->customComponentDef;
	_tmp161_ = ((ComponentDef*) _tmp160_)->downBound;
	gtk_spin_button_set_value (_tmp159_, (gdouble) _tmp161_);
	_tmp162_ = self->priv->downBoundSpinButton;
	g_signal_connect (_tmp162_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp163_ = self->priv->boundsGrid;
	_tmp164_ = self->priv->downBoundSpinButton;
	gtk_grid_attach (_tmp163_, (GtkWidget*) _tmp164_, 1, 1, 1, 1);
	_tmp165_ = (GtkLabel*) gtk_label_new ("Left:");
	g_object_ref_sink (_tmp165_);
	_g_object_unref0 (self->priv->leftBoundLabel);
	self->priv->leftBoundLabel = _tmp165_;
	_tmp166_ = self->priv->boundsGrid;
	_tmp167_ = self->priv->leftBoundLabel;
	gtk_grid_attach (_tmp166_, (GtkWidget*) _tmp167_, 0, 2, 1, 1);
	_tmp168_ = G_MININT;
	_tmp169_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) _tmp168_, (gdouble) 0, (gdouble) 5);
	g_object_ref_sink (_tmp169_);
	_g_object_unref0 (self->priv->leftBoundSpinButton);
	self->priv->leftBoundSpinButton = _tmp169_;
	_tmp170_ = self->priv->leftBoundSpinButton;
	_tmp171_ = self->priv->customComponentDef;
	_tmp172_ = ((ComponentDef*) _tmp171_)->leftBound;
	gtk_spin_button_set_value (_tmp170_, (gdouble) _tmp172_);
	_tmp173_ = self->priv->leftBoundSpinButton;
	g_signal_connect (_tmp173_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp174_ = self->priv->boundsGrid;
	_tmp175_ = self->priv->leftBoundSpinButton;
	gtk_grid_attach (_tmp174_, (GtkWidget*) _tmp175_, 1, 2, 1, 1);
	_tmp176_ = (GtkLabel*) gtk_label_new ("Up:");
	g_object_ref_sink (_tmp176_);
	_g_object_unref0 (self->priv->upBoundLabel);
	self->priv->upBoundLabel = _tmp176_;
	_tmp177_ = self->priv->boundsGrid;
	_tmp178_ = self->priv->upBoundLabel;
	gtk_grid_attach (_tmp177_, (GtkWidget*) _tmp178_, 0, 3, 1, 1);
	_tmp179_ = G_MININT;
	_tmp180_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) _tmp179_, (gdouble) 0, (gdouble) 5);
	g_object_ref_sink (_tmp180_);
	_g_object_unref0 (self->priv->upBoundSpinButton);
	self->priv->upBoundSpinButton = _tmp180_;
	_tmp181_ = self->priv->upBoundSpinButton;
	_tmp182_ = self->priv->customComponentDef;
	_tmp183_ = ((ComponentDef*) _tmp182_)->upBound;
	gtk_spin_button_set_value (_tmp181_, (gdouble) _tmp183_);
	_tmp184_ = self->priv->upBoundSpinButton;
	g_signal_connect (_tmp184_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp185_ = self->priv->boundsGrid;
	_tmp186_ = self->priv->upBoundSpinButton;
	gtk_grid_attach (_tmp185_, (GtkWidget*) _tmp186_, 1, 3, 1, 1);
	_tmp187_ = (GtkButton*) gtk_button_new_with_label ("Background Colour");
	g_object_ref_sink (_tmp187_);
	_g_object_unref0 (self->priv->colourButton);
	self->priv->colourButton = _tmp187_;
	_tmp188_ = self->priv->colourButton;
	g_signal_connect (_tmp188_, "clicked", (GCallback) ___lambda61__gtk_button_clicked, self);
	_tmp189_ = self->priv->controlsVBox;
	_tmp190_ = self->priv->colourButton;
	gtk_box_pack_start (_tmp189_, (GtkWidget*) _tmp190_, FALSE, TRUE, (guint) 1);
	_tmp191_ = self->priv->dialog;
	g_signal_connect (_tmp191_, "response", (GCallback) _customiser_response_handler_gtk_dialog_response, self);
	_tmp192_ = (GtkButton*) gtk_button_new_with_label ("Close");
	g_object_ref_sink (_tmp192_);
	_g_object_unref0 (self->priv->closeButton);
	self->priv->closeButton = _tmp192_;
	_tmp193_ = self->priv->dialog;
	_tmp194_ = self->priv->closeButton;
	gtk_dialog_add_action_widget (_tmp193_, (GtkWidget*) _tmp194_, (gint) GTK_RESPONSE_CLOSE);
	_tmp195_ = self->priv->dialog;
	gtk_widget_show_all ((GtkWidget*) _tmp195_);
	_g_object_unref0 (content);
}


/**
 * Signal handler for the Gtk.EventBox. Handles a mouse button down
 * event on the display area.
 */
static gboolean customiser_mouse_down (Customiser* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GdkEventButton _tmp0_;
	gdouble _tmp1_;
	GdkEventButton _tmp2_;
	gdouble _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.x;
	self->priv->xMouseStart = (gint) _tmp1_;
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.y;
	self->priv->yMouseStart = (gint) _tmp3_;
	result = FALSE;
	return result;
}


/**
 * Signal handler for the Gtk.EventBox. Handles a mouse button up
 * event on the display area. This is when an action is taken.
 * 
 * Only changes the pins' positions.
 */
static gboolean customiser_mouse_up (Customiser* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GtkAllocation areaAllocation = {0};
	GtkEventBox* _tmp0_;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_;
	gint _tmp3_;
	gint width;
	GtkAllocation _tmp4_;
	gint _tmp5_;
	gint height;
	DesignerWindow* _tmp6_;
	gint _tmp7_;
	gint halfGridSize;
	gint _tmp8_;
	gint xCentre;
	gint _tmp9_;
	gint yCentre;
	gint _tmp10_;
	gint _tmp11_;
	gint xStart;
	gint _tmp12_;
	gint _tmp13_;
	gint yStart;
	GdkEventButton _tmp14_;
	gdouble _tmp15_;
	gint _tmp16_;
	gint xEnd;
	GdkEventButton _tmp17_;
	gdouble _tmp18_;
	gint _tmp19_;
	gint yEnd;
	gint _tmp20_;
	gint xBoardStart;
	gint _tmp21_;
	gint yBoardStart;
	gint _tmp22_;
	gint xBoardEnd;
	gint _tmp23_;
	gint yBoardEnd;
	gint _tmp24_ = 0;
	gint _tmp25_;
	gint _tmp28_;
	gint _tmp29_;
	gint _tmp30_ = 0;
	gint _tmp31_;
	gint _tmp34_;
	gint _tmp35_;
	gint _tmp36_;
	DesignerWindow* _tmp37_;
	gint _tmp38_;
	DesignerWindow* _tmp39_;
	gint _tmp40_;
	gint _tmp41_;
	DesignerWindow* _tmp42_;
	gint _tmp43_;
	DesignerWindow* _tmp44_;
	gint _tmp45_;
	gint _tmp46_ = 0;
	gint _tmp47_;
	gint _tmp50_;
	gint _tmp51_;
	gint _tmp52_ = 0;
	gint _tmp53_;
	gint _tmp56_;
	gint _tmp57_;
	gint _tmp58_;
	DesignerWindow* _tmp59_;
	gint _tmp60_;
	DesignerWindow* _tmp61_;
	gint _tmp62_;
	gint _tmp63_;
	DesignerWindow* _tmp64_;
	gint _tmp65_;
	DesignerWindow* _tmp66_;
	gint _tmp67_;
	FILE* _tmp68_;
	gint _tmp69_;
	gint _tmp70_;
	gint _tmp71_;
	gint _tmp72_;
	CustomComponentDef* _tmp73_;
	gint _tmp74_;
	gint rightBound;
	CustomComponentDef* _tmp75_;
	gint _tmp76_;
	gint downBound;
	CustomComponentDef* _tmp77_;
	gint _tmp78_;
	gint leftBound;
	CustomComponentDef* _tmp79_;
	gint _tmp80_;
	gint upBound;
	gboolean _tmp81_ = FALSE;
	gint _tmp82_;
	gint _tmp83_;
	gboolean _tmp86_;
	gboolean _tmp101_ = FALSE;
	gint _tmp102_;
	gint _tmp103_;
	gboolean _tmp106_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->controller;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	areaAllocation = _tmp1_;
	_tmp2_ = areaAllocation;
	_tmp3_ = _tmp2_.width;
	width = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.height;
	height = _tmp5_;
	_tmp6_ = self->priv->parent;
	_tmp7_ = _tmp6_->gridSize;
	halfGridSize = _tmp7_ / 2;
	_tmp8_ = width;
	xCentre = _tmp8_ / 2;
	_tmp9_ = height;
	yCentre = _tmp9_ / 2;
	_tmp10_ = self->priv->xMouseStart;
	_tmp11_ = xCentre;
	xStart = _tmp10_ - _tmp11_;
	_tmp12_ = self->priv->yMouseStart;
	_tmp13_ = yCentre;
	yStart = _tmp12_ - _tmp13_;
	_tmp14_ = *event;
	_tmp15_ = _tmp14_.x;
	_tmp16_ = xCentre;
	xEnd = ((gint) _tmp15_) - _tmp16_;
	_tmp17_ = *event;
	_tmp18_ = _tmp17_.y;
	_tmp19_ = yCentre;
	yEnd = ((gint) _tmp18_) - _tmp19_;
	_tmp20_ = xStart;
	xBoardStart = _tmp20_;
	_tmp21_ = yStart;
	yBoardStart = _tmp21_;
	_tmp22_ = xEnd;
	xBoardEnd = _tmp22_;
	_tmp23_ = yEnd;
	yBoardEnd = _tmp23_;
	_tmp25_ = xBoardStart;
	if (_tmp25_ > 0) {
		gint _tmp26_;
		_tmp26_ = halfGridSize;
		_tmp24_ = _tmp26_;
	} else {
		gint _tmp27_;
		_tmp27_ = halfGridSize;
		_tmp24_ = -_tmp27_;
	}
	_tmp28_ = xBoardStart;
	_tmp29_ = _tmp24_;
	xBoardStart = _tmp28_ + _tmp29_;
	_tmp31_ = yBoardStart;
	if (_tmp31_ > 0) {
		gint _tmp32_;
		_tmp32_ = halfGridSize;
		_tmp30_ = _tmp32_;
	} else {
		gint _tmp33_;
		_tmp33_ = halfGridSize;
		_tmp30_ = -_tmp33_;
	}
	_tmp34_ = yBoardStart;
	_tmp35_ = _tmp30_;
	yBoardStart = _tmp34_ + _tmp35_;
	_tmp36_ = xBoardStart;
	_tmp37_ = self->priv->parent;
	_tmp38_ = _tmp37_->gridSize;
	_tmp39_ = self->priv->parent;
	_tmp40_ = _tmp39_->gridSize;
	xBoardStart = (_tmp36_ / _tmp38_) * _tmp40_;
	_tmp41_ = yBoardStart;
	_tmp42_ = self->priv->parent;
	_tmp43_ = _tmp42_->gridSize;
	_tmp44_ = self->priv->parent;
	_tmp45_ = _tmp44_->gridSize;
	yBoardStart = (_tmp41_ / _tmp43_) * _tmp45_;
	_tmp47_ = xBoardEnd;
	if (_tmp47_ > 0) {
		gint _tmp48_;
		_tmp48_ = halfGridSize;
		_tmp46_ = _tmp48_;
	} else {
		gint _tmp49_;
		_tmp49_ = halfGridSize;
		_tmp46_ = -_tmp49_;
	}
	_tmp50_ = xBoardEnd;
	_tmp51_ = _tmp46_;
	xBoardEnd = _tmp50_ + _tmp51_;
	_tmp53_ = yBoardEnd;
	if (_tmp53_ > 0) {
		gint _tmp54_;
		_tmp54_ = halfGridSize;
		_tmp52_ = _tmp54_;
	} else {
		gint _tmp55_;
		_tmp55_ = halfGridSize;
		_tmp52_ = -_tmp55_;
	}
	_tmp56_ = yBoardEnd;
	_tmp57_ = _tmp52_;
	yBoardEnd = _tmp56_ + _tmp57_;
	_tmp58_ = xBoardEnd;
	_tmp59_ = self->priv->parent;
	_tmp60_ = _tmp59_->gridSize;
	_tmp61_ = self->priv->parent;
	_tmp62_ = _tmp61_->gridSize;
	xBoardEnd = (_tmp58_ / _tmp60_) * _tmp62_;
	_tmp63_ = yBoardEnd;
	_tmp64_ = self->priv->parent;
	_tmp65_ = _tmp64_->gridSize;
	_tmp66_ = self->priv->parent;
	_tmp67_ = _tmp66_->gridSize;
	yBoardEnd = (_tmp63_ / _tmp65_) * _tmp67_;
	_tmp68_ = stdout;
	_tmp69_ = xBoardStart;
	_tmp70_ = yBoardStart;
	_tmp71_ = xBoardEnd;
	_tmp72_ = yBoardEnd;
	fprintf (_tmp68_, "Customiser Interact @ %i, %i - %i, %i\n", _tmp69_, _tmp70_, _tmp71_, _tmp72_);
	_tmp73_ = self->priv->customComponentDef;
	_tmp74_ = ((ComponentDef*) _tmp73_)->rightBound;
	rightBound = _tmp74_;
	_tmp75_ = self->priv->customComponentDef;
	_tmp76_ = ((ComponentDef*) _tmp75_)->downBound;
	downBound = _tmp76_;
	_tmp77_ = self->priv->customComponentDef;
	_tmp78_ = ((ComponentDef*) _tmp77_)->leftBound;
	leftBound = _tmp78_;
	_tmp79_ = self->priv->customComponentDef;
	_tmp80_ = ((ComponentDef*) _tmp79_)->upBound;
	upBound = _tmp80_;
	_tmp82_ = upBound;
	_tmp83_ = yBoardEnd;
	if (_tmp82_ <= _tmp83_) {
		gint _tmp84_;
		gint _tmp85_;
		_tmp84_ = yBoardEnd;
		_tmp85_ = downBound;
		_tmp81_ = _tmp84_ <= _tmp85_;
	} else {
		_tmp81_ = FALSE;
	}
	_tmp86_ = _tmp81_;
	if (_tmp86_) {
		gint _tmp87_;
		gint _tmp88_;
		gint _tmp94_;
		gint _tmp95_;
		_tmp87_ = xBoardEnd;
		_tmp88_ = leftBound;
		if (_tmp87_ < _tmp88_) {
			PinDef* _tmp89_;
			gint _tmp90_;
			gint _tmp91_;
			gint _tmp92_;
			gint _tmp93_;
			_tmp89_ = self->priv->selectedPin;
			_tmp90_ = leftBound;
			_tmp91_ = yBoardEnd;
			_tmp92_ = leftBound;
			_tmp93_ = xBoardEnd;
			pin_def_set_position (_tmp89_, _tmp90_, _tmp91_, _tmp92_ - _tmp93_, DIRECTION_LEFT);
		}
		_tmp94_ = xBoardEnd;
		_tmp95_ = rightBound;
		if (_tmp94_ > _tmp95_) {
			PinDef* _tmp96_;
			gint _tmp97_;
			gint _tmp98_;
			gint _tmp99_;
			gint _tmp100_;
			_tmp96_ = self->priv->selectedPin;
			_tmp97_ = rightBound;
			_tmp98_ = yBoardEnd;
			_tmp99_ = xBoardEnd;
			_tmp100_ = rightBound;
			pin_def_set_position (_tmp96_, _tmp97_, _tmp98_, _tmp99_ - _tmp100_, DIRECTION_RIGHT);
		}
	}
	_tmp102_ = leftBound;
	_tmp103_ = xBoardEnd;
	if (_tmp102_ <= _tmp103_) {
		gint _tmp104_;
		gint _tmp105_;
		_tmp104_ = xBoardEnd;
		_tmp105_ = rightBound;
		_tmp101_ = _tmp104_ <= _tmp105_;
	} else {
		_tmp101_ = FALSE;
	}
	_tmp106_ = _tmp101_;
	if (_tmp106_) {
		gint _tmp107_;
		gint _tmp108_;
		gint _tmp114_;
		gint _tmp115_;
		_tmp107_ = yBoardEnd;
		_tmp108_ = upBound;
		if (_tmp107_ < _tmp108_) {
			PinDef* _tmp109_;
			gint _tmp110_;
			gint _tmp111_;
			gint _tmp112_;
			gint _tmp113_;
			_tmp109_ = self->priv->selectedPin;
			_tmp110_ = xBoardEnd;
			_tmp111_ = upBound;
			_tmp112_ = upBound;
			_tmp113_ = yBoardEnd;
			pin_def_set_position (_tmp109_, _tmp110_, _tmp111_, _tmp112_ - _tmp113_, DIRECTION_UP);
		}
		_tmp114_ = yBoardEnd;
		_tmp115_ = downBound;
		if (_tmp114_ > _tmp115_) {
			PinDef* _tmp116_;
			gint _tmp117_;
			gint _tmp118_;
			gint _tmp119_;
			gint _tmp120_;
			_tmp116_ = self->priv->selectedPin;
			_tmp117_ = xBoardEnd;
			_tmp118_ = downBound;
			_tmp119_ = yBoardEnd;
			_tmp120_ = downBound;
			pin_def_set_position (_tmp116_, _tmp117_, _tmp118_, _tmp119_ - _tmp120_, DIRECTION_DOWN);
		}
	}
	customiser_update_values (self);
	customiser_render_def (self, NULL);
	result = FALSE;
	return result;
}


/**
 * Called when the Customiser should become modal.
 */
void customiser_run (Customiser* self) {
	GtkDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->dialog;
	gtk_dialog_run (_tmp0_);
}


/**
 * Handles the response of the customiser dialog. (On close.)
 */
void customiser_response_handler (Customiser* self, gint response_id) {
	GtkDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	customiser_update_values (self);
	_tmp0_ = self->priv->dialog;
	gtk_widget_destroy ((GtkWidget*) _tmp0_);
}


void customiser_set_colour (Customiser* self) {
	GtkDialog* _tmp0_;
	GtkColorChooserDialog* _tmp1_;
	GtkColorChooserDialog* colorDialog;
	GdkRGBA color = {0};
	GtkColorChooserDialog* _tmp2_;
	CustomComponentDef* _tmp3_;
	gint _tmp4_;
	CustomComponentDef* _tmp5_;
	gint _tmp6_;
	CustomComponentDef* _tmp7_;
	gint _tmp8_;
	CustomComponentDef* _tmp9_;
	gint _tmp10_;
	GtkColorChooserDialog* _tmp13_;
	GdkRGBA _tmp14_;
	GtkColorChooserDialog* _tmp15_;
	gint _tmp16_ = 0;
	GtkColorChooserDialog* _tmp43_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->dialog;
	_tmp1_ = (GtkColorChooserDialog*) gtk_color_chooser_dialog_new ("Component Background", (GtkWindow*) _tmp0_);
	g_object_ref_sink (_tmp1_);
	colorDialog = _tmp1_;
	memset (&color, 0, sizeof (GdkRGBA));
	_tmp2_ = colorDialog;
	gtk_color_chooser_set_use_alpha ((GtkColorChooser*) _tmp2_, TRUE);
	_tmp3_ = self->priv->customComponentDef;
	_tmp4_ = ((ComponentDef*) _tmp3_)->backgroundRed;
	color.red = ((gdouble) _tmp4_) / 255.0;
	_tmp5_ = self->priv->customComponentDef;
	_tmp6_ = ((ComponentDef*) _tmp5_)->backgroundGreen;
	color.green = ((gdouble) _tmp6_) / 255.0;
	_tmp7_ = self->priv->customComponentDef;
	_tmp8_ = ((ComponentDef*) _tmp7_)->backgroundBlue;
	color.blue = ((gdouble) _tmp8_) / 255.0;
	_tmp9_ = self->priv->customComponentDef;
	_tmp10_ = ((ComponentDef*) _tmp9_)->backgroundAlpha;
	if (_tmp10_ == 0) {
		color.alpha = 1.0;
	} else {
		CustomComponentDef* _tmp11_;
		gint _tmp12_;
		_tmp11_ = self->priv->customComponentDef;
		_tmp12_ = ((ComponentDef*) _tmp11_)->backgroundAlpha;
		color.alpha = ((gdouble) _tmp12_) / 255.0;
	}
	_tmp13_ = colorDialog;
	_tmp14_ = color;
	gtk_color_chooser_set_rgba ((GtkColorChooser*) _tmp13_, &_tmp14_);
	_tmp15_ = colorDialog;
	_tmp16_ = gtk_dialog_run ((GtkDialog*) _tmp15_);
	if (_tmp16_ == ((gint) GTK_RESPONSE_OK)) {
		GtkColorChooserDialog* _tmp17_;
		GdkRGBA _tmp18_ = {0};
		CustomComponentDef* _tmp19_;
		GdkRGBA _tmp20_;
		gdouble _tmp21_;
		CustomComponentDef* _tmp22_;
		GdkRGBA _tmp23_;
		gdouble _tmp24_;
		CustomComponentDef* _tmp25_;
		GdkRGBA _tmp26_;
		gdouble _tmp27_;
		CustomComponentDef* _tmp28_;
		GdkRGBA _tmp29_;
		gdouble _tmp30_;
		CustomComponentDef* _tmp31_;
		CustomComponentDef* _tmp32_;
		gint _tmp33_;
		CustomComponentDef* _tmp34_;
		CustomComponentDef* _tmp35_;
		gint _tmp36_;
		CustomComponentDef* _tmp37_;
		CustomComponentDef* _tmp38_;
		gint _tmp39_;
		CustomComponentDef* _tmp40_;
		CustomComponentDef* _tmp41_;
		gint _tmp42_;
		_tmp17_ = colorDialog;
		gtk_color_chooser_get_rgba ((GtkColorChooser*) _tmp17_, &_tmp18_);
		color = _tmp18_;
		_tmp19_ = self->priv->customComponentDef;
		_tmp20_ = color;
		_tmp21_ = _tmp20_.red;
		((ComponentDef*) _tmp19_)->backgroundRed = (gint) (_tmp21_ * 255.0);
		_tmp22_ = self->priv->customComponentDef;
		_tmp23_ = color;
		_tmp24_ = _tmp23_.green;
		((ComponentDef*) _tmp22_)->backgroundGreen = (gint) (_tmp24_ * 255.0);
		_tmp25_ = self->priv->customComponentDef;
		_tmp26_ = color;
		_tmp27_ = _tmp26_.blue;
		((ComponentDef*) _tmp25_)->backgroundBlue = (gint) (_tmp27_ * 255.0);
		_tmp28_ = self->priv->customComponentDef;
		_tmp29_ = color;
		_tmp30_ = _tmp29_.alpha;
		((ComponentDef*) _tmp28_)->backgroundAlpha = (gint) (_tmp30_ * 255.0);
		_tmp31_ = self->priv->customComponentDef;
		_tmp32_ = self->priv->customComponentDef;
		_tmp33_ = ((ComponentDef*) _tmp32_)->backgroundAlpha;
		((ComponentDef*) _tmp31_)->backgroundAlphaF = ((gdouble) _tmp33_) / 255.0;
		_tmp34_ = self->priv->customComponentDef;
		_tmp35_ = self->priv->customComponentDef;
		_tmp36_ = ((ComponentDef*) _tmp35_)->backgroundRed;
		((ComponentDef*) _tmp34_)->backgroundRedF = ((gdouble) _tmp36_) / 255.0;
		_tmp37_ = self->priv->customComponentDef;
		_tmp38_ = self->priv->customComponentDef;
		_tmp39_ = ((ComponentDef*) _tmp38_)->backgroundGreen;
		((ComponentDef*) _tmp37_)->backgroundGreenF = ((gdouble) _tmp39_) / 255.0;
		_tmp40_ = self->priv->customComponentDef;
		_tmp41_ = self->priv->customComponentDef;
		_tmp42_ = ((ComponentDef*) _tmp41_)->backgroundBlue;
		((ComponentDef*) _tmp40_)->backgroundBlueF = ((gdouble) _tmp42_) / 255.0;
	}
	_tmp43_ = colorDialog;
	gtk_widget_destroy ((GtkWidget*) _tmp43_);
	customiser_render_def (self, NULL);
	_g_object_unref0 (colorDialog);
}


/**
 * Set generic information. Called when closing the dialog.
 */
void customiser_update_values (Customiser* self) {
	GtkEntry* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	CustomComponentDef* _tmp3_;
	const gchar* _tmp4_;
	CustomComponentDef* _tmp30_;
	GtkEntry* _tmp31_;
	const gchar* _tmp32_;
	const gchar* _tmp33_;
	gchar* _tmp34_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->nameEntry;
	_tmp1_ = gtk_entry_get_text (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->customComponentDef;
	_tmp4_ = ((ComponentDef*) _tmp3_)->name;
	if (g_strcmp0 (_tmp2_, _tmp4_) != 0) {
		Project* _tmp5_;
		GtkEntry* _tmp6_;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		ComponentDef* _tmp9_ = NULL;
		ComponentDef* _tmp10_;
		gboolean _tmp11_;
		_tmp5_ = self->priv->project;
		_tmp6_ = self->priv->nameEntry;
		_tmp7_ = gtk_entry_get_text (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = project_resolve_def_name (_tmp5_, _tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = _tmp10_ == NULL;
		_component_def_unref0 (_tmp10_);
		if (_tmp11_) {
			CustomComponentDef* _tmp12_;
			GtkEntry* _tmp13_;
			const gchar* _tmp14_;
			const gchar* _tmp15_;
			gchar* _tmp16_;
			_tmp12_ = self->priv->customComponentDef;
			_tmp13_ = self->priv->nameEntry;
			_tmp14_ = gtk_entry_get_text (_tmp13_);
			_tmp15_ = _tmp14_;
			_tmp16_ = g_strdup (_tmp15_);
			_g_free0 (((ComponentDef*) _tmp12_)->name);
			((ComponentDef*) _tmp12_)->name = _tmp16_;
		} else {
			GtkEntry* _tmp17_;
			const gchar* _tmp18_;
			const gchar* _tmp19_;
			gchar* _tmp20_;
			gchar* _tmp21_;
			gchar* _tmp22_;
			gchar* _tmp23_;
			CustomComponentDef* _tmp24_;
			const gchar* _tmp25_;
			gchar* _tmp26_;
			gchar* _tmp27_;
			gchar* _tmp28_;
			gchar* _tmp29_;
			_tmp17_ = self->priv->nameEntry;
			_tmp18_ = gtk_entry_get_text (_tmp17_);
			_tmp19_ = _tmp18_;
			_tmp20_ = g_strconcat ("A component with the name \"", _tmp19_, NULL);
			_tmp21_ = _tmp20_;
			_tmp22_ = g_strconcat (_tmp21_, "\" already exists. It may be a built-in component or a custom componen" \
"t. This component's name will remain \"", NULL);
			_tmp23_ = _tmp22_;
			_tmp24_ = self->priv->customComponentDef;
			_tmp25_ = ((ComponentDef*) _tmp24_)->name;
			_tmp26_ = g_strconcat (_tmp23_, _tmp25_, NULL);
			_tmp27_ = _tmp26_;
			_tmp28_ = g_strconcat (_tmp27_, "\".", NULL);
			_tmp29_ = _tmp28_;
			basic_dialog_error (NULL, _tmp29_);
			_g_free0 (_tmp29_);
			_g_free0 (_tmp27_);
			_g_free0 (_tmp23_);
			_g_free0 (_tmp21_);
		}
	}
	_tmp30_ = self->priv->customComponentDef;
	_tmp31_ = self->priv->descriptionEntry;
	_tmp32_ = gtk_entry_get_text (_tmp31_);
	_tmp33_ = _tmp32_;
	_tmp34_ = g_strdup (_tmp33_);
	_g_free0 (((ComponentDef*) _tmp30_)->description);
	((ComponentDef*) _tmp30_)->description = _tmp34_;
}


/**
 * Set, from radio buttons, what type of label a pin should use.
 */
void customiser_update_label_type (Customiser* self) {
	PinDef* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->selectedPin;
	if (_tmp0_ != NULL) {
		GtkRadioButton* _tmp1_;
		gboolean _tmp2_;
		gboolean _tmp3_;
		_tmp1_ = self->priv->labelTypeNoneRadio;
		_tmp2_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp1_);
		_tmp3_ = _tmp2_;
		if (_tmp3_) {
			PinDef* _tmp4_;
			_tmp4_ = self->priv->selectedPin;
			_tmp4_->labelType = PIN_DEF_LABEL_TYPE_NONE;
		} else {
			GtkRadioButton* _tmp5_;
			gboolean _tmp6_;
			gboolean _tmp7_;
			_tmp5_ = self->priv->labelTypeTextRadio;
			_tmp6_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp5_);
			_tmp7_ = _tmp6_;
			if (_tmp7_) {
				PinDef* _tmp8_;
				_tmp8_ = self->priv->selectedPin;
				_tmp8_->labelType = PIN_DEF_LABEL_TYPE_TEXT;
			} else {
				GtkRadioButton* _tmp9_;
				gboolean _tmp10_;
				gboolean _tmp11_;
				_tmp9_ = self->priv->labelTypeTextBarRadio;
				_tmp10_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp9_);
				_tmp11_ = _tmp10_;
				if (_tmp11_) {
					PinDef* _tmp12_;
					_tmp12_ = self->priv->selectedPin;
					_tmp12_->labelType = PIN_DEF_LABEL_TYPE_TEXTBAR;
				} else {
					GtkRadioButton* _tmp13_;
					gboolean _tmp14_;
					gboolean _tmp15_;
					_tmp13_ = self->priv->labelTypeClockRadio;
					_tmp14_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp13_);
					_tmp15_ = _tmp14_;
					if (_tmp15_) {
						PinDef* _tmp16_;
						_tmp16_ = self->priv->selectedPin;
						_tmp16_->labelType = PIN_DEF_LABEL_TYPE_CLOCK;
					}
				}
			}
		}
		customiser_render_def (self, NULL);
	}
}


/**
 * Set, from spin buttons, what the bounds of the component are.
 */
void customiser_update_bounds (Customiser* self) {
	CustomComponentDef* _tmp0_;
	GtkSpinButton* _tmp1_;
	gint _tmp2_ = 0;
	CustomComponentDef* _tmp3_;
	GtkSpinButton* _tmp4_;
	gint _tmp5_ = 0;
	CustomComponentDef* _tmp6_;
	GtkSpinButton* _tmp7_;
	gint _tmp8_ = 0;
	CustomComponentDef* _tmp9_;
	GtkSpinButton* _tmp10_;
	gint _tmp11_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->customComponentDef;
	_tmp1_ = self->priv->rightBoundSpinButton;
	_tmp2_ = gtk_spin_button_get_value_as_int (_tmp1_);
	((ComponentDef*) _tmp0_)->rightBound = _tmp2_;
	_tmp3_ = self->priv->customComponentDef;
	_tmp4_ = self->priv->downBoundSpinButton;
	_tmp5_ = gtk_spin_button_get_value_as_int (_tmp4_);
	((ComponentDef*) _tmp3_)->downBound = _tmp5_;
	_tmp6_ = self->priv->customComponentDef;
	_tmp7_ = self->priv->leftBoundSpinButton;
	_tmp8_ = gtk_spin_button_get_value_as_int (_tmp7_);
	((ComponentDef*) _tmp6_)->leftBound = _tmp8_;
	_tmp9_ = self->priv->customComponentDef;
	_tmp10_ = self->priv->upBoundSpinButton;
	_tmp11_ = gtk_spin_button_get_value_as_int (_tmp10_);
	((ComponentDef*) _tmp9_)->upBound = _tmp11_;
	customiser_render_def (self, NULL);
}


/**
 * Update widgets to show the information of the selected pin.
 */
void customiser_update_selection (Customiser* self) {
	CustomComponentDef* _tmp0_;
	PinDef** _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->customComponentDef;
	_tmp1_ = ((ComponentDef*) _tmp0_)->pinDefs;
	_tmp1__length1 = ((ComponentDef*) _tmp0_)->pinDefs_length1;
	if (_tmp1__length1 > 0) {
		GtkSpinButton* _tmp2_;
		gint _tmp3_ = 0;
		CustomComponentDef* _tmp4_;
		PinDef** _tmp5_;
		gint _tmp5__length1;
		gint _tmp6_;
		PinDef* _tmp7_;
		PinDef* _tmp8_;
		CustomComponentDef* _tmp9_;
		gint _tmp10_;
		Tag* _tmp11_ = NULL;
		PinDef* _tmp12_;
		PinDefLabelType _tmp13_;
		Tag* _tmp18_;
		GtkEntry* _tmp31_;
		PinDef* _tmp32_;
		const gchar* _tmp33_;
		GtkCheckButton* _tmp34_;
		PinDef* _tmp35_;
		gboolean _tmp36_;
		_tmp2_ = self->priv->pinSpinButton;
		_tmp3_ = gtk_spin_button_get_value_as_int (_tmp2_);
		self->priv->selectedPinID = _tmp3_;
		_tmp4_ = self->priv->customComponentDef;
		_tmp5_ = ((ComponentDef*) _tmp4_)->pinDefs;
		_tmp5__length1 = ((ComponentDef*) _tmp4_)->pinDefs_length1;
		_tmp6_ = self->priv->selectedPinID;
		_tmp7_ = _tmp5_[_tmp6_];
		_tmp8_ = _pin_def_ref0 (_tmp7_);
		_pin_def_unref0 (self->priv->selectedPin);
		self->priv->selectedPin = _tmp8_;
		_tmp9_ = self->priv->customComponentDef;
		_tmp10_ = self->priv->selectedPinID;
		_tmp11_ = custom_component_def_resolve_tag_id (_tmp9_, _tmp10_);
		_tag_unref0 (self->priv->tag);
		self->priv->tag = _tmp11_;
		_tmp12_ = self->priv->selectedPin;
		_tmp13_ = _tmp12_->labelType;
		switch (_tmp13_) {
			case PIN_DEF_LABEL_TYPE_NONE:
			{
				GtkRadioButton* _tmp14_;
				_tmp14_ = self->priv->labelTypeNoneRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp14_, TRUE);
				break;
			}
			case PIN_DEF_LABEL_TYPE_TEXT:
			{
				GtkRadioButton* _tmp15_;
				_tmp15_ = self->priv->labelTypeTextRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp15_, TRUE);
				break;
			}
			case PIN_DEF_LABEL_TYPE_TEXTBAR:
			{
				GtkRadioButton* _tmp16_;
				_tmp16_ = self->priv->labelTypeTextBarRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp16_, TRUE);
				break;
			}
			case PIN_DEF_LABEL_TYPE_CLOCK:
			{
				GtkRadioButton* _tmp17_;
				_tmp17_ = self->priv->labelTypeClockRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp17_, TRUE);
				break;
			}
			default:
			break;
		}
		_tmp18_ = self->priv->tag;
		if (_tmp18_ != NULL) {
			GtkLabel* _tmp19_;
			Tag* _tmp20_;
			const gchar* _tmp21_;
			gchar* _tmp22_;
			gchar* _tmp23_;
			PinDef* _tmp24_;
			const gchar* _tmp25_;
			_tmp19_ = self->priv->tagNameLabel;
			_tmp20_ = self->priv->tag;
			_tmp21_ = _tmp20_->text;
			_tmp22_ = g_strconcat ("Maps to: ", _tmp21_, NULL);
			_tmp23_ = _tmp22_;
			gtk_label_set_label (_tmp19_, _tmp23_);
			_g_free0 (_tmp23_);
			_tmp24_ = self->priv->selectedPin;
			_tmp25_ = _tmp24_->label;
			if (g_strcmp0 (_tmp25_, "") == 0) {
				PinDef* _tmp26_;
				Tag* _tmp27_;
				const gchar* _tmp28_;
				gchar* _tmp29_;
				_tmp26_ = self->priv->selectedPin;
				_tmp27_ = self->priv->tag;
				_tmp28_ = _tmp27_->text;
				_tmp29_ = g_strdup (_tmp28_);
				_g_free0 (_tmp26_->label);
				_tmp26_->label = _tmp29_;
			}
		} else {
			GtkLabel* _tmp30_;
			_tmp30_ = self->priv->tagNameLabel;
			gtk_label_set_label (_tmp30_, "There is no matching tag!");
		}
		_tmp31_ = self->priv->pinLabelEntry;
		_tmp32_ = self->priv->selectedPin;
		_tmp33_ = _tmp32_->label;
		gtk_entry_set_text (_tmp31_, _tmp33_);
		_tmp34_ = self->priv->requiredCheck;
		_tmp35_ = self->priv->selectedPin;
		_tmp36_ = _tmp35_->required;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp34_, _tmp36_);
	} else {
		_pin_def_unref0 (self->priv->selectedPin);
		self->priv->selectedPin = NULL;
	}
	customiser_render_def (self, NULL);
}


/**
 * Render the current box design.
 */
static gpointer _cairo_reference0 (gpointer self) {
	return self ? cairo_reference (self) : NULL;
}


gboolean customiser_render_def (Customiser* self, cairo_t* passedDisplayContext) {
	gboolean result = FALSE;
	cairo_t* displayContext = NULL;
	gint width = 0;
	gint height = 0;
	GtkAllocation areaAllocation = {0};
	GtkDrawingArea* _tmp0_;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_;
	gint _tmp3_;
	GtkAllocation _tmp4_;
	gint _tmp5_;
	cairo_t* _tmp6_;
	cairo_t* _tmp12_;
	cairo_surface_t* _tmp13_ = NULL;
	gint _tmp14_;
	gint _tmp15_;
	cairo_surface_t* _tmp16_;
	cairo_surface_t* offScreenSurface;
	cairo_surface_t* _tmp17_;
	cairo_t* _tmp18_;
	cairo_t* context;
	cairo_t* _tmp19_;
	cairo_surface_t* _tmp20_;
	cairo_t* _tmp21_;
	gboolean _tmp22_ = FALSE;
	DesignerWindow* _tmp23_;
	gboolean _tmp26_;
	cairo_t* _tmp98_;
	gint _tmp99_;
	gint _tmp100_;
	cairo_t* _tmp101_;
	CustomComponentDef* _tmp102_;
	cairo_t* _tmp103_;
	cairo_t* _tmp121_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->display;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	areaAllocation = _tmp1_;
	_tmp2_ = areaAllocation;
	_tmp3_ = _tmp2_.width;
	width = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.height;
	height = _tmp5_;
	_tmp6_ = passedDisplayContext;
	if (_tmp6_ == NULL) {
		GtkDrawingArea* _tmp7_;
		GdkWindow* _tmp8_ = NULL;
		cairo_t* _tmp9_ = NULL;
		_tmp7_ = self->priv->display;
		_tmp8_ = gtk_widget_get_window ((GtkWidget*) _tmp7_);
		_tmp9_ = gdk_cairo_create (_tmp8_);
		_cairo_destroy0 (displayContext);
		displayContext = _tmp9_;
	} else {
		cairo_t* _tmp10_;
		cairo_t* _tmp11_;
		_tmp10_ = passedDisplayContext;
		_tmp11_ = _cairo_reference0 (_tmp10_);
		_cairo_destroy0 (displayContext);
		displayContext = _tmp11_;
	}
	_tmp12_ = displayContext;
	_tmp13_ = cairo_get_target (_tmp12_);
	_tmp14_ = width;
	_tmp15_ = height;
	_tmp16_ = cairo_surface_create_similar (_tmp13_, CAIRO_CONTENT_COLOR, _tmp14_, _tmp15_);
	offScreenSurface = _tmp16_;
	_tmp17_ = offScreenSurface;
	_tmp18_ = cairo_create (_tmp17_);
	context = _tmp18_;
	_tmp19_ = displayContext;
	_tmp20_ = offScreenSurface;
	cairo_set_source_surface (_tmp19_, _tmp20_, (gdouble) 0, (gdouble) 0);
	_tmp21_ = context;
	cairo_set_line_width (_tmp21_, (gdouble) 1);
	_tmp23_ = self->priv->parent;
	if (_tmp23_ != NULL) {
		DesignerWindow* _tmp24_;
		gboolean _tmp25_;
		_tmp24_ = self->priv->parent;
		_tmp25_ = _tmp24_->showGrid;
		_tmp22_ = _tmp25_;
	} else {
		_tmp22_ = FALSE;
	}
	_tmp26_ = _tmp22_;
	if (_tmp26_) {
		cairo_surface_t* _tmp27_;
		cairo_t* _tmp93_;
		cairo_surface_t* _tmp94_;
		cairo_t* _tmp95_;
		_tmp27_ = self->priv->gridCache;
		if (_tmp27_ == NULL) {
			cairo_t* _tmp28_;
			cairo_surface_t* _tmp29_ = NULL;
			cairo_t* _tmp30_;
			cairo_surface_t* _tmp31_ = NULL;
			cairo_content_t _tmp32_ = 0;
			gint _tmp33_;
			gint _tmp34_;
			cairo_surface_t* _tmp35_;
			cairo_surface_t* _tmp36_;
			cairo_t* _tmp37_;
			cairo_t* gridContext;
			cairo_t* _tmp38_;
			cairo_t* _tmp39_;
			DesignerWindow* _tmp40_;
			gint _tmp41_;
			gfloat spacing;
			gint _tmp46_;
			gfloat _tmp47_;
			gfloat y;
			gint _tmp48_;
			gfloat _tmp49_;
			gfloat x;
			cairo_t* _tmp50_;
			cairo_t* _tmp51_;
			gfloat _tmp52_;
			gdouble* _tmp53_ = NULL;
			gdouble* _tmp54_;
			gint _tmp54__length1;
			gfloat _tmp68_;
			gint _tmp69_;
			gfloat _tmp70_;
			gint _tmp71_;
			gfloat _tmp72_;
			cairo_t* _tmp73_;
			cairo_t* _tmp74_;
			gfloat _tmp75_;
			gdouble* _tmp76_ = NULL;
			gdouble* _tmp77_;
			gint _tmp77__length1;
			cairo_t* _tmp91_;
			cairo_t* _tmp92_;
			_tmp28_ = context;
			_tmp29_ = cairo_get_target (_tmp28_);
			_tmp30_ = context;
			_tmp31_ = cairo_get_target (_tmp30_);
			_tmp32_ = cairo_surface_get_content (_tmp31_);
			_tmp33_ = width;
			_tmp34_ = height;
			_tmp35_ = cairo_surface_create_similar (_tmp29_, _tmp32_, _tmp33_, _tmp34_);
			_cairo_surface_destroy0 (self->priv->gridCache);
			self->priv->gridCache = _tmp35_;
			_tmp36_ = self->priv->gridCache;
			_tmp37_ = cairo_create (_tmp36_);
			gridContext = _tmp37_;
			_tmp38_ = gridContext;
			cairo_set_source_rgb (_tmp38_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
			_tmp39_ = gridContext;
			cairo_paint (_tmp39_);
			_tmp40_ = self->priv->parent;
			_tmp41_ = _tmp40_->gridSize;
			spacing = (gfloat) _tmp41_;
			while (TRUE) {
				gfloat _tmp42_;
				gfloat _tmp43_;
				DesignerWindow* _tmp44_;
				gint _tmp45_;
				_tmp42_ = spacing;
				if (!(_tmp42_ < ((gfloat) 2))) {
					break;
				}
				_tmp43_ = spacing;
				_tmp44_ = self->priv->parent;
				_tmp45_ = _tmp44_->gridSize;
				spacing = _tmp43_ * _tmp45_;
			}
			_tmp46_ = height;
			_tmp47_ = spacing;
			y = fmodf (_tmp46_ / 2, _tmp47_);
			_tmp48_ = width;
			_tmp49_ = spacing;
			x = fmodf (_tmp48_ / 2, _tmp49_);
			_tmp50_ = gridContext;
			cairo_set_source_rgba (_tmp50_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.5);
			_tmp51_ = gridContext;
			_tmp52_ = spacing;
			_tmp53_ = g_new0 (gdouble, 2);
			_tmp53_[0] = 1.0;
			_tmp53_[1] = _tmp52_ - 1.0;
			_tmp54_ = _tmp53_;
			_tmp54__length1 = 2;
			cairo_set_dash (_tmp51_, _tmp54_, 2, (gdouble) 0);
			_tmp54_ = (g_free (_tmp54_), NULL);
			{
				gboolean _tmp55_;
				_tmp55_ = TRUE;
				while (TRUE) {
					gboolean _tmp56_;
					gfloat _tmp59_;
					gint _tmp60_;
					cairo_t* _tmp61_;
					gfloat _tmp62_;
					gfloat _tmp63_;
					cairo_t* _tmp64_;
					gint _tmp65_;
					gfloat _tmp66_;
					cairo_t* _tmp67_;
					_tmp56_ = _tmp55_;
					if (!_tmp56_) {
						gfloat _tmp57_;
						gfloat _tmp58_;
						_tmp57_ = y;
						_tmp58_ = spacing;
						y = _tmp57_ + _tmp58_;
					}
					_tmp55_ = FALSE;
					_tmp59_ = y;
					_tmp60_ = height;
					if (!(_tmp59_ < ((gfloat) _tmp60_))) {
						break;
					}
					_tmp61_ = gridContext;
					_tmp62_ = x;
					_tmp63_ = y;
					cairo_move_to (_tmp61_, (gdouble) _tmp62_, (gdouble) _tmp63_);
					_tmp64_ = gridContext;
					_tmp65_ = width;
					_tmp66_ = y;
					cairo_line_to (_tmp64_, (gdouble) _tmp65_, (gdouble) _tmp66_);
					_tmp67_ = gridContext;
					cairo_stroke (_tmp67_);
				}
			}
			_tmp68_ = spacing;
			spacing = _tmp68_ * 4;
			_tmp69_ = height;
			_tmp70_ = spacing;
			y = fmodf (_tmp69_ / 2, _tmp70_);
			_tmp71_ = width;
			_tmp72_ = spacing;
			x = fmodf (_tmp71_ / 2, _tmp72_);
			_tmp73_ = gridContext;
			cairo_set_source_rgba (_tmp73_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 1.0);
			_tmp74_ = gridContext;
			_tmp75_ = spacing;
			_tmp76_ = g_new0 (gdouble, 2);
			_tmp76_[0] = 1.0;
			_tmp76_[1] = _tmp75_ - 1.0;
			_tmp77_ = _tmp76_;
			_tmp77__length1 = 2;
			cairo_set_dash (_tmp74_, _tmp77_, 2, (gdouble) 0);
			_tmp77_ = (g_free (_tmp77_), NULL);
			{
				gboolean _tmp78_;
				_tmp78_ = TRUE;
				while (TRUE) {
					gboolean _tmp79_;
					gfloat _tmp82_;
					gint _tmp83_;
					cairo_t* _tmp84_;
					gfloat _tmp85_;
					gfloat _tmp86_;
					cairo_t* _tmp87_;
					gint _tmp88_;
					gfloat _tmp89_;
					cairo_t* _tmp90_;
					_tmp79_ = _tmp78_;
					if (!_tmp79_) {
						gfloat _tmp80_;
						gfloat _tmp81_;
						_tmp80_ = y;
						_tmp81_ = spacing;
						y = _tmp80_ + _tmp81_;
					}
					_tmp78_ = FALSE;
					_tmp82_ = y;
					_tmp83_ = height;
					if (!(_tmp82_ < ((gfloat) _tmp83_))) {
						break;
					}
					_tmp84_ = gridContext;
					_tmp85_ = x;
					_tmp86_ = y;
					cairo_move_to (_tmp84_, (gdouble) _tmp85_, (gdouble) _tmp86_);
					_tmp87_ = gridContext;
					_tmp88_ = width;
					_tmp89_ = y;
					cairo_line_to (_tmp87_, (gdouble) _tmp88_, (gdouble) _tmp89_);
					_tmp90_ = gridContext;
					cairo_stroke (_tmp90_);
				}
			}
			_tmp91_ = gridContext;
			cairo_set_dash (_tmp91_, NULL, 0, (gdouble) 0);
			_tmp92_ = gridContext;
			cairo_set_source_rgba (_tmp92_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 1);
			_cairo_destroy0 (gridContext);
		}
		_tmp93_ = context;
		_tmp94_ = self->priv->gridCache;
		cairo_set_source_surface (_tmp93_, _tmp94_, (gdouble) 0, (gdouble) 0);
		_tmp95_ = context;
		cairo_paint (_tmp95_);
	} else {
		cairo_t* _tmp96_;
		cairo_t* _tmp97_;
		_tmp96_ = context;
		cairo_set_source_rgb (_tmp96_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
		_tmp97_ = context;
		cairo_paint (_tmp97_);
	}
	_tmp98_ = context;
	_tmp99_ = width;
	_tmp100_ = height;
	cairo_translate (_tmp98_, (gdouble) (_tmp99_ / 2), (gdouble) (_tmp100_ / 2));
	_tmp101_ = context;
	cairo_set_source_rgb (_tmp101_, (gdouble) 0, (gdouble) 0, (gdouble) 0);
	_tmp102_ = self->priv->customComponentDef;
	_tmp103_ = context;
	component_def_render ((ComponentDef*) _tmp102_, _tmp103_, DIRECTION_RIGHT, FALSE, NULL, TRUE);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp104_;
			_tmp104_ = TRUE;
			while (TRUE) {
				gboolean _tmp105_;
				gint _tmp107_;
				CustomComponentDef* _tmp108_;
				PinDef** _tmp109_;
				gint _tmp109__length1;
				CustomComponentDef* _tmp110_;
				PinDef** _tmp111_;
				gint _tmp111__length1;
				gint _tmp112_;
				PinDef* _tmp113_;
				PinDef* _tmp114_;
				PinDef* pinDef;
				gint _tmp115_;
				gint _tmp116_;
				PinDef* _tmp119_;
				cairo_t* _tmp120_;
				_tmp105_ = _tmp104_;
				if (!_tmp105_) {
					gint _tmp106_;
					_tmp106_ = i;
					i = _tmp106_ + 1;
				}
				_tmp104_ = FALSE;
				_tmp107_ = i;
				_tmp108_ = self->priv->customComponentDef;
				_tmp109_ = ((ComponentDef*) _tmp108_)->pinDefs;
				_tmp109__length1 = ((ComponentDef*) _tmp108_)->pinDefs_length1;
				if (!(_tmp107_ < _tmp109__length1)) {
					break;
				}
				_tmp110_ = self->priv->customComponentDef;
				_tmp111_ = ((ComponentDef*) _tmp110_)->pinDefs;
				_tmp111__length1 = ((ComponentDef*) _tmp110_)->pinDefs_length1;
				_tmp112_ = i;
				_tmp113_ = _tmp111_[_tmp112_];
				_tmp114_ = _pin_def_ref0 (_tmp113_);
				pinDef = _tmp114_;
				_tmp115_ = self->priv->selectedPinID;
				_tmp116_ = i;
				if (_tmp115_ == _tmp116_) {
					cairo_t* _tmp117_;
					_tmp117_ = context;
					cairo_set_source_rgb (_tmp117_, (gdouble) 0, (gdouble) 0, (gdouble) 1);
				} else {
					cairo_t* _tmp118_;
					_tmp118_ = context;
					cairo_set_source_rgb (_tmp118_, (gdouble) 0, (gdouble) 0, (gdouble) 0);
				}
				_tmp119_ = pinDef;
				_tmp120_ = context;
				pin_def_render (_tmp119_, _tmp120_, FALSE);
				_pin_def_unref0 (pinDef);
			}
		}
	}
	_tmp121_ = displayContext;
	cairo_paint (_tmp121_);
	result = FALSE;
	_cairo_destroy0 (context);
	_cairo_surface_destroy0 (offScreenSurface);
	_cairo_destroy0 (displayContext);
	return result;
}


static void value_customiser_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_customiser_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		customiser_unref (value->data[0].v_pointer);
	}
}


static void value_customiser_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = customiser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_customiser_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_customiser_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Customiser* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = customiser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_customiser_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Customiser** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = customiser_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_customiser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecCustomiser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_CUSTOMISER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_customiser (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CUSTOMISER), NULL);
	return value->data[0].v_pointer;
}


void value_set_customiser (GValue* value, gpointer v_object) {
	Customiser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CUSTOMISER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CUSTOMISER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		customiser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		customiser_unref (old);
	}
}


void value_take_customiser (GValue* value, gpointer v_object) {
	Customiser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CUSTOMISER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CUSTOMISER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		customiser_unref (old);
	}
}


static void customiser_class_init (CustomiserClass * klass) {
	customiser_parent_class = g_type_class_peek_parent (klass);
	CUSTOMISER_CLASS (klass)->finalize = customiser_finalize;
	g_type_class_add_private (klass, sizeof (CustomiserPrivate));
}


static void customiser_instance_init (Customiser * self) {
	self->priv = CUSTOMISER_GET_PRIVATE (self);
	self->priv->selectedPinID = 0;
	self->ref_count = 1;
}


static void customiser_finalize (Customiser* obj) {
	Customiser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CUSTOMISER, Customiser);
	_g_object_unref0 (self->priv->dialog);
	_g_object_unref0 (self->priv->layoutHBox);
	_g_object_unref0 (self->priv->controller);
	_g_object_unref0 (self->priv->display);
	_g_object_unref0 (self->priv->controlsVBox);
	_g_object_unref0 (self->priv->nameHBox);
	_g_object_unref0 (self->priv->nameEntry);
	_g_object_unref0 (self->priv->nameLabel);
	_g_object_unref0 (self->priv->descriptionHBox);
	_g_object_unref0 (self->priv->descriptionEntry);
	_g_object_unref0 (self->priv->descriptionLabel);
	_g_object_unref0 (self->priv->labelHBox);
	_g_object_unref0 (self->priv->labelEntry);
	_g_object_unref0 (self->priv->labelLabel);
	_g_object_unref0 (self->priv->pinHBox);
	_g_object_unref0 (self->priv->pinSpinButton);
	_g_object_unref0 (self->priv->pinLabel);
	_g_object_unref0 (self->priv->tagNameLabel);
	_g_object_unref0 (self->priv->requiredCheck);
	_g_object_unref0 (self->priv->labelTypeVBox);
	_g_object_unref0 (self->priv->labelTypeLabel);
	_g_object_unref0 (self->priv->labelTypeNoneRadio);
	_g_object_unref0 (self->priv->labelTypeTextRadio);
	_g_object_unref0 (self->priv->labelTypeTextBarRadio);
	_g_object_unref0 (self->priv->labelTypeClockRadio);
	_g_object_unref0 (self->priv->pinLabelHBox);
	_g_object_unref0 (self->priv->pinLabelEntry);
	_g_object_unref0 (self->priv->pinLabelLabel);
	_g_object_unref0 (self->priv->boundsLabel);
	_g_object_unref0 (self->priv->boundsGrid);
	_g_object_unref0 (self->priv->rightBoundLabel);
	_g_object_unref0 (self->priv->rightBoundSpinButton);
	_g_object_unref0 (self->priv->downBoundLabel);
	_g_object_unref0 (self->priv->downBoundSpinButton);
	_g_object_unref0 (self->priv->leftBoundLabel);
	_g_object_unref0 (self->priv->leftBoundSpinButton);
	_g_object_unref0 (self->priv->upBoundLabel);
	_g_object_unref0 (self->priv->upBoundSpinButton);
	_g_object_unref0 (self->priv->colourButton);
	_g_object_unref0 (self->priv->closeButton);
	_cairo_surface_destroy0 (self->priv->gridCache);
	_component_def_unref0 (self->priv->customComponentDef);
	_g_object_unref0 (self->priv->parent);
	_project_unref0 (self->priv->project);
	_pin_def_unref0 (self->priv->selectedPin);
	_tag_unref0 (self->priv->tag);
}


/**
 * User interface element used to customise a component.
 * 
 * Allows a user to design how a custom component can be used in another
 * component.
 * Used to edit names and descriptions, create a box design, and
 * configure pins.
 */
GType customiser_get_type (void) {
	static volatile gsize customiser_type_id__volatile = 0;
	if (g_once_init_enter (&customiser_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_customiser_init, value_customiser_free_value, value_customiser_copy_value, value_customiser_peek_pointer, "p", value_customiser_collect_value, "p", value_customiser_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (CustomiserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) customiser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Customiser), 0, (GInstanceInitFunc) customiser_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType customiser_type_id;
		customiser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Customiser", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&customiser_type_id__volatile, customiser_type_id);
	}
	return customiser_type_id__volatile;
}


gpointer customiser_ref (gpointer instance) {
	Customiser* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void customiser_unref (gpointer instance) {
	Customiser* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		CUSTOMISER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



