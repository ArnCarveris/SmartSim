/* customiser.c generated by valac 0.20.1, the Vala compiler
 * generated from customiser.vala, do not modify */

/* 
 * SmartSim - Digital Logic Circuit Designer and Simulator
 *   
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *   
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *   
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *   
 *   Filename: customiser.vala
 *   
 *   Copyright Ashley Newson 2013
 */

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <gtk/gtk.h>
#include <cairo.h>
#include <libxml/tree.h>
#include <libxml/xmlwriter.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include <gdk/gdk.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_CUSTOMISER (customiser_get_type ())
#define CUSTOMISER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOMISER, Customiser))
#define CUSTOMISER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOMISER, CustomiserClass))
#define IS_CUSTOMISER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOMISER))
#define IS_CUSTOMISER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOMISER))
#define CUSTOMISER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOMISER, CustomiserClass))

typedef struct _Customiser Customiser;
typedef struct _CustomiserClass CustomiserClass;
typedef struct _CustomiserPrivate CustomiserPrivate;

#define CUSTOMISER_TYPE_MOUSE_MODE (customiser_mouse_mode_get_type ())

#define TYPE_COMPONENT_DEF (component_def_get_type ())
#define COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_DEF, ComponentDef))
#define COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_DEF, ComponentDefClass))
#define IS_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_DEF))
#define IS_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_DEF))
#define COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_DEF, ComponentDefClass))

typedef struct _ComponentDef ComponentDef;
typedef struct _ComponentDefClass ComponentDefClass;

#define TYPE_CUSTOM_COMPONENT_DEF (custom_component_def_get_type ())
#define CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDef))
#define CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))
#define IS_CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_COMPONENT_DEF))
#define IS_CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOM_COMPONENT_DEF))
#define CUSTOM_COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))

typedef struct _CustomComponentDef CustomComponentDef;
typedef struct _CustomComponentDefClass CustomComponentDefClass;

#define TYPE_DESIGNER_WINDOW (designer_window_get_type ())
#define DESIGNER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DESIGNER_WINDOW, DesignerWindow))
#define DESIGNER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DESIGNER_WINDOW, DesignerWindowClass))
#define IS_DESIGNER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DESIGNER_WINDOW))
#define IS_DESIGNER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DESIGNER_WINDOW))
#define DESIGNER_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DESIGNER_WINDOW, DesignerWindowClass))

typedef struct _DesignerWindow DesignerWindow;
typedef struct _DesignerWindowClass DesignerWindowClass;

#define TYPE_PROJECT (project_get_type ())
#define PROJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROJECT, Project))
#define PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROJECT, ProjectClass))
#define IS_PROJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROJECT))
#define IS_PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROJECT))
#define PROJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROJECT, ProjectClass))

typedef struct _Project Project;
typedef struct _ProjectClass ProjectClass;

#define TYPE_PIN_DEF (pin_def_get_type ())
#define PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PIN_DEF, PinDef))
#define PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PIN_DEF, PinDefClass))
#define IS_PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PIN_DEF))
#define IS_PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PIN_DEF))
#define PIN_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PIN_DEF, PinDefClass))

typedef struct _PinDef PinDef;
typedef struct _PinDefClass PinDefClass;

#define TYPE_TAG (tag_get_type ())
#define TAG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TAG, Tag))
#define TAG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TAG, TagClass))
#define IS_TAG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TAG))
#define IS_TAG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TAG))
#define TAG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TAG, TagClass))

typedef struct _Tag Tag;
typedef struct _TagClass TagClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _component_def_unref0(var) ((var == NULL) ? NULL : (var = (component_def_unref (var), NULL)))
#define _project_unref0(var) ((var == NULL) ? NULL : (var = (project_unref (var), NULL)))
#define _pin_def_unref0(var) ((var == NULL) ? NULL : (var = (pin_def_unref (var), NULL)))
#define _tag_unref0(var) ((var == NULL) ? NULL : (var = (tag_unref (var), NULL)))
typedef struct _ComponentDefPrivate ComponentDefPrivate;

#define TYPE_DIRECTION (direction_get_type ())

#define TYPE_COMPONENT_INST (component_inst_get_type ())
#define COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_INST, ComponentInst))
#define COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_INST, ComponentInstClass))
#define IS_COMPONENT_INST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_INST))
#define IS_COMPONENT_INST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_INST))
#define COMPONENT_INST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_INST, ComponentInstClass))

typedef struct _ComponentInst ComponentInst;
typedef struct _ComponentInstClass ComponentInstClass;

#define TYPE_PROPERTY_ITEM (property_item_get_type ())
#define PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_ITEM, PropertyItem))
#define PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_ITEM, PropertyItemClass))
#define IS_PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_ITEM))
#define IS_PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_ITEM))
#define PROPERTY_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_ITEM, PropertyItemClass))

typedef struct _PropertyItem PropertyItem;
typedef struct _PropertyItemClass PropertyItemClass;

#define TYPE_PROPERTY_SET (property_set_get_type ())
#define PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_SET, PropertySet))
#define PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_SET, PropertySetClass))
#define IS_PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_SET))
#define IS_PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_SET))
#define PROPERTY_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_SET, PropertySetClass))

typedef struct _PropertySet PropertySet;
typedef struct _PropertySetClass PropertySetClass;

#define TYPE_COMPILED_CIRCUIT (compiled_circuit_get_type ())
#define COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuit))
#define COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))
#define IS_COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPILED_CIRCUIT))
#define IS_COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPILED_CIRCUIT))
#define COMPILED_CIRCUIT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))

typedef struct _CompiledCircuit CompiledCircuit;
typedef struct _CompiledCircuitClass CompiledCircuitClass;

#define TYPE_CONNECTION (connection_get_type ())
#define CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONNECTION, Connection))
#define CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONNECTION, ConnectionClass))
#define IS_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONNECTION))
#define IS_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONNECTION))
#define CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONNECTION, ConnectionClass))

typedef struct _Connection Connection;
typedef struct _ConnectionClass ConnectionClass;

#define TYPE_CIRCUIT_INFORMATION (circuit_information_get_type ())
#define CIRCUIT_INFORMATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CIRCUIT_INFORMATION, CircuitInformation))
#define CIRCUIT_INFORMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CIRCUIT_INFORMATION, CircuitInformationClass))
#define IS_CIRCUIT_INFORMATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CIRCUIT_INFORMATION))
#define IS_CIRCUIT_INFORMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CIRCUIT_INFORMATION))
#define CIRCUIT_INFORMATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CIRCUIT_INFORMATION, CircuitInformationClass))

typedef struct _CircuitInformation CircuitInformation;
typedef struct _CircuitInformationClass CircuitInformationClass;

#define TYPE_GRAPHIC (graphic_get_type ())
#define GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GRAPHIC, Graphic))
#define GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GRAPHIC, GraphicClass))
#define IS_GRAPHIC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GRAPHIC))
#define IS_GRAPHIC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GRAPHIC))
#define GRAPHIC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GRAPHIC, GraphicClass))

typedef struct _Graphic Graphic;
typedef struct _GraphicClass GraphicClass;
typedef struct _TagPrivate TagPrivate;

#define TYPE_FLOW (flow_get_type ())

#define PIN_DEF_TYPE_LABEL_TYPE (pin_def_label_type_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _PinDefPrivate PinDefPrivate;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
typedef struct _DesignerWindowPrivate DesignerWindowPrivate;
typedef struct _ParamSpecCustomiser ParamSpecCustomiser;

struct _Customiser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	CustomiserPrivate * priv;
	gint gridSize;
	gfloat zoom;
};

struct _CustomiserClass {
	GTypeClass parent_class;
	void (*finalize) (Customiser *self);
};

typedef enum  {
	CUSTOMISER_MOUSE_MODE_SCROLL,
	CUSTOMISER_MOUSE_MODE_ZOOM,
	CUSTOMISER_MOUSE_MODE_PIN
} CustomiserMouseMode;

struct _CustomiserPrivate {
	GtkDialog* dialog;
	GtkBox* layoutHBox;
	GtkBox* layoutVBox;
	GtkRadioToolButton* hiddenRadioToolButton;
	GtkToolbar* toolbar;
	GtkRadioToolButton* toolScroll;
	GtkImage* toolScrollImage;
	GtkRadioToolButton* toolZoom;
	GtkImage* toolZoomImage;
	GtkSeparatorToolItem* toolSeparator1;
	GtkRadioToolButton* toolPin;
	GtkImage* toolPinImage;
	GtkEventBox* controller;
	GtkDrawingArea* display;
	GtkBox* controlsVBox;
	GtkBox* nameHBox;
	GtkEntry* nameEntry;
	GtkLabel* nameLabel;
	GtkBox* descriptionHBox;
	GtkEntry* descriptionEntry;
	GtkLabel* descriptionLabel;
	GtkBox* labelHBox;
	GtkEntry* labelEntry;
	GtkLabel* labelLabel;
	GtkBox* pinHBox;
	GtkSpinButton* pinSpinButton;
	GtkLabel* pinLabel;
	GtkLabel* tagNameLabel;
	GtkCheckButton* requiredCheck;
	GtkBox* labelTypeVBox;
	GtkLabel* labelTypeLabel;
	GtkRadioButton* labelTypeNoneRadio;
	GtkRadioButton* labelTypeTextRadio;
	GtkRadioButton* labelTypeTextBarRadio;
	GtkRadioButton* labelTypeClockRadio;
	GtkBox* pinLabelHBox;
	GtkEntry* pinLabelEntry;
	GtkLabel* pinLabelLabel;
	GtkLabel* boundsLabel;
	GtkGrid* boundsGrid;
	GtkLabel* rightBoundLabel;
	GtkSpinButton* rightBoundSpinButton;
	GtkLabel* downBoundLabel;
	GtkSpinButton* downBoundSpinButton;
	GtkLabel* leftBoundLabel;
	GtkSpinButton* leftBoundSpinButton;
	GtkLabel* upBoundLabel;
	GtkSpinButton* upBoundSpinButton;
	GtkButton* colourButton;
	GtkButton* closeButton;
	cairo_surface_t* gridCache;
	gint xView;
	gint yView;
	CustomiserMouseMode mouseMode;
	CustomComponentDef* customComponentDef;
	DesignerWindow* parent;
	Project* project;
	gint selectedPinID;
	PinDef* selectedPin;
	gint xMouseStart;
	gint yMouseStart;
	Tag* tag;
};

typedef enum  {
	DIRECTION_NONE,
	DIRECTION_RIGHT,
	DIRECTION_DOWN,
	DIRECTION_LEFT,
	DIRECTION_UP,
	DIRECTION_HORIZONTAL,
	DIRECTION_VERTICAL,
	DIRECTION_DIAGONAL
} Direction;

struct _ComponentDef {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ComponentDefPrivate * priv;
	Graphic* graphic;
	gchar* graphicReferenceFilename;
	gchar* name;
	gchar* description;
	gchar* iconFilename;
	gchar* label;
	PinDef** pinDefs;
	gint pinDefs_length1;
	gint rightBound;
	gint downBound;
	gint leftBound;
	gint upBound;
	gint backgroundAlpha;
	gint backgroundRed;
	gint backgroundGreen;
	gint backgroundBlue;
	gdouble backgroundAlphaF;
	gdouble backgroundRedF;
	gdouble backgroundGreenF;
	gdouble backgroundBlueF;
	gboolean drawBox;
	gchar* filename;
};

struct _ComponentDefClass {
	GTypeClass parent_class;
	void (*finalize) (ComponentDef *self);
	void (*extra_render) (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst);
	void (*extra_validate) (ComponentDef* self, Project* project, CustomComponentDef** componentChain, int componentChain_length1, ComponentInst* componentInst);
	void (*add_properties) (ComponentDef* self, PropertySet* queryProperty, PropertySet* configurationProperty);
	void (*get_properties) (ComponentDef* self, PropertySet* queryProperty, PropertySet** configurationProperty);
	void (*load_properties) (ComponentDef* self, xmlNode* xmlnode, PropertySet** configurationProperty);
	void (*save_properties) (ComponentDef* self, xmlTextWriter* xmlWriter, PropertySet* configurationProperty);
	void (*configure_inst) (ComponentDef* self, ComponentInst* componentInst, gboolean firstLoad);
	void (*compile_component) (ComponentDef* self, CompiledCircuit* compiledCircuit, ComponentInst* componentInst, Connection** connections, int connections_length1, ComponentInst** ancestry, int ancestry_length1);
	void (*create_information) (ComponentDef* self, CircuitInformation* circuitInformation);
};

typedef enum  {
	FLOW_NONE,
	FLOW_IN,
	FLOW_OUT,
	FLOW_BIDIRECTIONAL
} Flow;

struct _Tag {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TagPrivate * priv;
	gchar* text;
	gint xTag;
	gint yTag;
	gint xWire;
	gint yWire;
	gint pinid;
	Flow flow;
	Direction direction;
	gint rightBound;
	gint downBound;
	gint leftBound;
	gint upBound;
};

struct _TagClass {
	GTypeClass parent_class;
	void (*finalize) (Tag *self);
};

typedef enum  {
	PIN_DEF_LABEL_TYPE_NONE,
	PIN_DEF_LABEL_TYPE_TEXT,
	PIN_DEF_LABEL_TYPE_TEXTBAR,
	PIN_DEF_LABEL_TYPE_CLOCK
} PinDefLabelType;

struct _PinDef {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PinDefPrivate * priv;
	gint x;
	gint y;
	gint xLabel;
	gint yLabel;
	gint xConnect;
	gint yConnect;
	Direction direction;
	gint length;
	gboolean array;
	Flow flow;
	gint defaultArraySize;
	gint idealSpace;
	gfloat minSpace;
	gchar* label;
	gboolean required;
	gboolean userArrayResize;
	gboolean showDefault;
	PinDefLabelType labelType;
};

struct _PinDefClass {
	GTypeClass parent_class;
	void (*finalize) (PinDef *self);
};

struct _DesignerWindow {
	GtkWindow parent_instance;
	DesignerWindowPrivate * priv;
	gint myID;
	gchar* componentFileName;
	gint gridSize;
	gfloat zoom;
	gboolean showGrid;
	gboolean liveScrollUpdate;
	gboolean shadowComponent;
};

struct _DesignerWindowClass {
	GtkWindowClass parent_class;
};

struct _ParamSpecCustomiser {
	GParamSpec parent_instance;
};


static gpointer customiser_parent_class = NULL;

gpointer customiser_ref (gpointer instance);
void customiser_unref (gpointer instance);
GParamSpec* param_spec_customiser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_customiser (GValue* value, gpointer v_object);
void value_take_customiser (GValue* value, gpointer v_object);
gpointer value_get_customiser (const GValue* value);
GType customiser_get_type (void) G_GNUC_CONST;
static GType customiser_mouse_mode_get_type (void) G_GNUC_UNUSED;
gpointer component_def_ref (gpointer instance);
void component_def_unref (gpointer instance);
GParamSpec* param_spec_component_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_def (GValue* value, gpointer v_object);
void value_take_component_def (GValue* value, gpointer v_object);
gpointer value_get_component_def (const GValue* value);
GType component_def_get_type (void) G_GNUC_CONST;
GType custom_component_def_get_type (void) G_GNUC_CONST;
GType designer_window_get_type (void) G_GNUC_CONST;
gpointer project_ref (gpointer instance);
void project_unref (gpointer instance);
GParamSpec* param_spec_project (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_project (GValue* value, gpointer v_object);
void value_take_project (GValue* value, gpointer v_object);
gpointer value_get_project (const GValue* value);
GType project_get_type (void) G_GNUC_CONST;
gpointer pin_def_ref (gpointer instance);
void pin_def_unref (gpointer instance);
GParamSpec* param_spec_pin_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_pin_def (GValue* value, gpointer v_object);
void value_take_pin_def (GValue* value, gpointer v_object);
gpointer value_get_pin_def (const GValue* value);
GType pin_def_get_type (void) G_GNUC_CONST;
gpointer tag_ref (gpointer instance);
void tag_unref (gpointer instance);
GParamSpec* param_spec_tag (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_tag (GValue* value, gpointer v_object);
void value_take_tag (GValue* value, gpointer v_object);
gpointer value_get_tag (const GValue* value);
GType tag_get_type (void) G_GNUC_CONST;
#define CUSTOMISER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CUSTOMISER, CustomiserPrivate))
enum  {
	CUSTOMISER_DUMMY_PROPERTY
};
Customiser* customiser_new (DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project);
Customiser* customiser_construct (GType object_type, DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project);
gint custom_component_def_count_tags (CustomComponentDef* self);
GType direction_get_type (void) G_GNUC_CONST;
gpointer component_inst_ref (gpointer instance);
void component_inst_unref (gpointer instance);
GParamSpec* param_spec_component_inst (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_inst (GValue* value, gpointer v_object);
void value_take_component_inst (GValue* value, gpointer v_object);
gpointer value_get_component_inst (const GValue* value);
GType component_inst_get_type (void) G_GNUC_CONST;
gpointer property_item_ref (gpointer instance);
void property_item_unref (gpointer instance);
GParamSpec* param_spec_property_item (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_property_item (GValue* value, gpointer v_object);
void value_take_property_item (GValue* value, gpointer v_object);
gpointer value_get_property_item (const GValue* value);
GType property_item_get_type (void) G_GNUC_CONST;
GType property_set_get_type (void) G_GNUC_CONST;
gpointer compiled_circuit_ref (gpointer instance);
void compiled_circuit_unref (gpointer instance);
GParamSpec* param_spec_compiled_circuit (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_compiled_circuit (GValue* value, gpointer v_object);
void value_take_compiled_circuit (GValue* value, gpointer v_object);
gpointer value_get_compiled_circuit (const GValue* value);
GType compiled_circuit_get_type (void) G_GNUC_CONST;
gpointer connection_ref (gpointer instance);
void connection_unref (gpointer instance);
GParamSpec* param_spec_connection (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_connection (GValue* value, gpointer v_object);
void value_take_connection (GValue* value, gpointer v_object);
gpointer value_get_connection (const GValue* value);
GType connection_get_type (void) G_GNUC_CONST;
gpointer circuit_information_ref (gpointer instance);
void circuit_information_unref (gpointer instance);
GParamSpec* param_spec_circuit_information (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_circuit_information (GValue* value, gpointer v_object);
void value_take_circuit_information (GValue* value, gpointer v_object);
gpointer value_get_circuit_information (const GValue* value);
GType circuit_information_get_type (void) G_GNUC_CONST;
gpointer graphic_ref (gpointer instance);
void graphic_unref (gpointer instance);
GParamSpec* param_spec_graphic (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_graphic (GValue* value, gpointer v_object);
void value_take_graphic (GValue* value, gpointer v_object);
gpointer value_get_graphic (const GValue* value);
GType graphic_get_type (void) G_GNUC_CONST;
Tag* custom_component_def_resolve_tag_id (CustomComponentDef* self, gint tagID);
GType flow_get_type (void) G_GNUC_CONST;
GType pin_def_label_type_get_type (void) G_GNUC_CONST;
PinDef* pin_def_new (gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault);
PinDef* pin_def_construct (GType object_type, gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault);
gint custom_component_def_validate_interfaces (CustomComponentDef* self);
void basic_dialog_warning (GtkWindow* window, const gchar* text);
static void customiser_populate (Customiser* self);
void customiser_update_selection (Customiser* self);
static void __lambda56_ (Customiser* self);
static void ___lambda56__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda57_ (Customiser* self);
static void ___lambda57__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda58_ (Customiser* self);
static void ___lambda58__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static gboolean customiser_mouse_down (Customiser* self, GdkEventButton* event);
static gboolean _customiser_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean customiser_mouse_up (Customiser* self, GdkEventButton* event);
static gboolean _customiser_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean __lambda59_ (Customiser* self, cairo_t* context);
gboolean customiser_render_def (Customiser* self, cairo_t* passedDisplayContext);
static gboolean ___lambda59__gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self);
static gboolean __lambda60_ (Customiser* self);
static gboolean ___lambda60__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
static void __lambda61_ (Customiser* self);
static void ___lambda61__gtk_editable_changed (GtkEditable* _sender, gpointer self);
static void _customiser_update_selection_gtk_editable_changed (GtkEditable* _sender, gpointer self);
static void ___lambda62_ (Customiser* self);
static void ____lambda62__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
void customiser_update_label_type (Customiser* self);
static void _customiser_update_label_type_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void ___lambda63_ (Customiser* self);
static void ____lambda63__gtk_editable_changed (GtkEditable* _sender, gpointer self);
void customiser_update_bounds (Customiser* self);
static void _customiser_update_bounds_gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self);
static void __lambda64_ (Customiser* self);
void customiser_set_colour (Customiser* self);
static void ___lambda64__gtk_button_clicked (GtkButton* _sender, gpointer self);
void customiser_response_handler (Customiser* self, gint response_id);
static void _customiser_response_handler_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
void pin_def_set_position (PinDef* self, gint x, gint y, gint length, Direction direction);
void customiser_update_values (Customiser* self);
void customiser_run (Customiser* self);
ComponentDef* project_resolve_def_name (Project* self, const gchar* name);
void basic_dialog_error (GtkWindow* window, const gchar* text);
void component_def_render (ComponentDef* self, cairo_t* context, Direction direction, gboolean flipped, ComponentInst* componentInst, gboolean colourBackground);
void pin_def_render (PinDef* self, cairo_t* context, gboolean invert);
static void customiser_finalize (Customiser* obj);


/**
 * Actions to perform when the mouse button is released.
 */
static GType customiser_mouse_mode_get_type (void) {
	static volatile gsize customiser_mouse_mode_type_id__volatile = 0;
	if (g_once_init_enter (&customiser_mouse_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{CUSTOMISER_MOUSE_MODE_SCROLL, "CUSTOMISER_MOUSE_MODE_SCROLL", "scroll"}, {CUSTOMISER_MOUSE_MODE_ZOOM, "CUSTOMISER_MOUSE_MODE_ZOOM", "zoom"}, {CUSTOMISER_MOUSE_MODE_PIN, "CUSTOMISER_MOUSE_MODE_PIN", "pin"}, {0, NULL, NULL}};
		GType customiser_mouse_mode_type_id;
		customiser_mouse_mode_type_id = g_enum_register_static ("CustomiserMouseMode", values);
		g_once_init_leave (&customiser_mouse_mode_type_id__volatile, customiser_mouse_mode_type_id);
	}
	return customiser_mouse_mode_type_id__volatile;
}


/**
 * Start the customiser, setting the caller DesignerWindow, target 
 * custom component and its project.
 */
static gpointer _component_def_ref0 (gpointer self) {
	return self ? component_def_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _project_ref0 (gpointer self) {
	return self ? project_ref (self) : NULL;
}


Customiser* customiser_construct (GType object_type, DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project) {
	Customiser* self = NULL;
	CustomComponentDef* _tmp0_;
	CustomComponentDef* _tmp1_;
	DesignerWindow* _tmp2_;
	DesignerWindow* _tmp3_;
	Project* _tmp4_;
	Project* _tmp5_;
	CustomComponentDef* _tmp6_;
	gint _tmp7_ = 0;
	gint tagCount;
	CustomComponentDef* _tmp8_;
	gint _tmp9_;
	gint _tmp10_ = 0;
	CustomComponentDef* _tmp36_;
	gint _tmp37_ = 0;
	g_return_val_if_fail (customComponentDef != NULL, NULL);
	g_return_val_if_fail (project != NULL, NULL);
	self = (Customiser*) g_type_create_instance (object_type);
	_tmp0_ = customComponentDef;
	_tmp1_ = _component_def_ref0 (_tmp0_);
	_component_def_unref0 (self->priv->customComponentDef);
	self->priv->customComponentDef = _tmp1_;
	_tmp2_ = parent;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp3_;
	_tmp4_ = project;
	_tmp5_ = _project_ref0 (_tmp4_);
	_project_unref0 (self->priv->project);
	self->priv->project = _tmp5_;
	_tmp6_ = customComponentDef;
	_tmp7_ = custom_component_def_count_tags (_tmp6_);
	tagCount = _tmp7_;
	_tmp8_ = customComponentDef;
	_tmp9_ = tagCount;
	_tmp10_ = _tmp9_;
	((ComponentDef*) _tmp8_)->pinDefs = g_renew (PinDef*, ((ComponentDef*) _tmp8_)->pinDefs, _tmp9_);
	(_tmp10_ > ((ComponentDef*) _tmp8_)->pinDefs_length1) ? memset (((ComponentDef*) _tmp8_)->pinDefs + ((ComponentDef*) _tmp8_)->pinDefs_length1, 0, sizeof (PinDef*) * (_tmp10_ - ((ComponentDef*) _tmp8_)->pinDefs_length1)) : NULL;
	((ComponentDef*) _tmp8_)->pinDefs_length1 = _tmp10_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp11_;
			_tmp11_ = TRUE;
			while (TRUE) {
				gboolean _tmp12_;
				gint _tmp14_;
				gint _tmp15_;
				CustomComponentDef* _tmp16_;
				PinDef** _tmp17_;
				gint _tmp17__length1;
				gint _tmp18_;
				PinDef* _tmp19_;
				_tmp12_ = _tmp11_;
				if (!_tmp12_) {
					gint _tmp13_;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp11_ = FALSE;
				_tmp14_ = i;
				_tmp15_ = tagCount;
				if (!(_tmp14_ < _tmp15_)) {
					break;
				}
				_tmp16_ = customComponentDef;
				_tmp17_ = ((ComponentDef*) _tmp16_)->pinDefs;
				_tmp17__length1 = ((ComponentDef*) _tmp16_)->pinDefs_length1;
				_tmp18_ = i;
				_tmp19_ = _tmp17_[_tmp18_];
				if (_tmp19_ == NULL) {
					CustomComponentDef* _tmp20_;
					gint _tmp21_;
					Tag* _tmp22_ = NULL;
					Tag* resolvedTag;
					Tag* _tmp23_;
					_tmp20_ = customComponentDef;
					_tmp21_ = i;
					_tmp22_ = custom_component_def_resolve_tag_id (_tmp20_, _tmp21_);
					resolvedTag = _tmp22_;
					_tmp23_ = resolvedTag;
					if (_tmp23_ != NULL) {
						CustomComponentDef* _tmp24_;
						PinDef** _tmp25_;
						gint _tmp25__length1;
						gint _tmp26_;
						Tag* _tmp27_;
						Flow _tmp28_;
						PinDef* _tmp29_;
						PinDef* _tmp30_;
						_tmp24_ = customComponentDef;
						_tmp25_ = ((ComponentDef*) _tmp24_)->pinDefs;
						_tmp25__length1 = ((ComponentDef*) _tmp24_)->pinDefs_length1;
						_tmp26_ = i;
						_tmp27_ = resolvedTag;
						_tmp28_ = _tmp27_->flow;
						_tmp29_ = pin_def_new (0, 0, DIRECTION_RIGHT, _tmp28_, 0, FALSE, 1, 0, (gfloat) 0, "", PIN_DEF_LABEL_TYPE_NONE, TRUE, TRUE, TRUE);
						_pin_def_unref0 (_tmp25_[_tmp26_]);
						_tmp25_[_tmp26_] = _tmp29_;
						_tmp30_ = _tmp25_[_tmp26_];
					} else {
						CustomComponentDef* _tmp31_;
						PinDef** _tmp32_;
						gint _tmp32__length1;
						gint _tmp33_;
						PinDef* _tmp34_;
						PinDef* _tmp35_;
						_tmp31_ = customComponentDef;
						_tmp32_ = ((ComponentDef*) _tmp31_)->pinDefs;
						_tmp32__length1 = ((ComponentDef*) _tmp31_)->pinDefs_length1;
						_tmp33_ = i;
						_tmp34_ = pin_def_new (0, 0, DIRECTION_RIGHT, FLOW_NONE, 0, FALSE, 1, 0, (gfloat) 0, "", PIN_DEF_LABEL_TYPE_NONE, TRUE, TRUE, TRUE);
						_pin_def_unref0 (_tmp32_[_tmp33_]);
						_tmp32_[_tmp33_] = _tmp34_;
						_tmp35_ = _tmp32_[_tmp33_];
					}
					_tag_unref0 (resolvedTag);
				}
			}
		}
	}
	_tmp36_ = customComponentDef;
	_tmp37_ = custom_component_def_validate_interfaces (_tmp36_);
	if (_tmp37_ != 0) {
		basic_dialog_warning (NULL, "Warning:\n" \
"Could not associate all pins with interface tags. Make sure that all t" \
"ags have unique and sequential IDs starting with 0. You can cycle thro" \
"ugh the pins to check the associations.\n");
	}
	customiser_populate (self);
	customiser_update_selection (self);
	return self;
}


Customiser* customiser_new (DesignerWindow* parent, CustomComponentDef* customComponentDef, Project* project) {
	return customiser_construct (TYPE_CUSTOMISER, parent, customComponentDef, project);
}


/**
 * Create a new Gtk Dialog and populate it with widgets
 */
static void __lambda56_ (Customiser* self) {
	self->priv->mouseMode = CUSTOMISER_MOUSE_MODE_SCROLL;
}


static void ___lambda56__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda56_ (self);
}


static void __lambda57_ (Customiser* self) {
	self->priv->mouseMode = CUSTOMISER_MOUSE_MODE_ZOOM;
}


static void ___lambda57__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda57_ (self);
}


static void __lambda58_ (Customiser* self) {
	self->priv->mouseMode = CUSTOMISER_MOUSE_MODE_PIN;
}


static void ___lambda58__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda58_ (self);
}


static gboolean _customiser_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = customiser_mouse_down (self, event);
	return result;
}


static gboolean _customiser_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = customiser_mouse_up (self, event);
	return result;
}


static gboolean __lambda59_ (Customiser* self, cairo_t* context) {
	gboolean result = FALSE;
	cairo_t* _tmp0_;
	g_return_val_if_fail (context != NULL, FALSE);
	_tmp0_ = context;
	customiser_render_def (self, _tmp0_);
	result = FALSE;
	return result;
}


static gboolean ___lambda59__gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self) {
	gboolean result;
	result = __lambda59_ (self, cr);
	return result;
}


static gboolean __lambda60_ (Customiser* self) {
	gboolean result = FALSE;
	_cairo_surface_destroy0 (self->priv->gridCache);
	self->priv->gridCache = NULL;
	customiser_render_def (self, NULL);
	result = FALSE;
	return result;
}


static gboolean ___lambda60__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = __lambda60_ (self);
	return result;
}


static void __lambda61_ (Customiser* self) {
	CustomComponentDef* _tmp0_;
	GtkEntry* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = self->priv->customComponentDef;
	_tmp1_ = self->priv->labelEntry;
	_tmp2_ = gtk_entry_get_text (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 (((ComponentDef*) _tmp0_)->label);
	((ComponentDef*) _tmp0_)->label = _tmp4_;
	customiser_render_def (self, NULL);
}


static void ___lambda61__gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	__lambda61_ (self);
}


static gpointer _pin_def_ref0 (gpointer self) {
	return self ? pin_def_ref (self) : NULL;
}


static void _customiser_update_selection_gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	customiser_update_selection (self);
}


static void ___lambda62_ (Customiser* self) {
	PinDef* _tmp0_;
	_tmp0_ = self->priv->selectedPin;
	if (_tmp0_ != NULL) {
		PinDef* _tmp1_;
		GtkCheckButton* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp1_ = self->priv->selectedPin;
		_tmp2_ = self->priv->requiredCheck;
		_tmp3_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp1_->required = _tmp4_;
	}
}


static void ____lambda62__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	___lambda62_ (self);
}


static void _customiser_update_label_type_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	customiser_update_label_type (self);
}


static void ___lambda63_ (Customiser* self) {
	PinDef* _tmp0_;
	_tmp0_ = self->priv->selectedPin;
	if (_tmp0_ != NULL) {
		PinDef* _tmp1_;
		GtkEntry* _tmp2_;
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		gchar* _tmp5_;
		_tmp1_ = self->priv->selectedPin;
		_tmp2_ = self->priv->pinLabelEntry;
		_tmp3_ = gtk_entry_get_text (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (_tmp1_->label);
		_tmp1_->label = _tmp5_;
		customiser_render_def (self, NULL);
	}
}


static void ____lambda63__gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	___lambda63_ (self);
}


static void _customiser_update_bounds_gtk_spin_button_value_changed (GtkSpinButton* _sender, gpointer self) {
	customiser_update_bounds (self);
}


static void __lambda64_ (Customiser* self) {
	customiser_set_colour (self);
}


static void ___lambda64__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda64_ (self);
}


static void _customiser_response_handler_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	customiser_response_handler (self, response_id);
}


static void customiser_populate (Customiser* self) {
	DesignerWindow* _tmp0_;
	GtkDialog* _tmp1_;
	GtkDialog* _tmp2_;
	GtkBox* _tmp3_ = NULL;
	GtkBox* _tmp4_;
	GtkBox* content;
	GtkDialog* _tmp5_;
	GtkDialog* _tmp6_;
	GtkBox* _tmp7_;
	GtkBox* _tmp8_;
	GtkBox* _tmp9_;
	GtkBox* _tmp10_;
	GtkBox* _tmp11_;
	GtkBox* _tmp12_;
	GtkRadioToolButton* _tmp13_;
	GtkToolbar* _tmp14_;
	GtkToolbar* _tmp15_;
	GtkBox* _tmp16_;
	GtkToolbar* _tmp17_;
	GtkImage* _tmp18_;
	GtkRadioToolButton* _tmp19_;
	GtkRadioToolButton* _tmp20_;
	GtkRadioToolButton* _tmp21_;
	GtkRadioToolButton* _tmp22_;
	GtkImage* _tmp23_;
	GtkToolbar* _tmp24_;
	GtkRadioToolButton* _tmp25_;
	GtkRadioToolButton* _tmp26_;
	GtkRadioToolButton* _tmp27_;
	GtkImage* _tmp28_;
	GtkRadioToolButton* _tmp29_;
	GtkRadioToolButton* _tmp30_;
	GtkRadioToolButton* _tmp31_;
	GtkRadioToolButton* _tmp32_;
	GtkImage* _tmp33_;
	GtkToolbar* _tmp34_;
	GtkRadioToolButton* _tmp35_;
	GtkRadioToolButton* _tmp36_;
	GtkRadioToolButton* _tmp37_;
	GtkSeparatorToolItem* _tmp38_;
	GtkToolbar* _tmp39_;
	GtkSeparatorToolItem* _tmp40_;
	GtkImage* _tmp41_;
	GtkRadioToolButton* _tmp42_;
	GtkRadioToolButton* _tmp43_;
	GtkRadioToolButton* _tmp44_;
	GtkRadioToolButton* _tmp45_;
	GtkImage* _tmp46_;
	GtkToolbar* _tmp47_;
	GtkRadioToolButton* _tmp48_;
	GtkRadioToolButton* _tmp49_;
	GtkRadioToolButton* _tmp50_;
	GtkRadioToolButton* _tmp51_;
	GtkEventBox* _tmp52_;
	GtkBox* _tmp53_;
	GtkEventBox* _tmp54_;
	GtkEventBox* _tmp55_;
	GtkEventBox* _tmp56_;
	GtkDrawingArea* _tmp57_;
	GtkEventBox* _tmp58_;
	GtkDrawingArea* _tmp59_;
	GtkDrawingArea* _tmp60_;
	GtkDrawingArea* _tmp61_;
	GtkBox* _tmp62_;
	GtkBox* _tmp63_;
	GtkBox* _tmp64_;
	GtkBox* _tmp65_;
	GtkBox* _tmp66_;
	GtkBox* _tmp67_;
	GtkLabel* _tmp68_;
	GtkBox* _tmp69_;
	GtkLabel* _tmp70_;
	GtkEntry* _tmp71_;
	GtkEntry* _tmp72_;
	CustomComponentDef* _tmp73_;
	const gchar* _tmp74_;
	GtkBox* _tmp75_;
	GtkEntry* _tmp76_;
	GtkBox* _tmp77_;
	GtkBox* _tmp78_;
	GtkBox* _tmp79_;
	GtkLabel* _tmp80_;
	GtkBox* _tmp81_;
	GtkLabel* _tmp82_;
	GtkEntry* _tmp83_;
	GtkEntry* _tmp84_;
	CustomComponentDef* _tmp85_;
	const gchar* _tmp86_;
	GtkBox* _tmp87_;
	GtkEntry* _tmp88_;
	GtkBox* _tmp89_;
	GtkBox* _tmp90_;
	GtkBox* _tmp91_;
	GtkLabel* _tmp92_;
	GtkBox* _tmp93_;
	GtkLabel* _tmp94_;
	GtkEntry* _tmp95_;
	GtkEntry* _tmp96_;
	CustomComponentDef* _tmp97_;
	const gchar* _tmp98_;
	GtkEntry* _tmp99_;
	GtkBox* _tmp100_;
	GtkEntry* _tmp101_;
	CustomComponentDef* _tmp102_;
	PinDef** _tmp103_;
	gint _tmp103__length1;
	GtkLabel* _tmp179_;
	GtkBox* _tmp180_;
	GtkLabel* _tmp181_;
	GtkGrid* _tmp182_;
	GtkBox* _tmp183_;
	GtkGrid* _tmp184_;
	GtkLabel* _tmp185_;
	GtkGrid* _tmp186_;
	GtkLabel* _tmp187_;
	gint _tmp188_;
	GtkSpinButton* _tmp189_;
	GtkSpinButton* _tmp190_;
	CustomComponentDef* _tmp191_;
	gint _tmp192_;
	GtkSpinButton* _tmp193_;
	GtkGrid* _tmp194_;
	GtkSpinButton* _tmp195_;
	GtkLabel* _tmp196_;
	GtkGrid* _tmp197_;
	GtkLabel* _tmp198_;
	gint _tmp199_;
	GtkSpinButton* _tmp200_;
	GtkSpinButton* _tmp201_;
	CustomComponentDef* _tmp202_;
	gint _tmp203_;
	GtkSpinButton* _tmp204_;
	GtkGrid* _tmp205_;
	GtkSpinButton* _tmp206_;
	GtkLabel* _tmp207_;
	GtkGrid* _tmp208_;
	GtkLabel* _tmp209_;
	gint _tmp210_;
	GtkSpinButton* _tmp211_;
	GtkSpinButton* _tmp212_;
	CustomComponentDef* _tmp213_;
	gint _tmp214_;
	GtkSpinButton* _tmp215_;
	GtkGrid* _tmp216_;
	GtkSpinButton* _tmp217_;
	GtkLabel* _tmp218_;
	GtkGrid* _tmp219_;
	GtkLabel* _tmp220_;
	gint _tmp221_;
	GtkSpinButton* _tmp222_;
	GtkSpinButton* _tmp223_;
	CustomComponentDef* _tmp224_;
	gint _tmp225_;
	GtkSpinButton* _tmp226_;
	GtkGrid* _tmp227_;
	GtkSpinButton* _tmp228_;
	GtkButton* _tmp229_;
	GtkButton* _tmp230_;
	GtkBox* _tmp231_;
	GtkButton* _tmp232_;
	GtkDialog* _tmp233_;
	GtkButton* _tmp234_;
	GtkDialog* _tmp235_;
	GtkButton* _tmp236_;
	GtkDialog* _tmp237_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->parent;
	_tmp1_ = (GtkDialog*) gtk_dialog_new_with_buttons ("Customise Component", (GtkWindow*) _tmp0_, GTK_DIALOG_MODAL, NULL);
	g_object_ref_sink (_tmp1_);
	_g_object_unref0 (self->priv->dialog);
	self->priv->dialog = _tmp1_;
	_tmp2_ = self->priv->dialog;
	_tmp3_ = gtk_dialog_get_content_area (_tmp2_);
	_tmp4_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, GTK_TYPE_BOX) ? ((GtkBox*) _tmp3_) : NULL);
	content = _tmp4_;
	_tmp5_ = self->priv->dialog;
	gtk_window_set_default_size ((GtkWindow*) _tmp5_, 600, 200);
	_tmp6_ = self->priv->dialog;
	gtk_container_set_border_width ((GtkContainer*) _tmp6_, (guint) 1);
	_tmp7_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
	g_object_ref_sink (_tmp7_);
	_g_object_unref0 (self->priv->layoutHBox);
	self->priv->layoutHBox = _tmp7_;
	_tmp8_ = content;
	_tmp9_ = self->priv->layoutHBox;
	gtk_box_pack_start (_tmp8_, (GtkWidget*) _tmp9_, TRUE, TRUE, (guint) 1);
	_tmp10_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
	g_object_ref_sink (_tmp10_);
	_g_object_unref0 (self->priv->layoutVBox);
	self->priv->layoutVBox = _tmp10_;
	_tmp11_ = self->priv->layoutHBox;
	_tmp12_ = self->priv->layoutVBox;
	gtk_box_pack_start (_tmp11_, (GtkWidget*) _tmp12_, TRUE, TRUE, (guint) 1);
	_tmp13_ = (GtkRadioToolButton*) gtk_radio_tool_button_new (NULL);
	g_object_ref_sink (_tmp13_);
	_g_object_unref0 (self->priv->hiddenRadioToolButton);
	self->priv->hiddenRadioToolButton = _tmp13_;
	_tmp14_ = (GtkToolbar*) gtk_toolbar_new ();
	g_object_ref_sink (_tmp14_);
	_g_object_unref0 (self->priv->toolbar);
	self->priv->toolbar = _tmp14_;
	_tmp15_ = self->priv->toolbar;
	g_object_set (_tmp15_, "toolbar-style", GTK_TOOLBAR_ICONS, NULL);
	_tmp16_ = self->priv->layoutVBox;
	_tmp17_ = self->priv->toolbar;
	gtk_box_pack_start (_tmp16_, (GtkWidget*) _tmp17_, FALSE, TRUE, (guint) 0);
	_tmp18_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/scroll.png");
	g_object_ref_sink (_tmp18_);
	_g_object_unref0 (self->priv->toolScrollImage);
	self->priv->toolScrollImage = _tmp18_;
	_tmp19_ = self->priv->hiddenRadioToolButton;
	_tmp20_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp19_);
	g_object_ref_sink (_tmp20_);
	_g_object_unref0 (self->priv->toolScroll);
	self->priv->toolScroll = _tmp20_;
	_tmp21_ = self->priv->toolScroll;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp21_, "Scroll");
	_tmp22_ = self->priv->toolScroll;
	_tmp23_ = self->priv->toolScrollImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp22_, (GtkWidget*) _tmp23_);
	_tmp24_ = self->priv->toolbar;
	_tmp25_ = self->priv->toolScroll;
	gtk_toolbar_insert (_tmp24_, (GtkToolItem*) _tmp25_, -1);
	_tmp26_ = self->priv->toolScroll;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp26_, "Scroll: Move your view of the component with click and drag.");
	_tmp27_ = self->priv->toolScroll;
	g_signal_connect ((GtkToolButton*) _tmp27_, "clicked", (GCallback) ___lambda56__gtk_tool_button_clicked, self);
	_tmp28_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/zoom.png");
	g_object_ref_sink (_tmp28_);
	_g_object_unref0 (self->priv->toolZoomImage);
	self->priv->toolZoomImage = _tmp28_;
	_tmp29_ = self->priv->hiddenRadioToolButton;
	_tmp30_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp29_);
	g_object_ref_sink (_tmp30_);
	_g_object_unref0 (self->priv->toolZoom);
	self->priv->toolZoom = _tmp30_;
	_tmp31_ = self->priv->toolZoom;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp31_, "Zoom");
	_tmp32_ = self->priv->toolZoom;
	_tmp33_ = self->priv->toolZoomImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp32_, (GtkWidget*) _tmp33_);
	_tmp34_ = self->priv->toolbar;
	_tmp35_ = self->priv->toolZoom;
	gtk_toolbar_insert (_tmp34_, (GtkToolItem*) _tmp35_, -1);
	_tmp36_ = self->priv->toolZoom;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp36_, "Zoom: Drag downward to zoom in or upward to zoom out.");
	_tmp37_ = self->priv->toolZoom;
	g_signal_connect ((GtkToolButton*) _tmp37_, "clicked", (GCallback) ___lambda57__gtk_tool_button_clicked, self);
	_tmp38_ = (GtkSeparatorToolItem*) gtk_separator_tool_item_new ();
	g_object_ref_sink (_tmp38_);
	_g_object_unref0 (self->priv->toolSeparator1);
	self->priv->toolSeparator1 = _tmp38_;
	_tmp39_ = self->priv->toolbar;
	_tmp40_ = self->priv->toolSeparator1;
	gtk_toolbar_insert (_tmp39_, (GtkToolItem*) _tmp40_, -1);
	_tmp41_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/pin.png");
	g_object_ref_sink (_tmp41_);
	_g_object_unref0 (self->priv->toolPinImage);
	self->priv->toolPinImage = _tmp41_;
	_tmp42_ = self->priv->hiddenRadioToolButton;
	_tmp43_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp42_);
	g_object_ref_sink (_tmp43_);
	_g_object_unref0 (self->priv->toolPin);
	self->priv->toolPin = _tmp43_;
	_tmp44_ = self->priv->toolPin;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp44_, "Pin");
	_tmp45_ = self->priv->toolPin;
	_tmp46_ = self->priv->toolPinImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp45_, (GtkWidget*) _tmp46_);
	_tmp47_ = self->priv->toolbar;
	_tmp48_ = self->priv->toolPin;
	gtk_toolbar_insert (_tmp47_, (GtkToolItem*) _tmp48_, -1);
	_tmp49_ = self->priv->toolPin;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp49_, "Pin: Click outside the component to position a pin.");
	_tmp50_ = self->priv->toolPin;
	g_signal_connect ((GtkToolButton*) _tmp50_, "clicked", (GCallback) ___lambda58__gtk_tool_button_clicked, self);
	_tmp51_ = self->priv->toolPin;
	gtk_toggle_tool_button_set_active ((GtkToggleToolButton*) _tmp51_, TRUE);
	_tmp52_ = (GtkEventBox*) gtk_event_box_new ();
	g_object_ref_sink (_tmp52_);
	_g_object_unref0 (self->priv->controller);
	self->priv->controller = _tmp52_;
	_tmp53_ = self->priv->layoutVBox;
	_tmp54_ = self->priv->controller;
	gtk_box_pack_start (_tmp53_, (GtkWidget*) _tmp54_, TRUE, TRUE, (guint) 1);
	_tmp55_ = self->priv->controller;
	g_signal_connect ((GtkWidget*) _tmp55_, "button-press-event", (GCallback) _customiser_mouse_down_gtk_widget_button_press_event, self);
	_tmp56_ = self->priv->controller;
	g_signal_connect ((GtkWidget*) _tmp56_, "button-release-event", (GCallback) _customiser_mouse_up_gtk_widget_button_release_event, self);
	_tmp57_ = (GtkDrawingArea*) gtk_drawing_area_new ();
	g_object_ref_sink (_tmp57_);
	_g_object_unref0 (self->priv->display);
	self->priv->display = _tmp57_;
	_tmp58_ = self->priv->controller;
	_tmp59_ = self->priv->display;
	gtk_container_add ((GtkContainer*) _tmp58_, (GtkWidget*) _tmp59_);
	_tmp60_ = self->priv->display;
	g_signal_connect ((GtkWidget*) _tmp60_, "draw", (GCallback) ___lambda59__gtk_widget_draw, self);
	_tmp61_ = self->priv->display;
	g_signal_connect ((GtkWidget*) _tmp61_, "configure-event", (GCallback) ___lambda60__gtk_widget_configure_event, self);
	_tmp62_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
	g_object_ref_sink (_tmp62_);
	_g_object_unref0 (self->priv->controlsVBox);
	self->priv->controlsVBox = _tmp62_;
	_tmp63_ = self->priv->layoutHBox;
	_tmp64_ = self->priv->controlsVBox;
	gtk_box_pack_start (_tmp63_, (GtkWidget*) _tmp64_, FALSE, TRUE, (guint) 1);
	_tmp65_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
	g_object_ref_sink (_tmp65_);
	_g_object_unref0 (self->priv->nameHBox);
	self->priv->nameHBox = _tmp65_;
	_tmp66_ = self->priv->controlsVBox;
	_tmp67_ = self->priv->nameHBox;
	gtk_box_pack_start (_tmp66_, (GtkWidget*) _tmp67_, FALSE, TRUE, (guint) 1);
	_tmp68_ = (GtkLabel*) gtk_label_new ("Name:");
	g_object_ref_sink (_tmp68_);
	_g_object_unref0 (self->priv->nameLabel);
	self->priv->nameLabel = _tmp68_;
	_tmp69_ = self->priv->nameHBox;
	_tmp70_ = self->priv->nameLabel;
	gtk_box_pack_start (_tmp69_, (GtkWidget*) _tmp70_, FALSE, TRUE, (guint) 1);
	_tmp71_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp71_);
	_g_object_unref0 (self->priv->nameEntry);
	self->priv->nameEntry = _tmp71_;
	_tmp72_ = self->priv->nameEntry;
	_tmp73_ = self->priv->customComponentDef;
	_tmp74_ = ((ComponentDef*) _tmp73_)->name;
	gtk_entry_set_text (_tmp72_, _tmp74_);
	_tmp75_ = self->priv->nameHBox;
	_tmp76_ = self->priv->nameEntry;
	gtk_box_pack_start (_tmp75_, (GtkWidget*) _tmp76_, TRUE, TRUE, (guint) 1);
	_tmp77_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
	g_object_ref_sink (_tmp77_);
	_g_object_unref0 (self->priv->descriptionHBox);
	self->priv->descriptionHBox = _tmp77_;
	_tmp78_ = self->priv->controlsVBox;
	_tmp79_ = self->priv->descriptionHBox;
	gtk_box_pack_start (_tmp78_, (GtkWidget*) _tmp79_, FALSE, TRUE, (guint) 1);
	_tmp80_ = (GtkLabel*) gtk_label_new ("Description:");
	g_object_ref_sink (_tmp80_);
	_g_object_unref0 (self->priv->descriptionLabel);
	self->priv->descriptionLabel = _tmp80_;
	_tmp81_ = self->priv->descriptionHBox;
	_tmp82_ = self->priv->descriptionLabel;
	gtk_box_pack_start (_tmp81_, (GtkWidget*) _tmp82_, FALSE, TRUE, (guint) 1);
	_tmp83_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp83_);
	_g_object_unref0 (self->priv->descriptionEntry);
	self->priv->descriptionEntry = _tmp83_;
	_tmp84_ = self->priv->descriptionEntry;
	_tmp85_ = self->priv->customComponentDef;
	_tmp86_ = ((ComponentDef*) _tmp85_)->description;
	gtk_entry_set_text (_tmp84_, _tmp86_);
	_tmp87_ = self->priv->descriptionHBox;
	_tmp88_ = self->priv->descriptionEntry;
	gtk_box_pack_start (_tmp87_, (GtkWidget*) _tmp88_, TRUE, TRUE, (guint) 1);
	_tmp89_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
	g_object_ref_sink (_tmp89_);
	_g_object_unref0 (self->priv->labelHBox);
	self->priv->labelHBox = _tmp89_;
	_tmp90_ = self->priv->controlsVBox;
	_tmp91_ = self->priv->labelHBox;
	gtk_box_pack_start (_tmp90_, (GtkWidget*) _tmp91_, FALSE, TRUE, (guint) 1);
	_tmp92_ = (GtkLabel*) gtk_label_new ("Box Label:");
	g_object_ref_sink (_tmp92_);
	_g_object_unref0 (self->priv->labelLabel);
	self->priv->labelLabel = _tmp92_;
	_tmp93_ = self->priv->labelHBox;
	_tmp94_ = self->priv->labelLabel;
	gtk_box_pack_start (_tmp93_, (GtkWidget*) _tmp94_, FALSE, TRUE, (guint) 1);
	_tmp95_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp95_);
	_g_object_unref0 (self->priv->labelEntry);
	self->priv->labelEntry = _tmp95_;
	_tmp96_ = self->priv->labelEntry;
	_tmp97_ = self->priv->customComponentDef;
	_tmp98_ = ((ComponentDef*) _tmp97_)->label;
	gtk_entry_set_text (_tmp96_, _tmp98_);
	_tmp99_ = self->priv->labelEntry;
	g_signal_connect ((GtkEditable*) _tmp99_, "changed", (GCallback) ___lambda61__gtk_editable_changed, self);
	_tmp100_ = self->priv->labelHBox;
	_tmp101_ = self->priv->labelEntry;
	gtk_box_pack_start (_tmp100_, (GtkWidget*) _tmp101_, TRUE, TRUE, (guint) 1);
	_tmp102_ = self->priv->customComponentDef;
	_tmp103_ = ((ComponentDef*) _tmp102_)->pinDefs;
	_tmp103__length1 = ((ComponentDef*) _tmp102_)->pinDefs_length1;
	if (_tmp103__length1 > 0) {
		CustomComponentDef* _tmp104_;
		PinDef** _tmp105_;
		gint _tmp105__length1;
		gint _tmp106_;
		PinDef* _tmp107_;
		PinDef* _tmp108_;
		CustomComponentDef* _tmp109_;
		gint _tmp110_;
		Tag* _tmp111_ = NULL;
		GtkBox* _tmp112_;
		GtkBox* _tmp113_;
		GtkBox* _tmp114_;
		GtkLabel* _tmp115_;
		GtkBox* _tmp116_;
		GtkLabel* _tmp117_;
		CustomComponentDef* _tmp118_;
		PinDef** _tmp119_;
		gint _tmp119__length1;
		GtkSpinButton* _tmp120_;
		GtkSpinButton* _tmp121_;
		GtkSpinButton* _tmp122_;
		GtkBox* _tmp123_;
		GtkSpinButton* _tmp124_;
		Tag* _tmp125_;
		GtkBox* _tmp132_;
		GtkLabel* _tmp133_;
		GtkCheckButton* _tmp134_;
		GtkCheckButton* _tmp135_;
		PinDef* _tmp136_;
		gboolean _tmp137_;
		GtkCheckButton* _tmp138_;
		GtkBox* _tmp139_;
		GtkCheckButton* _tmp140_;
		GtkBox* _tmp141_;
		GtkBox* _tmp142_;
		GtkBox* _tmp143_;
		GtkLabel* _tmp144_;
		GtkBox* _tmp145_;
		GtkLabel* _tmp146_;
		GtkRadioButton* _tmp147_;
		GtkRadioButton* _tmp148_;
		GtkBox* _tmp149_;
		GtkRadioButton* _tmp150_;
		GtkRadioButton* _tmp151_;
		GtkRadioButton* _tmp152_;
		GtkRadioButton* _tmp153_;
		GtkBox* _tmp154_;
		GtkRadioButton* _tmp155_;
		GtkRadioButton* _tmp156_;
		GtkRadioButton* _tmp157_;
		GtkRadioButton* _tmp158_;
		GtkBox* _tmp159_;
		GtkRadioButton* _tmp160_;
		GtkRadioButton* _tmp161_;
		GtkRadioButton* _tmp162_;
		GtkRadioButton* _tmp163_;
		GtkBox* _tmp164_;
		GtkRadioButton* _tmp165_;
		GtkBox* _tmp166_;
		GtkBox* _tmp167_;
		GtkBox* _tmp168_;
		GtkLabel* _tmp169_;
		GtkBox* _tmp170_;
		GtkLabel* _tmp171_;
		GtkEntry* _tmp172_;
		GtkEntry* _tmp173_;
		PinDef* _tmp174_;
		const gchar* _tmp175_;
		GtkEntry* _tmp176_;
		GtkBox* _tmp177_;
		GtkEntry* _tmp178_;
		self->priv->selectedPinID = 0;
		_tmp104_ = self->priv->customComponentDef;
		_tmp105_ = ((ComponentDef*) _tmp104_)->pinDefs;
		_tmp105__length1 = ((ComponentDef*) _tmp104_)->pinDefs_length1;
		_tmp106_ = self->priv->selectedPinID;
		_tmp107_ = _tmp105_[_tmp106_];
		_tmp108_ = _pin_def_ref0 (_tmp107_);
		_pin_def_unref0 (self->priv->selectedPin);
		self->priv->selectedPin = _tmp108_;
		_tmp109_ = self->priv->customComponentDef;
		_tmp110_ = self->priv->selectedPinID;
		_tmp111_ = custom_component_def_resolve_tag_id (_tmp109_, _tmp110_);
		_tag_unref0 (self->priv->tag);
		self->priv->tag = _tmp111_;
		_tmp112_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
		g_object_ref_sink (_tmp112_);
		_g_object_unref0 (self->priv->pinHBox);
		self->priv->pinHBox = _tmp112_;
		_tmp113_ = self->priv->controlsVBox;
		_tmp114_ = self->priv->pinHBox;
		gtk_box_pack_start (_tmp113_, (GtkWidget*) _tmp114_, FALSE, TRUE, (guint) 1);
		_tmp115_ = (GtkLabel*) gtk_label_new ("Pin Select:");
		g_object_ref_sink (_tmp115_);
		_g_object_unref0 (self->priv->pinLabel);
		self->priv->pinLabel = _tmp115_;
		_tmp116_ = self->priv->pinHBox;
		_tmp117_ = self->priv->pinLabel;
		gtk_box_pack_start (_tmp116_, (GtkWidget*) _tmp117_, FALSE, TRUE, (guint) 1);
		_tmp118_ = self->priv->customComponentDef;
		_tmp119_ = ((ComponentDef*) _tmp118_)->pinDefs;
		_tmp119__length1 = ((ComponentDef*) _tmp118_)->pinDefs_length1;
		_tmp120_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) (_tmp119__length1 - 1), (gdouble) 1);
		g_object_ref_sink (_tmp120_);
		_g_object_unref0 (self->priv->pinSpinButton);
		self->priv->pinSpinButton = _tmp120_;
		_tmp121_ = self->priv->pinSpinButton;
		gtk_spin_button_set_value (_tmp121_, (gdouble) 0);
		_tmp122_ = self->priv->pinSpinButton;
		g_signal_connect ((GtkEditable*) _tmp122_, "changed", (GCallback) _customiser_update_selection_gtk_editable_changed, self);
		_tmp123_ = self->priv->pinHBox;
		_tmp124_ = self->priv->pinSpinButton;
		gtk_box_pack_start (_tmp123_, (GtkWidget*) _tmp124_, TRUE, TRUE, (guint) 1);
		_tmp125_ = self->priv->tag;
		if (_tmp125_ != NULL) {
			Tag* _tmp126_;
			const gchar* _tmp127_;
			gchar* _tmp128_;
			gchar* _tmp129_;
			GtkLabel* _tmp130_;
			_tmp126_ = self->priv->tag;
			_tmp127_ = _tmp126_->text;
			_tmp128_ = g_strconcat ("Maps to: ", _tmp127_, NULL);
			_tmp129_ = _tmp128_;
			_tmp130_ = (GtkLabel*) gtk_label_new (_tmp129_);
			g_object_ref_sink (_tmp130_);
			_g_object_unref0 (self->priv->tagNameLabel);
			self->priv->tagNameLabel = _tmp130_;
			_g_free0 (_tmp129_);
		} else {
			GtkLabel* _tmp131_;
			_tmp131_ = (GtkLabel*) gtk_label_new ("There is no matching tag!");
			g_object_ref_sink (_tmp131_);
			_g_object_unref0 (self->priv->tagNameLabel);
			self->priv->tagNameLabel = _tmp131_;
		}
		_tmp132_ = self->priv->controlsVBox;
		_tmp133_ = self->priv->tagNameLabel;
		gtk_box_pack_start (_tmp132_, (GtkWidget*) _tmp133_, FALSE, TRUE, (guint) 1);
		_tmp134_ = (GtkCheckButton*) gtk_check_button_new_with_label ("Connection Required");
		g_object_ref_sink (_tmp134_);
		_g_object_unref0 (self->priv->requiredCheck);
		self->priv->requiredCheck = _tmp134_;
		_tmp135_ = self->priv->requiredCheck;
		_tmp136_ = self->priv->selectedPin;
		_tmp137_ = _tmp136_->required;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp135_, _tmp137_);
		_tmp138_ = self->priv->requiredCheck;
		g_signal_connect ((GtkToggleButton*) _tmp138_, "toggled", (GCallback) ____lambda62__gtk_toggle_button_toggled, self);
		_tmp139_ = self->priv->controlsVBox;
		_tmp140_ = self->priv->requiredCheck;
		gtk_box_pack_start (_tmp139_, (GtkWidget*) _tmp140_, FALSE, TRUE, (guint) 1);
		_tmp141_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
		g_object_ref_sink (_tmp141_);
		_g_object_unref0 (self->priv->labelTypeVBox);
		self->priv->labelTypeVBox = _tmp141_;
		_tmp142_ = self->priv->controlsVBox;
		_tmp143_ = self->priv->labelTypeVBox;
		gtk_box_pack_start (_tmp142_, (GtkWidget*) _tmp143_, FALSE, TRUE, (guint) 1);
		_tmp144_ = (GtkLabel*) gtk_label_new ("Pin labels can be text or a symbol:");
		g_object_ref_sink (_tmp144_);
		_g_object_unref0 (self->priv->labelTypeLabel);
		self->priv->labelTypeLabel = _tmp144_;
		_tmp145_ = self->priv->labelTypeVBox;
		_tmp146_ = self->priv->labelTypeLabel;
		gtk_box_pack_start (_tmp145_, (GtkWidget*) _tmp146_, FALSE, TRUE, (guint) 1);
		_tmp147_ = (GtkRadioButton*) gtk_radio_button_new_with_label (NULL, "No Label");
		g_object_ref_sink (_tmp147_);
		_g_object_unref0 (self->priv->labelTypeNoneRadio);
		self->priv->labelTypeNoneRadio = _tmp147_;
		_tmp148_ = self->priv->labelTypeNoneRadio;
		g_signal_connect ((GtkToggleButton*) _tmp148_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp149_ = self->priv->labelTypeVBox;
		_tmp150_ = self->priv->labelTypeNoneRadio;
		gtk_box_pack_start (_tmp149_, (GtkWidget*) _tmp150_, FALSE, TRUE, (guint) 1);
		_tmp151_ = self->priv->labelTypeNoneRadio;
		_tmp152_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp151_, "Text");
		g_object_ref_sink (_tmp152_);
		_g_object_unref0 (self->priv->labelTypeTextRadio);
		self->priv->labelTypeTextRadio = _tmp152_;
		_tmp153_ = self->priv->labelTypeTextRadio;
		g_signal_connect ((GtkToggleButton*) _tmp153_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp154_ = self->priv->labelTypeVBox;
		_tmp155_ = self->priv->labelTypeTextRadio;
		gtk_box_pack_start (_tmp154_, (GtkWidget*) _tmp155_, FALSE, TRUE, (guint) 1);
		_tmp156_ = self->priv->labelTypeNoneRadio;
		_tmp157_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp156_, "Text With Bar");
		g_object_ref_sink (_tmp157_);
		_g_object_unref0 (self->priv->labelTypeTextBarRadio);
		self->priv->labelTypeTextBarRadio = _tmp157_;
		_tmp158_ = self->priv->labelTypeTextBarRadio;
		g_signal_connect ((GtkToggleButton*) _tmp158_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp159_ = self->priv->labelTypeVBox;
		_tmp160_ = self->priv->labelTypeTextBarRadio;
		gtk_box_pack_start (_tmp159_, (GtkWidget*) _tmp160_, FALSE, TRUE, (guint) 1);
		_tmp161_ = self->priv->labelTypeNoneRadio;
		_tmp162_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp161_, "Clock");
		g_object_ref_sink (_tmp162_);
		_g_object_unref0 (self->priv->labelTypeClockRadio);
		self->priv->labelTypeClockRadio = _tmp162_;
		_tmp163_ = self->priv->labelTypeClockRadio;
		g_signal_connect ((GtkToggleButton*) _tmp163_, "toggled", (GCallback) _customiser_update_label_type_gtk_toggle_button_toggled, self);
		_tmp164_ = self->priv->labelTypeVBox;
		_tmp165_ = self->priv->labelTypeClockRadio;
		gtk_box_pack_start (_tmp164_, (GtkWidget*) _tmp165_, FALSE, TRUE, (guint) 1);
		_tmp166_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2);
		g_object_ref_sink (_tmp166_);
		_g_object_unref0 (self->priv->pinLabelHBox);
		self->priv->pinLabelHBox = _tmp166_;
		_tmp167_ = self->priv->controlsVBox;
		_tmp168_ = self->priv->pinLabelHBox;
		gtk_box_pack_start (_tmp167_, (GtkWidget*) _tmp168_, FALSE, TRUE, (guint) 1);
		_tmp169_ = (GtkLabel*) gtk_label_new ("Pin Label:");
		g_object_ref_sink (_tmp169_);
		_g_object_unref0 (self->priv->pinLabelLabel);
		self->priv->pinLabelLabel = _tmp169_;
		_tmp170_ = self->priv->pinLabelHBox;
		_tmp171_ = self->priv->pinLabelLabel;
		gtk_box_pack_start (_tmp170_, (GtkWidget*) _tmp171_, FALSE, TRUE, (guint) 1);
		_tmp172_ = (GtkEntry*) gtk_entry_new ();
		g_object_ref_sink (_tmp172_);
		_g_object_unref0 (self->priv->pinLabelEntry);
		self->priv->pinLabelEntry = _tmp172_;
		_tmp173_ = self->priv->pinLabelEntry;
		_tmp174_ = self->priv->selectedPin;
		_tmp175_ = _tmp174_->label;
		gtk_entry_set_text (_tmp173_, _tmp175_);
		_tmp176_ = self->priv->pinLabelEntry;
		g_signal_connect ((GtkEditable*) _tmp176_, "changed", (GCallback) ____lambda63__gtk_editable_changed, self);
		_tmp177_ = self->priv->pinLabelHBox;
		_tmp178_ = self->priv->pinLabelEntry;
		gtk_box_pack_start (_tmp177_, (GtkWidget*) _tmp178_, TRUE, TRUE, (guint) 1);
	}
	_tmp179_ = (GtkLabel*) gtk_label_new ("Bounds define the visual size:");
	g_object_ref_sink (_tmp179_);
	_g_object_unref0 (self->priv->boundsLabel);
	self->priv->boundsLabel = _tmp179_;
	_tmp180_ = self->priv->controlsVBox;
	_tmp181_ = self->priv->boundsLabel;
	gtk_box_pack_start (_tmp180_, (GtkWidget*) _tmp181_, FALSE, TRUE, (guint) 1);
	_tmp182_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp182_);
	_g_object_unref0 (self->priv->boundsGrid);
	self->priv->boundsGrid = _tmp182_;
	_tmp183_ = self->priv->controlsVBox;
	_tmp184_ = self->priv->boundsGrid;
	gtk_box_pack_start (_tmp183_, (GtkWidget*) _tmp184_, FALSE, TRUE, (guint) 1);
	_tmp185_ = (GtkLabel*) gtk_label_new ("Right:");
	g_object_ref_sink (_tmp185_);
	_g_object_unref0 (self->priv->rightBoundLabel);
	self->priv->rightBoundLabel = _tmp185_;
	_tmp186_ = self->priv->boundsGrid;
	_tmp187_ = self->priv->rightBoundLabel;
	gtk_grid_attach (_tmp186_, (GtkWidget*) _tmp187_, 0, 0, 1, 1);
	_tmp188_ = G_MAXINT;
	_tmp189_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) _tmp188_, (gdouble) 5);
	g_object_ref_sink (_tmp189_);
	_g_object_unref0 (self->priv->rightBoundSpinButton);
	self->priv->rightBoundSpinButton = _tmp189_;
	_tmp190_ = self->priv->rightBoundSpinButton;
	_tmp191_ = self->priv->customComponentDef;
	_tmp192_ = ((ComponentDef*) _tmp191_)->rightBound;
	gtk_spin_button_set_value (_tmp190_, (gdouble) _tmp192_);
	_tmp193_ = self->priv->rightBoundSpinButton;
	g_signal_connect (_tmp193_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp194_ = self->priv->boundsGrid;
	_tmp195_ = self->priv->rightBoundSpinButton;
	gtk_grid_attach (_tmp194_, (GtkWidget*) _tmp195_, 1, 0, 1, 1);
	_tmp196_ = (GtkLabel*) gtk_label_new ("Down:");
	g_object_ref_sink (_tmp196_);
	_g_object_unref0 (self->priv->downBoundLabel);
	self->priv->downBoundLabel = _tmp196_;
	_tmp197_ = self->priv->boundsGrid;
	_tmp198_ = self->priv->downBoundLabel;
	gtk_grid_attach (_tmp197_, (GtkWidget*) _tmp198_, 0, 1, 1, 1);
	_tmp199_ = G_MAXINT;
	_tmp200_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) _tmp199_, (gdouble) 5);
	g_object_ref_sink (_tmp200_);
	_g_object_unref0 (self->priv->downBoundSpinButton);
	self->priv->downBoundSpinButton = _tmp200_;
	_tmp201_ = self->priv->downBoundSpinButton;
	_tmp202_ = self->priv->customComponentDef;
	_tmp203_ = ((ComponentDef*) _tmp202_)->downBound;
	gtk_spin_button_set_value (_tmp201_, (gdouble) _tmp203_);
	_tmp204_ = self->priv->downBoundSpinButton;
	g_signal_connect (_tmp204_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp205_ = self->priv->boundsGrid;
	_tmp206_ = self->priv->downBoundSpinButton;
	gtk_grid_attach (_tmp205_, (GtkWidget*) _tmp206_, 1, 1, 1, 1);
	_tmp207_ = (GtkLabel*) gtk_label_new ("Left:");
	g_object_ref_sink (_tmp207_);
	_g_object_unref0 (self->priv->leftBoundLabel);
	self->priv->leftBoundLabel = _tmp207_;
	_tmp208_ = self->priv->boundsGrid;
	_tmp209_ = self->priv->leftBoundLabel;
	gtk_grid_attach (_tmp208_, (GtkWidget*) _tmp209_, 0, 2, 1, 1);
	_tmp210_ = G_MININT;
	_tmp211_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) _tmp210_, (gdouble) 0, (gdouble) 5);
	g_object_ref_sink (_tmp211_);
	_g_object_unref0 (self->priv->leftBoundSpinButton);
	self->priv->leftBoundSpinButton = _tmp211_;
	_tmp212_ = self->priv->leftBoundSpinButton;
	_tmp213_ = self->priv->customComponentDef;
	_tmp214_ = ((ComponentDef*) _tmp213_)->leftBound;
	gtk_spin_button_set_value (_tmp212_, (gdouble) _tmp214_);
	_tmp215_ = self->priv->leftBoundSpinButton;
	g_signal_connect (_tmp215_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp216_ = self->priv->boundsGrid;
	_tmp217_ = self->priv->leftBoundSpinButton;
	gtk_grid_attach (_tmp216_, (GtkWidget*) _tmp217_, 1, 2, 1, 1);
	_tmp218_ = (GtkLabel*) gtk_label_new ("Up:");
	g_object_ref_sink (_tmp218_);
	_g_object_unref0 (self->priv->upBoundLabel);
	self->priv->upBoundLabel = _tmp218_;
	_tmp219_ = self->priv->boundsGrid;
	_tmp220_ = self->priv->upBoundLabel;
	gtk_grid_attach (_tmp219_, (GtkWidget*) _tmp220_, 0, 3, 1, 1);
	_tmp221_ = G_MININT;
	_tmp222_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) _tmp221_, (gdouble) 0, (gdouble) 5);
	g_object_ref_sink (_tmp222_);
	_g_object_unref0 (self->priv->upBoundSpinButton);
	self->priv->upBoundSpinButton = _tmp222_;
	_tmp223_ = self->priv->upBoundSpinButton;
	_tmp224_ = self->priv->customComponentDef;
	_tmp225_ = ((ComponentDef*) _tmp224_)->upBound;
	gtk_spin_button_set_value (_tmp223_, (gdouble) _tmp225_);
	_tmp226_ = self->priv->upBoundSpinButton;
	g_signal_connect (_tmp226_, "value-changed", (GCallback) _customiser_update_bounds_gtk_spin_button_value_changed, self);
	_tmp227_ = self->priv->boundsGrid;
	_tmp228_ = self->priv->upBoundSpinButton;
	gtk_grid_attach (_tmp227_, (GtkWidget*) _tmp228_, 1, 3, 1, 1);
	_tmp229_ = (GtkButton*) gtk_button_new_with_label ("Background Colour");
	g_object_ref_sink (_tmp229_);
	_g_object_unref0 (self->priv->colourButton);
	self->priv->colourButton = _tmp229_;
	_tmp230_ = self->priv->colourButton;
	g_signal_connect (_tmp230_, "clicked", (GCallback) ___lambda64__gtk_button_clicked, self);
	_tmp231_ = self->priv->controlsVBox;
	_tmp232_ = self->priv->colourButton;
	gtk_box_pack_start (_tmp231_, (GtkWidget*) _tmp232_, FALSE, TRUE, (guint) 1);
	_tmp233_ = self->priv->dialog;
	g_signal_connect (_tmp233_, "response", (GCallback) _customiser_response_handler_gtk_dialog_response, self);
	_tmp234_ = (GtkButton*) gtk_button_new_with_label ("Close");
	g_object_ref_sink (_tmp234_);
	_g_object_unref0 (self->priv->closeButton);
	self->priv->closeButton = _tmp234_;
	_tmp235_ = self->priv->dialog;
	_tmp236_ = self->priv->closeButton;
	gtk_dialog_add_action_widget (_tmp235_, (GtkWidget*) _tmp236_, (gint) GTK_RESPONSE_CLOSE);
	_tmp237_ = self->priv->dialog;
	gtk_widget_show_all ((GtkWidget*) _tmp237_);
	_g_object_unref0 (content);
}


/**
 * Signal handler for the Gtk.EventBox. Handles a mouse button down
 * event on the display area.
 */
static gboolean customiser_mouse_down (Customiser* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GdkEventButton _tmp0_;
	gdouble _tmp1_;
	GdkEventButton _tmp2_;
	gdouble _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.x;
	self->priv->xMouseStart = (gint) _tmp1_;
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.y;
	self->priv->yMouseStart = (gint) _tmp3_;
	result = FALSE;
	return result;
}


/**
 * Signal handler for the Gtk.EventBox. Handles a mouse button up
 * event on the display area. This is when an action is taken.
 * 
 * Only changes the pins' positions.
 */
static gboolean customiser_mouse_up (Customiser* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GtkAllocation areaAllocation = {0};
	GtkEventBox* _tmp0_;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_;
	gint _tmp3_;
	gint width;
	GtkAllocation _tmp4_;
	gint _tmp5_;
	gint height;
	gint _tmp6_;
	gint xCentre;
	gint _tmp7_;
	gint yCentre;
	gint _tmp8_;
	gint _tmp9_;
	gint xStart;
	gint _tmp10_;
	gint _tmp11_;
	gint yStart;
	GdkEventButton _tmp12_;
	gdouble _tmp13_;
	gint _tmp14_;
	gint xEnd;
	GdkEventButton _tmp15_;
	gdouble _tmp16_;
	gint _tmp17_;
	gint yEnd;
	gint _tmp18_;
	gint _tmp19_;
	gint yDiff;
	gint _tmp20_;
	gint halfGridSize;
	gint _tmp21_;
	gfloat _tmp22_;
	gint _tmp23_;
	gint xBoardStart;
	gint _tmp24_;
	gfloat _tmp25_;
	gint _tmp26_;
	gint yBoardStart;
	gint _tmp27_;
	gfloat _tmp28_;
	gint _tmp29_;
	gint xBoardEnd;
	gint _tmp30_;
	gfloat _tmp31_;
	gint _tmp32_;
	gint yBoardEnd;
	CustomiserMouseMode _tmp33_;
	FILE* _tmp70_;
	gint _tmp71_;
	gint _tmp72_;
	gint _tmp73_;
	gint _tmp74_;
	gint _tmp75_;
	gint _tmp76_;
	gint xBoardDiff;
	gint _tmp77_;
	gint _tmp78_;
	gint yBoardDiff;
	gint _tmp79_ = 0;
	gint _tmp80_;
	gint _tmp83_;
	gint yDiffAbs;
	CustomComponentDef* _tmp84_;
	gint _tmp85_;
	gint rightBound;
	CustomComponentDef* _tmp86_;
	gint _tmp87_;
	gint downBound;
	CustomComponentDef* _tmp88_;
	gint _tmp89_;
	gint leftBound;
	CustomComponentDef* _tmp90_;
	gint _tmp91_;
	gint upBound;
	CustomiserMouseMode _tmp92_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->controller;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	areaAllocation = _tmp1_;
	_tmp2_ = areaAllocation;
	_tmp3_ = _tmp2_.width;
	width = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.height;
	height = _tmp5_;
	_tmp6_ = width;
	xCentre = _tmp6_ / 2;
	_tmp7_ = height;
	yCentre = _tmp7_ / 2;
	_tmp8_ = self->priv->xMouseStart;
	_tmp9_ = xCentre;
	xStart = _tmp8_ - _tmp9_;
	_tmp10_ = self->priv->yMouseStart;
	_tmp11_ = yCentre;
	yStart = _tmp10_ - _tmp11_;
	_tmp12_ = *event;
	_tmp13_ = _tmp12_.x;
	_tmp14_ = xCentre;
	xEnd = ((gint) _tmp13_) - _tmp14_;
	_tmp15_ = *event;
	_tmp16_ = _tmp15_.y;
	_tmp17_ = yCentre;
	yEnd = ((gint) _tmp16_) - _tmp17_;
	_tmp18_ = yEnd;
	_tmp19_ = yStart;
	yDiff = _tmp18_ - _tmp19_;
	_tmp20_ = self->gridSize;
	halfGridSize = _tmp20_ / 2;
	_tmp21_ = xStart;
	_tmp22_ = self->zoom;
	_tmp23_ = self->priv->xView;
	xBoardStart = (gint) ((((gfloat) _tmp21_) / _tmp22_) + ((gfloat) _tmp23_));
	_tmp24_ = yStart;
	_tmp25_ = self->zoom;
	_tmp26_ = self->priv->yView;
	yBoardStart = (gint) ((((gfloat) _tmp24_) / _tmp25_) + ((gfloat) _tmp26_));
	_tmp27_ = xEnd;
	_tmp28_ = self->zoom;
	_tmp29_ = self->priv->xView;
	xBoardEnd = (gint) ((((gfloat) _tmp27_) / _tmp28_) + ((gfloat) _tmp29_));
	_tmp30_ = yEnd;
	_tmp31_ = self->zoom;
	_tmp32_ = self->priv->yView;
	yBoardEnd = (gint) ((((gfloat) _tmp30_) / _tmp31_) + ((gfloat) _tmp32_));
	_tmp33_ = self->priv->mouseMode;
	switch (_tmp33_) {
		case CUSTOMISER_MOUSE_MODE_SCROLL:
		case CUSTOMISER_MOUSE_MODE_ZOOM:
		{
			break;
		}
		case CUSTOMISER_MOUSE_MODE_PIN:
		{
			gint _tmp34_ = 0;
			gint _tmp35_;
			gint _tmp38_;
			gint _tmp39_;
			gint _tmp40_ = 0;
			gint _tmp41_;
			gint _tmp44_;
			gint _tmp45_;
			gint _tmp46_;
			gint _tmp47_;
			gint _tmp48_;
			gint _tmp49_;
			gint _tmp50_;
			gint _tmp51_;
			gint _tmp52_ = 0;
			gint _tmp53_;
			gint _tmp56_;
			gint _tmp57_;
			gint _tmp58_ = 0;
			gint _tmp59_;
			gint _tmp62_;
			gint _tmp63_;
			gint _tmp64_;
			gint _tmp65_;
			gint _tmp66_;
			gint _tmp67_;
			gint _tmp68_;
			gint _tmp69_;
			_tmp35_ = xBoardStart;
			if (_tmp35_ > 0) {
				gint _tmp36_;
				_tmp36_ = halfGridSize;
				_tmp34_ = _tmp36_;
			} else {
				gint _tmp37_;
				_tmp37_ = halfGridSize;
				_tmp34_ = -_tmp37_;
			}
			_tmp38_ = xBoardStart;
			_tmp39_ = _tmp34_;
			xBoardStart = _tmp38_ + _tmp39_;
			_tmp41_ = yBoardStart;
			if (_tmp41_ > 0) {
				gint _tmp42_;
				_tmp42_ = halfGridSize;
				_tmp40_ = _tmp42_;
			} else {
				gint _tmp43_;
				_tmp43_ = halfGridSize;
				_tmp40_ = -_tmp43_;
			}
			_tmp44_ = yBoardStart;
			_tmp45_ = _tmp40_;
			yBoardStart = _tmp44_ + _tmp45_;
			_tmp46_ = xBoardStart;
			_tmp47_ = self->gridSize;
			_tmp48_ = self->gridSize;
			xBoardStart = (_tmp46_ / _tmp47_) * _tmp48_;
			_tmp49_ = yBoardStart;
			_tmp50_ = self->gridSize;
			_tmp51_ = self->gridSize;
			yBoardStart = (_tmp49_ / _tmp50_) * _tmp51_;
			_tmp53_ = xBoardEnd;
			if (_tmp53_ > 0) {
				gint _tmp54_;
				_tmp54_ = halfGridSize;
				_tmp52_ = _tmp54_;
			} else {
				gint _tmp55_;
				_tmp55_ = halfGridSize;
				_tmp52_ = -_tmp55_;
			}
			_tmp56_ = xBoardEnd;
			_tmp57_ = _tmp52_;
			xBoardEnd = _tmp56_ + _tmp57_;
			_tmp59_ = yBoardEnd;
			if (_tmp59_ > 0) {
				gint _tmp60_;
				_tmp60_ = halfGridSize;
				_tmp58_ = _tmp60_;
			} else {
				gint _tmp61_;
				_tmp61_ = halfGridSize;
				_tmp58_ = -_tmp61_;
			}
			_tmp62_ = yBoardEnd;
			_tmp63_ = _tmp58_;
			yBoardEnd = _tmp62_ + _tmp63_;
			_tmp64_ = xBoardEnd;
			_tmp65_ = self->gridSize;
			_tmp66_ = self->gridSize;
			xBoardEnd = (_tmp64_ / _tmp65_) * _tmp66_;
			_tmp67_ = yBoardEnd;
			_tmp68_ = self->gridSize;
			_tmp69_ = self->gridSize;
			yBoardEnd = (_tmp67_ / _tmp68_) * _tmp69_;
			break;
		}
		default:
		break;
	}
	_tmp70_ = stdout;
	_tmp71_ = xBoardStart;
	_tmp72_ = yBoardStart;
	_tmp73_ = xBoardEnd;
	_tmp74_ = yBoardEnd;
	fprintf (_tmp70_, "Customiser Interact @ %i, %i - %i, %i\n", _tmp71_, _tmp72_, _tmp73_, _tmp74_);
	_tmp75_ = xBoardEnd;
	_tmp76_ = xBoardStart;
	xBoardDiff = _tmp75_ - _tmp76_;
	_tmp77_ = yBoardEnd;
	_tmp78_ = yBoardStart;
	yBoardDiff = _tmp77_ - _tmp78_;
	_tmp80_ = yDiff;
	if (_tmp80_ > 0) {
		gint _tmp81_;
		_tmp81_ = yDiff;
		_tmp79_ = _tmp81_;
	} else {
		gint _tmp82_;
		_tmp82_ = yDiff;
		_tmp79_ = -_tmp82_;
	}
	_tmp83_ = _tmp79_;
	yDiffAbs = _tmp83_;
	_tmp84_ = self->priv->customComponentDef;
	_tmp85_ = ((ComponentDef*) _tmp84_)->rightBound;
	rightBound = _tmp85_;
	_tmp86_ = self->priv->customComponentDef;
	_tmp87_ = ((ComponentDef*) _tmp86_)->downBound;
	downBound = _tmp87_;
	_tmp88_ = self->priv->customComponentDef;
	_tmp89_ = ((ComponentDef*) _tmp88_)->leftBound;
	leftBound = _tmp89_;
	_tmp90_ = self->priv->customComponentDef;
	_tmp91_ = ((ComponentDef*) _tmp90_)->upBound;
	upBound = _tmp91_;
	_tmp92_ = self->priv->mouseMode;
	switch (_tmp92_) {
		case CUSTOMISER_MOUSE_MODE_SCROLL:
		{
			gint _tmp93_;
			gint _tmp94_;
			gint _tmp95_;
			gint _tmp96_;
			_tmp93_ = self->priv->xView;
			_tmp94_ = xBoardDiff;
			self->priv->xView = _tmp93_ - _tmp94_;
			_tmp95_ = self->priv->yView;
			_tmp96_ = yBoardDiff;
			self->priv->yView = _tmp95_ - _tmp96_;
			_cairo_surface_destroy0 (self->priv->gridCache);
			self->priv->gridCache = NULL;
			break;
		}
		case CUSTOMISER_MOUSE_MODE_ZOOM:
		{
			gint _tmp97_;
			_tmp97_ = yDiff;
			if (_tmp97_ > 0) {
				gfloat _tmp98_;
				gint _tmp99_;
				gint _tmp100_;
				_tmp98_ = self->zoom;
				_tmp99_ = yDiffAbs;
				_tmp100_ = height;
				self->zoom = _tmp98_ * (1.0f + (((gfloat) _tmp99_) / ((gfloat) _tmp100_)));
			} else {
				gfloat _tmp101_;
				gint _tmp102_;
				gint _tmp103_;
				_tmp101_ = self->zoom;
				_tmp102_ = yDiffAbs;
				_tmp103_ = height;
				self->zoom = _tmp101_ / (1.0f + (((gfloat) _tmp102_) / ((gfloat) _tmp103_)));
			}
			_cairo_surface_destroy0 (self->priv->gridCache);
			self->priv->gridCache = NULL;
			break;
		}
		case CUSTOMISER_MOUSE_MODE_PIN:
		{
			gboolean _tmp104_ = FALSE;
			gint _tmp105_;
			gint _tmp106_;
			gboolean _tmp109_;
			gboolean _tmp124_ = FALSE;
			gint _tmp125_;
			gint _tmp126_;
			gboolean _tmp129_;
			_tmp105_ = upBound;
			_tmp106_ = yBoardEnd;
			if (_tmp105_ <= _tmp106_) {
				gint _tmp107_;
				gint _tmp108_;
				_tmp107_ = yBoardEnd;
				_tmp108_ = downBound;
				_tmp104_ = _tmp107_ <= _tmp108_;
			} else {
				_tmp104_ = FALSE;
			}
			_tmp109_ = _tmp104_;
			if (_tmp109_) {
				gint _tmp110_;
				gint _tmp111_;
				gint _tmp117_;
				gint _tmp118_;
				_tmp110_ = xBoardEnd;
				_tmp111_ = leftBound;
				if (_tmp110_ < _tmp111_) {
					PinDef* _tmp112_;
					gint _tmp113_;
					gint _tmp114_;
					gint _tmp115_;
					gint _tmp116_;
					_tmp112_ = self->priv->selectedPin;
					_tmp113_ = leftBound;
					_tmp114_ = yBoardEnd;
					_tmp115_ = leftBound;
					_tmp116_ = xBoardEnd;
					pin_def_set_position (_tmp112_, _tmp113_, _tmp114_, _tmp115_ - _tmp116_, DIRECTION_LEFT);
				}
				_tmp117_ = xBoardEnd;
				_tmp118_ = rightBound;
				if (_tmp117_ > _tmp118_) {
					PinDef* _tmp119_;
					gint _tmp120_;
					gint _tmp121_;
					gint _tmp122_;
					gint _tmp123_;
					_tmp119_ = self->priv->selectedPin;
					_tmp120_ = rightBound;
					_tmp121_ = yBoardEnd;
					_tmp122_ = xBoardEnd;
					_tmp123_ = rightBound;
					pin_def_set_position (_tmp119_, _tmp120_, _tmp121_, _tmp122_ - _tmp123_, DIRECTION_RIGHT);
				}
			}
			_tmp125_ = leftBound;
			_tmp126_ = xBoardEnd;
			if (_tmp125_ <= _tmp126_) {
				gint _tmp127_;
				gint _tmp128_;
				_tmp127_ = xBoardEnd;
				_tmp128_ = rightBound;
				_tmp124_ = _tmp127_ <= _tmp128_;
			} else {
				_tmp124_ = FALSE;
			}
			_tmp129_ = _tmp124_;
			if (_tmp129_) {
				gint _tmp130_;
				gint _tmp131_;
				gint _tmp137_;
				gint _tmp138_;
				_tmp130_ = yBoardEnd;
				_tmp131_ = upBound;
				if (_tmp130_ < _tmp131_) {
					PinDef* _tmp132_;
					gint _tmp133_;
					gint _tmp134_;
					gint _tmp135_;
					gint _tmp136_;
					_tmp132_ = self->priv->selectedPin;
					_tmp133_ = xBoardEnd;
					_tmp134_ = upBound;
					_tmp135_ = upBound;
					_tmp136_ = yBoardEnd;
					pin_def_set_position (_tmp132_, _tmp133_, _tmp134_, _tmp135_ - _tmp136_, DIRECTION_UP);
				}
				_tmp137_ = yBoardEnd;
				_tmp138_ = downBound;
				if (_tmp137_ > _tmp138_) {
					PinDef* _tmp139_;
					gint _tmp140_;
					gint _tmp141_;
					gint _tmp142_;
					gint _tmp143_;
					_tmp139_ = self->priv->selectedPin;
					_tmp140_ = xBoardEnd;
					_tmp141_ = downBound;
					_tmp142_ = yBoardEnd;
					_tmp143_ = downBound;
					pin_def_set_position (_tmp139_, _tmp140_, _tmp141_, _tmp142_ - _tmp143_, DIRECTION_DOWN);
				}
			}
			break;
		}
		default:
		break;
	}
	customiser_update_values (self);
	customiser_render_def (self, NULL);
	result = FALSE;
	return result;
}


/**
 * Called when the Customiser should become modal.
 */
void customiser_run (Customiser* self) {
	GtkDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->dialog;
	gtk_dialog_run (_tmp0_);
}


/**
 * Handles the response of the customiser dialog. (On close.)
 */
void customiser_response_handler (Customiser* self, gint response_id) {
	GtkDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	customiser_update_values (self);
	_tmp0_ = self->priv->dialog;
	gtk_widget_destroy ((GtkWidget*) _tmp0_);
}


void customiser_set_colour (Customiser* self) {
	GtkDialog* _tmp0_;
	GtkColorChooserDialog* _tmp1_;
	GtkColorChooserDialog* colorDialog;
	GdkRGBA color = {0};
	GtkColorChooserDialog* _tmp2_;
	CustomComponentDef* _tmp3_;
	gint _tmp4_;
	CustomComponentDef* _tmp5_;
	gint _tmp6_;
	CustomComponentDef* _tmp7_;
	gint _tmp8_;
	CustomComponentDef* _tmp9_;
	gint _tmp10_;
	GtkColorChooserDialog* _tmp13_;
	GdkRGBA _tmp14_;
	GtkColorChooserDialog* _tmp15_;
	gint _tmp16_ = 0;
	GtkColorChooserDialog* _tmp43_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->dialog;
	_tmp1_ = (GtkColorChooserDialog*) gtk_color_chooser_dialog_new ("Component Background", (GtkWindow*) _tmp0_);
	g_object_ref_sink (_tmp1_);
	colorDialog = _tmp1_;
	memset (&color, 0, sizeof (GdkRGBA));
	_tmp2_ = colorDialog;
	gtk_color_chooser_set_use_alpha ((GtkColorChooser*) _tmp2_, TRUE);
	_tmp3_ = self->priv->customComponentDef;
	_tmp4_ = ((ComponentDef*) _tmp3_)->backgroundRed;
	color.red = ((gdouble) _tmp4_) / 255.0;
	_tmp5_ = self->priv->customComponentDef;
	_tmp6_ = ((ComponentDef*) _tmp5_)->backgroundGreen;
	color.green = ((gdouble) _tmp6_) / 255.0;
	_tmp7_ = self->priv->customComponentDef;
	_tmp8_ = ((ComponentDef*) _tmp7_)->backgroundBlue;
	color.blue = ((gdouble) _tmp8_) / 255.0;
	_tmp9_ = self->priv->customComponentDef;
	_tmp10_ = ((ComponentDef*) _tmp9_)->backgroundAlpha;
	if (_tmp10_ == 0) {
		color.alpha = 1.0;
	} else {
		CustomComponentDef* _tmp11_;
		gint _tmp12_;
		_tmp11_ = self->priv->customComponentDef;
		_tmp12_ = ((ComponentDef*) _tmp11_)->backgroundAlpha;
		color.alpha = ((gdouble) _tmp12_) / 255.0;
	}
	_tmp13_ = colorDialog;
	_tmp14_ = color;
	gtk_color_chooser_set_rgba ((GtkColorChooser*) _tmp13_, &_tmp14_);
	_tmp15_ = colorDialog;
	_tmp16_ = gtk_dialog_run ((GtkDialog*) _tmp15_);
	if (_tmp16_ == ((gint) GTK_RESPONSE_OK)) {
		GtkColorChooserDialog* _tmp17_;
		GdkRGBA _tmp18_ = {0};
		CustomComponentDef* _tmp19_;
		GdkRGBA _tmp20_;
		gdouble _tmp21_;
		CustomComponentDef* _tmp22_;
		GdkRGBA _tmp23_;
		gdouble _tmp24_;
		CustomComponentDef* _tmp25_;
		GdkRGBA _tmp26_;
		gdouble _tmp27_;
		CustomComponentDef* _tmp28_;
		GdkRGBA _tmp29_;
		gdouble _tmp30_;
		CustomComponentDef* _tmp31_;
		CustomComponentDef* _tmp32_;
		gint _tmp33_;
		CustomComponentDef* _tmp34_;
		CustomComponentDef* _tmp35_;
		gint _tmp36_;
		CustomComponentDef* _tmp37_;
		CustomComponentDef* _tmp38_;
		gint _tmp39_;
		CustomComponentDef* _tmp40_;
		CustomComponentDef* _tmp41_;
		gint _tmp42_;
		_tmp17_ = colorDialog;
		gtk_color_chooser_get_rgba ((GtkColorChooser*) _tmp17_, &_tmp18_);
		color = _tmp18_;
		_tmp19_ = self->priv->customComponentDef;
		_tmp20_ = color;
		_tmp21_ = _tmp20_.red;
		((ComponentDef*) _tmp19_)->backgroundRed = (gint) (_tmp21_ * 255.0);
		_tmp22_ = self->priv->customComponentDef;
		_tmp23_ = color;
		_tmp24_ = _tmp23_.green;
		((ComponentDef*) _tmp22_)->backgroundGreen = (gint) (_tmp24_ * 255.0);
		_tmp25_ = self->priv->customComponentDef;
		_tmp26_ = color;
		_tmp27_ = _tmp26_.blue;
		((ComponentDef*) _tmp25_)->backgroundBlue = (gint) (_tmp27_ * 255.0);
		_tmp28_ = self->priv->customComponentDef;
		_tmp29_ = color;
		_tmp30_ = _tmp29_.alpha;
		((ComponentDef*) _tmp28_)->backgroundAlpha = (gint) (_tmp30_ * 255.0);
		_tmp31_ = self->priv->customComponentDef;
		_tmp32_ = self->priv->customComponentDef;
		_tmp33_ = ((ComponentDef*) _tmp32_)->backgroundAlpha;
		((ComponentDef*) _tmp31_)->backgroundAlphaF = ((gdouble) _tmp33_) / 255.0;
		_tmp34_ = self->priv->customComponentDef;
		_tmp35_ = self->priv->customComponentDef;
		_tmp36_ = ((ComponentDef*) _tmp35_)->backgroundRed;
		((ComponentDef*) _tmp34_)->backgroundRedF = ((gdouble) _tmp36_) / 255.0;
		_tmp37_ = self->priv->customComponentDef;
		_tmp38_ = self->priv->customComponentDef;
		_tmp39_ = ((ComponentDef*) _tmp38_)->backgroundGreen;
		((ComponentDef*) _tmp37_)->backgroundGreenF = ((gdouble) _tmp39_) / 255.0;
		_tmp40_ = self->priv->customComponentDef;
		_tmp41_ = self->priv->customComponentDef;
		_tmp42_ = ((ComponentDef*) _tmp41_)->backgroundBlue;
		((ComponentDef*) _tmp40_)->backgroundBlueF = ((gdouble) _tmp42_) / 255.0;
	}
	_tmp43_ = colorDialog;
	gtk_widget_destroy ((GtkWidget*) _tmp43_);
	customiser_render_def (self, NULL);
	_g_object_unref0 (colorDialog);
}


/**
 * Set generic information. Called when closing the dialog.
 */
void customiser_update_values (Customiser* self) {
	GtkEntry* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	CustomComponentDef* _tmp3_;
	const gchar* _tmp4_;
	CustomComponentDef* _tmp30_;
	GtkEntry* _tmp31_;
	const gchar* _tmp32_;
	const gchar* _tmp33_;
	gchar* _tmp34_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->nameEntry;
	_tmp1_ = gtk_entry_get_text (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->customComponentDef;
	_tmp4_ = ((ComponentDef*) _tmp3_)->name;
	if (g_strcmp0 (_tmp2_, _tmp4_) != 0) {
		Project* _tmp5_;
		GtkEntry* _tmp6_;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		ComponentDef* _tmp9_ = NULL;
		ComponentDef* _tmp10_;
		gboolean _tmp11_;
		_tmp5_ = self->priv->project;
		_tmp6_ = self->priv->nameEntry;
		_tmp7_ = gtk_entry_get_text (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = project_resolve_def_name (_tmp5_, _tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = _tmp10_ == NULL;
		_component_def_unref0 (_tmp10_);
		if (_tmp11_) {
			CustomComponentDef* _tmp12_;
			GtkEntry* _tmp13_;
			const gchar* _tmp14_;
			const gchar* _tmp15_;
			gchar* _tmp16_;
			_tmp12_ = self->priv->customComponentDef;
			_tmp13_ = self->priv->nameEntry;
			_tmp14_ = gtk_entry_get_text (_tmp13_);
			_tmp15_ = _tmp14_;
			_tmp16_ = g_strdup (_tmp15_);
			_g_free0 (((ComponentDef*) _tmp12_)->name);
			((ComponentDef*) _tmp12_)->name = _tmp16_;
		} else {
			GtkEntry* _tmp17_;
			const gchar* _tmp18_;
			const gchar* _tmp19_;
			gchar* _tmp20_;
			gchar* _tmp21_;
			gchar* _tmp22_;
			gchar* _tmp23_;
			CustomComponentDef* _tmp24_;
			const gchar* _tmp25_;
			gchar* _tmp26_;
			gchar* _tmp27_;
			gchar* _tmp28_;
			gchar* _tmp29_;
			_tmp17_ = self->priv->nameEntry;
			_tmp18_ = gtk_entry_get_text (_tmp17_);
			_tmp19_ = _tmp18_;
			_tmp20_ = g_strconcat ("A component with the name \"", _tmp19_, NULL);
			_tmp21_ = _tmp20_;
			_tmp22_ = g_strconcat (_tmp21_, "\" already exists. It may be a built-in component or a custom componen" \
"t. This component's name will remain \"", NULL);
			_tmp23_ = _tmp22_;
			_tmp24_ = self->priv->customComponentDef;
			_tmp25_ = ((ComponentDef*) _tmp24_)->name;
			_tmp26_ = g_strconcat (_tmp23_, _tmp25_, NULL);
			_tmp27_ = _tmp26_;
			_tmp28_ = g_strconcat (_tmp27_, "\".", NULL);
			_tmp29_ = _tmp28_;
			basic_dialog_error (NULL, _tmp29_);
			_g_free0 (_tmp29_);
			_g_free0 (_tmp27_);
			_g_free0 (_tmp23_);
			_g_free0 (_tmp21_);
		}
	}
	_tmp30_ = self->priv->customComponentDef;
	_tmp31_ = self->priv->descriptionEntry;
	_tmp32_ = gtk_entry_get_text (_tmp31_);
	_tmp33_ = _tmp32_;
	_tmp34_ = g_strdup (_tmp33_);
	_g_free0 (((ComponentDef*) _tmp30_)->description);
	((ComponentDef*) _tmp30_)->description = _tmp34_;
}


/**
 * Set, from radio buttons, what type of label a pin should use.
 */
void customiser_update_label_type (Customiser* self) {
	PinDef* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->selectedPin;
	if (_tmp0_ != NULL) {
		GtkRadioButton* _tmp1_;
		gboolean _tmp2_;
		gboolean _tmp3_;
		_tmp1_ = self->priv->labelTypeNoneRadio;
		_tmp2_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp1_);
		_tmp3_ = _tmp2_;
		if (_tmp3_) {
			PinDef* _tmp4_;
			_tmp4_ = self->priv->selectedPin;
			_tmp4_->labelType = PIN_DEF_LABEL_TYPE_NONE;
		} else {
			GtkRadioButton* _tmp5_;
			gboolean _tmp6_;
			gboolean _tmp7_;
			_tmp5_ = self->priv->labelTypeTextRadio;
			_tmp6_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp5_);
			_tmp7_ = _tmp6_;
			if (_tmp7_) {
				PinDef* _tmp8_;
				_tmp8_ = self->priv->selectedPin;
				_tmp8_->labelType = PIN_DEF_LABEL_TYPE_TEXT;
			} else {
				GtkRadioButton* _tmp9_;
				gboolean _tmp10_;
				gboolean _tmp11_;
				_tmp9_ = self->priv->labelTypeTextBarRadio;
				_tmp10_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp9_);
				_tmp11_ = _tmp10_;
				if (_tmp11_) {
					PinDef* _tmp12_;
					_tmp12_ = self->priv->selectedPin;
					_tmp12_->labelType = PIN_DEF_LABEL_TYPE_TEXTBAR;
				} else {
					GtkRadioButton* _tmp13_;
					gboolean _tmp14_;
					gboolean _tmp15_;
					_tmp13_ = self->priv->labelTypeClockRadio;
					_tmp14_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp13_);
					_tmp15_ = _tmp14_;
					if (_tmp15_) {
						PinDef* _tmp16_;
						_tmp16_ = self->priv->selectedPin;
						_tmp16_->labelType = PIN_DEF_LABEL_TYPE_CLOCK;
					}
				}
			}
		}
		customiser_render_def (self, NULL);
	}
}


/**
 * Set, from spin buttons, what the bounds of the component are.
 */
void customiser_update_bounds (Customiser* self) {
	CustomComponentDef* _tmp0_;
	GtkSpinButton* _tmp1_;
	gint _tmp2_ = 0;
	CustomComponentDef* _tmp3_;
	GtkSpinButton* _tmp4_;
	gint _tmp5_ = 0;
	CustomComponentDef* _tmp6_;
	GtkSpinButton* _tmp7_;
	gint _tmp8_ = 0;
	CustomComponentDef* _tmp9_;
	GtkSpinButton* _tmp10_;
	gint _tmp11_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->customComponentDef;
	_tmp1_ = self->priv->rightBoundSpinButton;
	_tmp2_ = gtk_spin_button_get_value_as_int (_tmp1_);
	((ComponentDef*) _tmp0_)->rightBound = _tmp2_;
	_tmp3_ = self->priv->customComponentDef;
	_tmp4_ = self->priv->downBoundSpinButton;
	_tmp5_ = gtk_spin_button_get_value_as_int (_tmp4_);
	((ComponentDef*) _tmp3_)->downBound = _tmp5_;
	_tmp6_ = self->priv->customComponentDef;
	_tmp7_ = self->priv->leftBoundSpinButton;
	_tmp8_ = gtk_spin_button_get_value_as_int (_tmp7_);
	((ComponentDef*) _tmp6_)->leftBound = _tmp8_;
	_tmp9_ = self->priv->customComponentDef;
	_tmp10_ = self->priv->upBoundSpinButton;
	_tmp11_ = gtk_spin_button_get_value_as_int (_tmp10_);
	((ComponentDef*) _tmp9_)->upBound = _tmp11_;
	customiser_render_def (self, NULL);
}


/**
 * Update widgets to show the information of the selected pin.
 */
void customiser_update_selection (Customiser* self) {
	CustomComponentDef* _tmp0_;
	PinDef** _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->customComponentDef;
	_tmp1_ = ((ComponentDef*) _tmp0_)->pinDefs;
	_tmp1__length1 = ((ComponentDef*) _tmp0_)->pinDefs_length1;
	if (_tmp1__length1 > 0) {
		GtkSpinButton* _tmp2_;
		gint _tmp3_ = 0;
		CustomComponentDef* _tmp4_;
		PinDef** _tmp5_;
		gint _tmp5__length1;
		gint _tmp6_;
		PinDef* _tmp7_;
		PinDef* _tmp8_;
		CustomComponentDef* _tmp9_;
		gint _tmp10_;
		Tag* _tmp11_ = NULL;
		PinDef* _tmp12_;
		PinDefLabelType _tmp13_;
		Tag* _tmp18_;
		GtkEntry* _tmp31_;
		PinDef* _tmp32_;
		const gchar* _tmp33_;
		GtkCheckButton* _tmp34_;
		PinDef* _tmp35_;
		gboolean _tmp36_;
		_tmp2_ = self->priv->pinSpinButton;
		_tmp3_ = gtk_spin_button_get_value_as_int (_tmp2_);
		self->priv->selectedPinID = _tmp3_;
		_tmp4_ = self->priv->customComponentDef;
		_tmp5_ = ((ComponentDef*) _tmp4_)->pinDefs;
		_tmp5__length1 = ((ComponentDef*) _tmp4_)->pinDefs_length1;
		_tmp6_ = self->priv->selectedPinID;
		_tmp7_ = _tmp5_[_tmp6_];
		_tmp8_ = _pin_def_ref0 (_tmp7_);
		_pin_def_unref0 (self->priv->selectedPin);
		self->priv->selectedPin = _tmp8_;
		_tmp9_ = self->priv->customComponentDef;
		_tmp10_ = self->priv->selectedPinID;
		_tmp11_ = custom_component_def_resolve_tag_id (_tmp9_, _tmp10_);
		_tag_unref0 (self->priv->tag);
		self->priv->tag = _tmp11_;
		_tmp12_ = self->priv->selectedPin;
		_tmp13_ = _tmp12_->labelType;
		switch (_tmp13_) {
			case PIN_DEF_LABEL_TYPE_NONE:
			{
				GtkRadioButton* _tmp14_;
				_tmp14_ = self->priv->labelTypeNoneRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp14_, TRUE);
				break;
			}
			case PIN_DEF_LABEL_TYPE_TEXT:
			{
				GtkRadioButton* _tmp15_;
				_tmp15_ = self->priv->labelTypeTextRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp15_, TRUE);
				break;
			}
			case PIN_DEF_LABEL_TYPE_TEXTBAR:
			{
				GtkRadioButton* _tmp16_;
				_tmp16_ = self->priv->labelTypeTextBarRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp16_, TRUE);
				break;
			}
			case PIN_DEF_LABEL_TYPE_CLOCK:
			{
				GtkRadioButton* _tmp17_;
				_tmp17_ = self->priv->labelTypeClockRadio;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp17_, TRUE);
				break;
			}
			default:
			break;
		}
		_tmp18_ = self->priv->tag;
		if (_tmp18_ != NULL) {
			GtkLabel* _tmp19_;
			Tag* _tmp20_;
			const gchar* _tmp21_;
			gchar* _tmp22_;
			gchar* _tmp23_;
			PinDef* _tmp24_;
			const gchar* _tmp25_;
			_tmp19_ = self->priv->tagNameLabel;
			_tmp20_ = self->priv->tag;
			_tmp21_ = _tmp20_->text;
			_tmp22_ = g_strconcat ("Maps to: ", _tmp21_, NULL);
			_tmp23_ = _tmp22_;
			gtk_label_set_label (_tmp19_, _tmp23_);
			_g_free0 (_tmp23_);
			_tmp24_ = self->priv->selectedPin;
			_tmp25_ = _tmp24_->label;
			if (g_strcmp0 (_tmp25_, "") == 0) {
				PinDef* _tmp26_;
				Tag* _tmp27_;
				const gchar* _tmp28_;
				gchar* _tmp29_;
				_tmp26_ = self->priv->selectedPin;
				_tmp27_ = self->priv->tag;
				_tmp28_ = _tmp27_->text;
				_tmp29_ = g_strdup (_tmp28_);
				_g_free0 (_tmp26_->label);
				_tmp26_->label = _tmp29_;
			}
		} else {
			GtkLabel* _tmp30_;
			_tmp30_ = self->priv->tagNameLabel;
			gtk_label_set_label (_tmp30_, "There is no matching tag!");
		}
		_tmp31_ = self->priv->pinLabelEntry;
		_tmp32_ = self->priv->selectedPin;
		_tmp33_ = _tmp32_->label;
		gtk_entry_set_text (_tmp31_, _tmp33_);
		_tmp34_ = self->priv->requiredCheck;
		_tmp35_ = self->priv->selectedPin;
		_tmp36_ = _tmp35_->required;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp34_, _tmp36_);
	} else {
		_pin_def_unref0 (self->priv->selectedPin);
		self->priv->selectedPin = NULL;
	}
	customiser_render_def (self, NULL);
}


/**
 * Render the current box design.
 */
static gpointer _cairo_reference0 (gpointer self) {
	return self ? cairo_reference (self) : NULL;
}


gboolean customiser_render_def (Customiser* self, cairo_t* passedDisplayContext) {
	gboolean result = FALSE;
	cairo_t* displayContext = NULL;
	gint width = 0;
	gint height = 0;
	GtkAllocation areaAllocation = {0};
	GtkDrawingArea* _tmp0_;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_;
	gint _tmp3_;
	GtkAllocation _tmp4_;
	gint _tmp5_;
	cairo_t* _tmp6_;
	cairo_t* _tmp12_;
	cairo_surface_t* _tmp13_ = NULL;
	gint _tmp14_;
	gint _tmp15_;
	cairo_surface_t* _tmp16_;
	cairo_surface_t* offScreenSurface;
	cairo_surface_t* _tmp17_;
	cairo_t* _tmp18_;
	cairo_t* context;
	cairo_t* _tmp19_;
	cairo_surface_t* _tmp20_;
	cairo_t* _tmp21_;
	gboolean _tmp22_ = FALSE;
	DesignerWindow* _tmp23_;
	gboolean _tmp26_;
	cairo_t* _tmp107_;
	gint _tmp108_;
	gint _tmp109_;
	cairo_t* _tmp110_;
	gfloat _tmp111_;
	gfloat _tmp112_;
	cairo_t* _tmp113_;
	gint _tmp114_;
	gint _tmp115_;
	cairo_t* _tmp116_;
	CustomComponentDef* _tmp117_;
	cairo_t* _tmp118_;
	cairo_t* _tmp136_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->display;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	areaAllocation = _tmp1_;
	_tmp2_ = areaAllocation;
	_tmp3_ = _tmp2_.width;
	width = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.height;
	height = _tmp5_;
	_tmp6_ = passedDisplayContext;
	if (_tmp6_ == NULL) {
		GtkDrawingArea* _tmp7_;
		GdkWindow* _tmp8_ = NULL;
		cairo_t* _tmp9_ = NULL;
		_tmp7_ = self->priv->display;
		_tmp8_ = gtk_widget_get_window ((GtkWidget*) _tmp7_);
		_tmp9_ = gdk_cairo_create (_tmp8_);
		_cairo_destroy0 (displayContext);
		displayContext = _tmp9_;
	} else {
		cairo_t* _tmp10_;
		cairo_t* _tmp11_;
		_tmp10_ = passedDisplayContext;
		_tmp11_ = _cairo_reference0 (_tmp10_);
		_cairo_destroy0 (displayContext);
		displayContext = _tmp11_;
	}
	_tmp12_ = displayContext;
	_tmp13_ = cairo_get_target (_tmp12_);
	_tmp14_ = width;
	_tmp15_ = height;
	_tmp16_ = cairo_surface_create_similar (_tmp13_, CAIRO_CONTENT_COLOR, _tmp14_, _tmp15_);
	offScreenSurface = _tmp16_;
	_tmp17_ = offScreenSurface;
	_tmp18_ = cairo_create (_tmp17_);
	context = _tmp18_;
	_tmp19_ = displayContext;
	_tmp20_ = offScreenSurface;
	cairo_set_source_surface (_tmp19_, _tmp20_, (gdouble) 0, (gdouble) 0);
	_tmp21_ = context;
	cairo_set_line_width (_tmp21_, (gdouble) 1);
	_tmp23_ = self->priv->parent;
	if (_tmp23_ != NULL) {
		DesignerWindow* _tmp24_;
		gboolean _tmp25_;
		_tmp24_ = self->priv->parent;
		_tmp25_ = _tmp24_->showGrid;
		_tmp22_ = _tmp25_;
	} else {
		_tmp22_ = FALSE;
	}
	_tmp26_ = _tmp22_;
	if (_tmp26_) {
		cairo_surface_t* _tmp27_;
		cairo_t* _tmp102_;
		cairo_surface_t* _tmp103_;
		cairo_t* _tmp104_;
		_tmp27_ = self->priv->gridCache;
		if (_tmp27_ == NULL) {
			cairo_t* _tmp28_;
			cairo_surface_t* _tmp29_ = NULL;
			cairo_t* _tmp30_;
			cairo_surface_t* _tmp31_ = NULL;
			cairo_content_t _tmp32_ = 0;
			gint _tmp33_;
			gint _tmp34_;
			cairo_surface_t* _tmp35_;
			cairo_surface_t* _tmp36_;
			cairo_t* _tmp37_;
			cairo_t* gridContext;
			cairo_t* _tmp38_;
			cairo_t* _tmp39_;
			gfloat _tmp40_;
			DesignerWindow* _tmp41_;
			gint _tmp42_;
			gfloat spacing;
			gint _tmp47_;
			gint _tmp48_;
			gfloat _tmp49_;
			gfloat _tmp50_;
			gfloat y;
			gint _tmp51_;
			gint _tmp52_;
			gfloat _tmp53_;
			gfloat _tmp54_;
			gfloat x;
			cairo_t* _tmp55_;
			cairo_t* _tmp56_;
			gfloat _tmp57_;
			gdouble* _tmp58_ = NULL;
			gdouble* _tmp59_;
			gint _tmp59__length1;
			gfloat _tmp73_;
			gint _tmp74_;
			gint _tmp75_;
			gfloat _tmp76_;
			gfloat _tmp77_;
			gint _tmp78_;
			gint _tmp79_;
			gfloat _tmp80_;
			gfloat _tmp81_;
			cairo_t* _tmp82_;
			cairo_t* _tmp83_;
			gfloat _tmp84_;
			gdouble* _tmp85_ = NULL;
			gdouble* _tmp86_;
			gint _tmp86__length1;
			cairo_t* _tmp100_;
			cairo_t* _tmp101_;
			_tmp28_ = context;
			_tmp29_ = cairo_get_target (_tmp28_);
			_tmp30_ = context;
			_tmp31_ = cairo_get_target (_tmp30_);
			_tmp32_ = cairo_surface_get_content (_tmp31_);
			_tmp33_ = width;
			_tmp34_ = height;
			_tmp35_ = cairo_surface_create_similar (_tmp29_, _tmp32_, _tmp33_, _tmp34_);
			_cairo_surface_destroy0 (self->priv->gridCache);
			self->priv->gridCache = _tmp35_;
			_tmp36_ = self->priv->gridCache;
			_tmp37_ = cairo_create (_tmp36_);
			gridContext = _tmp37_;
			_tmp38_ = gridContext;
			cairo_set_source_rgb (_tmp38_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
			_tmp39_ = gridContext;
			cairo_paint (_tmp39_);
			_tmp40_ = self->zoom;
			_tmp41_ = self->priv->parent;
			_tmp42_ = _tmp41_->gridSize;
			spacing = _tmp40_ * _tmp42_;
			while (TRUE) {
				gfloat _tmp43_;
				gfloat _tmp44_;
				DesignerWindow* _tmp45_;
				gint _tmp46_;
				_tmp43_ = spacing;
				if (!(_tmp43_ < ((gfloat) 2))) {
					break;
				}
				_tmp44_ = spacing;
				_tmp45_ = self->priv->parent;
				_tmp46_ = _tmp45_->gridSize;
				spacing = _tmp44_ * _tmp46_;
			}
			_tmp47_ = height;
			_tmp48_ = self->priv->yView;
			_tmp49_ = self->zoom;
			_tmp50_ = spacing;
			y = fmodf ((_tmp47_ / 2) - (((gfloat) _tmp48_) * _tmp49_), _tmp50_);
			_tmp51_ = width;
			_tmp52_ = self->priv->xView;
			_tmp53_ = self->zoom;
			_tmp54_ = spacing;
			x = fmodf ((_tmp51_ / 2) - (((gfloat) _tmp52_) * _tmp53_), _tmp54_);
			_tmp55_ = gridContext;
			cairo_set_source_rgba (_tmp55_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.5);
			_tmp56_ = gridContext;
			_tmp57_ = spacing;
			_tmp58_ = g_new0 (gdouble, 2);
			_tmp58_[0] = 1.0;
			_tmp58_[1] = _tmp57_ - 1.0;
			_tmp59_ = _tmp58_;
			_tmp59__length1 = 2;
			cairo_set_dash (_tmp56_, _tmp59_, 2, (gdouble) 0);
			_tmp59_ = (g_free (_tmp59_), NULL);
			{
				gboolean _tmp60_;
				_tmp60_ = TRUE;
				while (TRUE) {
					gboolean _tmp61_;
					gfloat _tmp64_;
					gint _tmp65_;
					cairo_t* _tmp66_;
					gfloat _tmp67_;
					gfloat _tmp68_;
					cairo_t* _tmp69_;
					gint _tmp70_;
					gfloat _tmp71_;
					cairo_t* _tmp72_;
					_tmp61_ = _tmp60_;
					if (!_tmp61_) {
						gfloat _tmp62_;
						gfloat _tmp63_;
						_tmp62_ = y;
						_tmp63_ = spacing;
						y = _tmp62_ + _tmp63_;
					}
					_tmp60_ = FALSE;
					_tmp64_ = y;
					_tmp65_ = height;
					if (!(_tmp64_ < ((gfloat) _tmp65_))) {
						break;
					}
					_tmp66_ = gridContext;
					_tmp67_ = x;
					_tmp68_ = y;
					cairo_move_to (_tmp66_, (gdouble) _tmp67_, (gdouble) _tmp68_);
					_tmp69_ = gridContext;
					_tmp70_ = width;
					_tmp71_ = y;
					cairo_line_to (_tmp69_, (gdouble) _tmp70_, (gdouble) _tmp71_);
					_tmp72_ = gridContext;
					cairo_stroke (_tmp72_);
				}
			}
			_tmp73_ = spacing;
			spacing = _tmp73_ * 4;
			_tmp74_ = height;
			_tmp75_ = self->priv->yView;
			_tmp76_ = self->zoom;
			_tmp77_ = spacing;
			y = fmodf ((_tmp74_ / 2) - (((gfloat) _tmp75_) * _tmp76_), _tmp77_);
			_tmp78_ = width;
			_tmp79_ = self->priv->xView;
			_tmp80_ = self->zoom;
			_tmp81_ = spacing;
			x = fmodf ((_tmp78_ / 2) - (((gfloat) _tmp79_) * _tmp80_), _tmp81_);
			_tmp82_ = gridContext;
			cairo_set_source_rgba (_tmp82_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 1.0);
			_tmp83_ = gridContext;
			_tmp84_ = spacing;
			_tmp85_ = g_new0 (gdouble, 2);
			_tmp85_[0] = 1.0;
			_tmp85_[1] = _tmp84_ - 1.0;
			_tmp86_ = _tmp85_;
			_tmp86__length1 = 2;
			cairo_set_dash (_tmp83_, _tmp86_, 2, (gdouble) 0);
			_tmp86_ = (g_free (_tmp86_), NULL);
			{
				gboolean _tmp87_;
				_tmp87_ = TRUE;
				while (TRUE) {
					gboolean _tmp88_;
					gfloat _tmp91_;
					gint _tmp92_;
					cairo_t* _tmp93_;
					gfloat _tmp94_;
					gfloat _tmp95_;
					cairo_t* _tmp96_;
					gint _tmp97_;
					gfloat _tmp98_;
					cairo_t* _tmp99_;
					_tmp88_ = _tmp87_;
					if (!_tmp88_) {
						gfloat _tmp89_;
						gfloat _tmp90_;
						_tmp89_ = y;
						_tmp90_ = spacing;
						y = _tmp89_ + _tmp90_;
					}
					_tmp87_ = FALSE;
					_tmp91_ = y;
					_tmp92_ = height;
					if (!(_tmp91_ < ((gfloat) _tmp92_))) {
						break;
					}
					_tmp93_ = gridContext;
					_tmp94_ = x;
					_tmp95_ = y;
					cairo_move_to (_tmp93_, (gdouble) _tmp94_, (gdouble) _tmp95_);
					_tmp96_ = gridContext;
					_tmp97_ = width;
					_tmp98_ = y;
					cairo_line_to (_tmp96_, (gdouble) _tmp97_, (gdouble) _tmp98_);
					_tmp99_ = gridContext;
					cairo_stroke (_tmp99_);
				}
			}
			_tmp100_ = gridContext;
			cairo_set_dash (_tmp100_, NULL, 0, (gdouble) 0);
			_tmp101_ = gridContext;
			cairo_set_source_rgba (_tmp101_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 1);
			_cairo_destroy0 (gridContext);
		}
		_tmp102_ = context;
		_tmp103_ = self->priv->gridCache;
		cairo_set_source_surface (_tmp102_, _tmp103_, (gdouble) 0, (gdouble) 0);
		_tmp104_ = context;
		cairo_paint (_tmp104_);
	} else {
		cairo_t* _tmp105_;
		cairo_t* _tmp106_;
		_tmp105_ = context;
		cairo_set_source_rgb (_tmp105_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
		_tmp106_ = context;
		cairo_paint (_tmp106_);
	}
	_tmp107_ = context;
	_tmp108_ = width;
	_tmp109_ = height;
	cairo_translate (_tmp107_, (gdouble) (_tmp108_ / 2), (gdouble) (_tmp109_ / 2));
	_tmp110_ = context;
	_tmp111_ = self->zoom;
	_tmp112_ = self->zoom;
	cairo_scale (_tmp110_, (gdouble) _tmp111_, (gdouble) _tmp112_);
	_tmp113_ = context;
	_tmp114_ = self->priv->xView;
	_tmp115_ = self->priv->yView;
	cairo_translate (_tmp113_, (gdouble) (-_tmp114_), (gdouble) (-_tmp115_));
	_tmp116_ = context;
	cairo_set_source_rgb (_tmp116_, (gdouble) 0, (gdouble) 0, (gdouble) 0);
	_tmp117_ = self->priv->customComponentDef;
	_tmp118_ = context;
	component_def_render ((ComponentDef*) _tmp117_, _tmp118_, DIRECTION_RIGHT, FALSE, NULL, TRUE);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp119_;
			_tmp119_ = TRUE;
			while (TRUE) {
				gboolean _tmp120_;
				gint _tmp122_;
				CustomComponentDef* _tmp123_;
				PinDef** _tmp124_;
				gint _tmp124__length1;
				CustomComponentDef* _tmp125_;
				PinDef** _tmp126_;
				gint _tmp126__length1;
				gint _tmp127_;
				PinDef* _tmp128_;
				PinDef* _tmp129_;
				PinDef* pinDef;
				gint _tmp130_;
				gint _tmp131_;
				PinDef* _tmp134_;
				cairo_t* _tmp135_;
				_tmp120_ = _tmp119_;
				if (!_tmp120_) {
					gint _tmp121_;
					_tmp121_ = i;
					i = _tmp121_ + 1;
				}
				_tmp119_ = FALSE;
				_tmp122_ = i;
				_tmp123_ = self->priv->customComponentDef;
				_tmp124_ = ((ComponentDef*) _tmp123_)->pinDefs;
				_tmp124__length1 = ((ComponentDef*) _tmp123_)->pinDefs_length1;
				if (!(_tmp122_ < _tmp124__length1)) {
					break;
				}
				_tmp125_ = self->priv->customComponentDef;
				_tmp126_ = ((ComponentDef*) _tmp125_)->pinDefs;
				_tmp126__length1 = ((ComponentDef*) _tmp125_)->pinDefs_length1;
				_tmp127_ = i;
				_tmp128_ = _tmp126_[_tmp127_];
				_tmp129_ = _pin_def_ref0 (_tmp128_);
				pinDef = _tmp129_;
				_tmp130_ = self->priv->selectedPinID;
				_tmp131_ = i;
				if (_tmp130_ == _tmp131_) {
					cairo_t* _tmp132_;
					_tmp132_ = context;
					cairo_set_source_rgb (_tmp132_, (gdouble) 0, (gdouble) 0, (gdouble) 1);
				} else {
					cairo_t* _tmp133_;
					_tmp133_ = context;
					cairo_set_source_rgb (_tmp133_, (gdouble) 0, (gdouble) 0, (gdouble) 0);
				}
				_tmp134_ = pinDef;
				_tmp135_ = context;
				pin_def_render (_tmp134_, _tmp135_, FALSE);
				_pin_def_unref0 (pinDef);
			}
		}
	}
	_tmp136_ = displayContext;
	cairo_paint (_tmp136_);
	result = FALSE;
	_cairo_destroy0 (context);
	_cairo_surface_destroy0 (offScreenSurface);
	_cairo_destroy0 (displayContext);
	return result;
}


static void value_customiser_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_customiser_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		customiser_unref (value->data[0].v_pointer);
	}
}


static void value_customiser_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = customiser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_customiser_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_customiser_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Customiser* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = customiser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_customiser_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Customiser** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = customiser_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_customiser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecCustomiser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_CUSTOMISER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_customiser (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CUSTOMISER), NULL);
	return value->data[0].v_pointer;
}


void value_set_customiser (GValue* value, gpointer v_object) {
	Customiser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CUSTOMISER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CUSTOMISER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		customiser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		customiser_unref (old);
	}
}


void value_take_customiser (GValue* value, gpointer v_object) {
	Customiser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CUSTOMISER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CUSTOMISER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		customiser_unref (old);
	}
}


static void customiser_class_init (CustomiserClass * klass) {
	customiser_parent_class = g_type_class_peek_parent (klass);
	CUSTOMISER_CLASS (klass)->finalize = customiser_finalize;
	g_type_class_add_private (klass, sizeof (CustomiserPrivate));
}


static void customiser_instance_init (Customiser * self) {
	self->priv = CUSTOMISER_GET_PRIVATE (self);
	self->gridSize = 5;
	self->priv->xView = 0;
	self->priv->yView = 0;
	self->zoom = (gfloat) 1;
	self->priv->mouseMode = CUSTOMISER_MOUSE_MODE_PIN;
	self->priv->selectedPinID = 0;
	self->ref_count = 1;
}


static void customiser_finalize (Customiser* obj) {
	Customiser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CUSTOMISER, Customiser);
	_g_object_unref0 (self->priv->dialog);
	_g_object_unref0 (self->priv->layoutHBox);
	_g_object_unref0 (self->priv->layoutVBox);
	_g_object_unref0 (self->priv->hiddenRadioToolButton);
	_g_object_unref0 (self->priv->toolbar);
	_g_object_unref0 (self->priv->toolScroll);
	_g_object_unref0 (self->priv->toolScrollImage);
	_g_object_unref0 (self->priv->toolZoom);
	_g_object_unref0 (self->priv->toolZoomImage);
	_g_object_unref0 (self->priv->toolSeparator1);
	_g_object_unref0 (self->priv->toolPin);
	_g_object_unref0 (self->priv->toolPinImage);
	_g_object_unref0 (self->priv->controller);
	_g_object_unref0 (self->priv->display);
	_g_object_unref0 (self->priv->controlsVBox);
	_g_object_unref0 (self->priv->nameHBox);
	_g_object_unref0 (self->priv->nameEntry);
	_g_object_unref0 (self->priv->nameLabel);
	_g_object_unref0 (self->priv->descriptionHBox);
	_g_object_unref0 (self->priv->descriptionEntry);
	_g_object_unref0 (self->priv->descriptionLabel);
	_g_object_unref0 (self->priv->labelHBox);
	_g_object_unref0 (self->priv->labelEntry);
	_g_object_unref0 (self->priv->labelLabel);
	_g_object_unref0 (self->priv->pinHBox);
	_g_object_unref0 (self->priv->pinSpinButton);
	_g_object_unref0 (self->priv->pinLabel);
	_g_object_unref0 (self->priv->tagNameLabel);
	_g_object_unref0 (self->priv->requiredCheck);
	_g_object_unref0 (self->priv->labelTypeVBox);
	_g_object_unref0 (self->priv->labelTypeLabel);
	_g_object_unref0 (self->priv->labelTypeNoneRadio);
	_g_object_unref0 (self->priv->labelTypeTextRadio);
	_g_object_unref0 (self->priv->labelTypeTextBarRadio);
	_g_object_unref0 (self->priv->labelTypeClockRadio);
	_g_object_unref0 (self->priv->pinLabelHBox);
	_g_object_unref0 (self->priv->pinLabelEntry);
	_g_object_unref0 (self->priv->pinLabelLabel);
	_g_object_unref0 (self->priv->boundsLabel);
	_g_object_unref0 (self->priv->boundsGrid);
	_g_object_unref0 (self->priv->rightBoundLabel);
	_g_object_unref0 (self->priv->rightBoundSpinButton);
	_g_object_unref0 (self->priv->downBoundLabel);
	_g_object_unref0 (self->priv->downBoundSpinButton);
	_g_object_unref0 (self->priv->leftBoundLabel);
	_g_object_unref0 (self->priv->leftBoundSpinButton);
	_g_object_unref0 (self->priv->upBoundLabel);
	_g_object_unref0 (self->priv->upBoundSpinButton);
	_g_object_unref0 (self->priv->colourButton);
	_g_object_unref0 (self->priv->closeButton);
	_cairo_surface_destroy0 (self->priv->gridCache);
	_component_def_unref0 (self->priv->customComponentDef);
	_g_object_unref0 (self->priv->parent);
	_project_unref0 (self->priv->project);
	_pin_def_unref0 (self->priv->selectedPin);
	_tag_unref0 (self->priv->tag);
}


/**
 * User interface element used to customise a component.
 * 
 * Allows a user to design how a custom component can be used in another
 * component.
 * Used to edit names and descriptions, create a box design, and
 * configure pins.
 */
GType customiser_get_type (void) {
	static volatile gsize customiser_type_id__volatile = 0;
	if (g_once_init_enter (&customiser_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_customiser_init, value_customiser_free_value, value_customiser_copy_value, value_customiser_peek_pointer, "p", value_customiser_collect_value, "p", value_customiser_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (CustomiserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) customiser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Customiser), 0, (GInstanceInitFunc) customiser_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType customiser_type_id;
		customiser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Customiser", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&customiser_type_id__volatile, customiser_type_id);
	}
	return customiser_type_id__volatile;
}


gpointer customiser_ref (gpointer instance) {
	Customiser* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void customiser_unref (gpointer instance) {
	Customiser* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		CUSTOMISER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



